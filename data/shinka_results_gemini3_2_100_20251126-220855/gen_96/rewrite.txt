# EVOLVE-BLOCK-START
"""S3-LRU with Windowed Promotion and Probabilistic Anchor"""
import random
import itertools

# Global State
# s3_small: FIFO queue for the small segment (probation)
# s3_main: LRU queue for the main segment (protected)
# s3_ghost: Ghost cache for tracking eviction from small
# s3_freq: Frequency counter for objects (max 3)
s3_small = {}
s3_main = {}
s3_ghost = {}
s3_freq = {}

def evict(cache_snapshot, obj):
    '''
    S3-LRU with Windowed Promotion and Probabilistic Anchor.
    
    Hybrid Strategy:
    - Main Segment: LRU with Second Chance. Best for strong temporal locality.
    - Small Segment: FIFO with Windowed Promotion.
      - Scans first K=5 items for any 'hot' item (freq > 0) to promote.
      - If none found, tries Probabilistic Promotion (1%) to anchor loop items.
      - If no promotion, evicts the HEAD (Strict FIFO). This preserves recency info 
        better than random eviction.
    - Ghost: 3x capacity to catch long-range recurrences.
    '''
    global s3_small, s3_main, s3_ghost, s3_freq

    capacity = cache_snapshot.capacity
    
    # Jittered Small Capacity (10% +/- 1%)
    # Noise breaks synchronized thrashing
    noise = max(1, int(capacity * 0.01))
    s_capacity = max(1, int(capacity * 0.1) + random.randint(-noise, noise))

    # Extended Ghost Cleanup (3x)
    while len(s3_ghost) > 3 * capacity:
        s3_ghost.pop(next(iter(s3_ghost)))
        
    k_window = 5

    while True:
        # Decision: Small or Main?
        # Evict from Small if it's too big, or if Main is empty
        if len(s3_small) >= s_capacity or not s3_main:
            if not s3_small:
                return None
            
            # Windowed Scan for Promotion
            # Check first K items. If any is hot, promote it.
            candidates = list(itertools.islice(s3_small, k_window))
            promoted_key = None
            
            for cand in candidates:
                freq = s3_freq.get(cand, 0)
                
                # 1. Merit Promotion (Hit in Small)
                if freq > 0:
                    promoted_key = cand
                    break
                
                # 2. Probabilistic Promotion (1%)
                # Anchors items from scan/loop patterns into Main
                if (cache_snapshot.access_count ^ hash(cand)) % 100 == 0:
                    promoted_key = cand
                    break
            
            if promoted_key:
                # Promote to Main
                s3_small.pop(promoted_key)
                s3_main[promoted_key] = None
                s3_freq[promoted_key] = 0 # Reset freq on promotion
                continue
                
            # No promotion candidate found in window.
            # Evict the Head (Strict FIFO).
            # We explicitly choose the Head (candidates[0]) to preserve the FIFO 
            # property for the eviction victim, which is optimal for Recency workloads.
            return candidates[0]

        else:
            # Evict from Main (LRU + Second Chance)
            candidate = next(iter(s3_main))
            freq = s3_freq.get(candidate, 0)

            if freq > 0:
                # Second Chance: Reinsert at MRU (tail) and decrement freq
                s3_main.pop(candidate)
                s3_main[candidate] = None
                s3_freq[candidate] = freq - 1
                continue
            
            return candidate

def update_after_hit(cache_snapshot, obj):
    '''
    On Hit:
    - Increment frequency (capped at 3).
    - If in Main, move to MRU (True LRU).
    '''
    global s3_freq, s3_main
    key = obj.key
    s3_freq[key] = min(s3_freq.get(key, 0) + 1, 3)

    if key in s3_main:
        # LRU Update: Move to MRU
        val = s3_main.pop(key)
        s3_main[key] = val

def update_after_insert(cache_snapshot, obj):
    '''
    On Insert:
    - Check Ghost -> Main (Rescue).
    - Else -> Small (Probation).
    '''
    global s3_small, s3_main, s3_ghost, s3_freq
    key = obj.key
    s3_freq[key] = 0

    if key in s3_ghost:
        s3_main[key] = None
        s3_ghost.pop(key)
    else:
        s3_small[key] = None

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    On Evict:
    - Cleanup queues.
    - Small evictions go to Ghost.
    '''
    global s3_small, s3_main, s3_ghost, s3_freq
    key = evicted_obj.key

    if key in s3_small:
        s3_small.pop(key)
        s3_ghost[key] = None
    elif key in s3_main:
        s3_main.pop(key)

    if key in s3_freq:
        s3_freq.pop(key)
# EVOLVE-BLOCK-END