# EVOLVE-BLOCK-START
from collections import OrderedDict

# S3-FIFO Global State
# m_small: FIFO queue for new/probationary items
# m_main: FIFO queue for protected/frequent items
# m_ghost_s: Ghost history for items evicted from Small
# m_ghost_m: Ghost history for items evicted from Main
# m_freq: Frequency counter for items (simulates access bits)
# m_ratio: Target ratio for the Small queue size (0.0 to 1.0)
m_small = OrderedDict()
m_main = OrderedDict()
m_ghost_s = OrderedDict()
m_ghost_m = OrderedDict()
m_freq = {}
m_ratio = 0.1
m_last_access_count = 0

def check_reset(cache_snapshot):
    '''
    Detects if the trace has changed/reset and clears internal state.
    '''
    global m_last_access_count, m_small, m_main, m_ghost_s, m_ghost_m, m_freq, m_ratio
    current_count = cache_snapshot.access_count
    if current_count < m_last_access_count:
        m_small.clear()
        m_main.clear()
        m_ghost_s.clear()
        m_ghost_m.clear()
        m_freq.clear()
        m_ratio = 0.1
    m_last_access_count = current_count

def evict(cache_snapshot, obj):
    '''
    Adaptive S3-FIFO Eviction Policy.
    - Adapts partition size (S vs M) based on ghost hits.
    - Selects victim from S or M based on size targets and access history.
    '''
    check_reset(cache_snapshot)
    global m_ratio, m_small, m_main, m_ghost_s, m_ghost_m, m_freq

    capacity = cache_snapshot.capacity
    
    # 1. Adapt S/M Partition Ratio
    # If the missing object (obj) is in a ghost list, it indicates we evicted it too early.
    if obj.key in m_ghost_s:
        # Ghost S hit -> S was too small, increase target S size
        m_ratio = min(0.9, m_ratio + 0.02)
    elif obj.key in m_ghost_m:
        # Ghost M hit -> M was too small (S too big), decrease target S size
        m_ratio = max(0.01, m_ratio - 0.02)

    target_s = max(1, int(capacity * m_ratio))
    
    # 2. Select Victim
    # We loop to apply the "Second Chance" logic (clearing access bits and moving items).
    # We limit attempts to avoid infinite loops in pathological cases (though access bits are cleared).
    attempts = 0
    max_attempts = len(m_small) + len(m_main) + 10 # Safety buffer
    
    while attempts < max_attempts:
        attempts += 1
        
        # Determine which queue to examine
        # Prefer evicting from S if it exceeds target size.
        # But if M is empty, we must evict from S.
        evict_from_s = False
        if len(m_small) >= target_s or len(m_main) == 0:
            evict_from_s = True
            
        if evict_from_s:
            if not m_small:
                # Should not happen if logic correct, but fallback to M
                if m_main:
                    evict_from_s = False
                else:
                    break # Both empty?

        if evict_from_s:
            # Check candidate from Small queue
            key = next(iter(m_small))
            freq = m_freq.get(key, 0)
            
            if freq > 0:
                # Has been accessed: Promote to Main
                m_small.popitem(last=False) # Remove from S head
                m_main[key] = None          # Append to M tail
                m_freq[key] = 0             # Clear access bit/freq
            else:
                # Not accessed: Evict this candidate
                return key
        else:
            # Check candidate from Main queue
            key = next(iter(m_main))
            freq = m_freq.get(key, 0)
            
            if freq > 0:
                # Has been accessed: Reinsert to Main tail
                m_main.move_to_end(key)
                m_freq[key] = 0             # Clear access bit/freq
            else:
                # Not accessed: Evict this candidate
                return key
                
    # Fallback if internal state is inconsistent with cache_snapshot
    # Return any key from the cache snapshot that exists
    if cache_snapshot.cache:
        return next(iter(cache_snapshot.cache))
    return None

def update_after_hit(cache_snapshot, obj):
    '''
    On hit, update frequency counter.
    S3-FIFO does not move items on hit (lazy promotion).
    '''
    check_reset(cache_snapshot)
    global m_freq
    # Cap frequency at 3 (2 bits effectively) to distinguish frequent items
    m_freq[obj.key] = min(m_freq.get(obj.key, 0) + 1, 3)

def update_after_insert(cache_snapshot, obj):
    '''
    On insert, add to Small queue and clear ghost entries.
    '''
    check_reset(cache_snapshot)
    global m_small, m_freq, m_ghost_s, m_ghost_m
    
    key = obj.key
    # Remove from ghosts if present (it's now back in cache)
    if key in m_ghost_s:
        del m_ghost_s[key]
    if key in m_ghost_m:
        del m_ghost_m[key]
        
    # Insert new item into Small queue
    m_small[key] = None
    m_freq[key] = 0

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    After eviction, remove from queues and add to ghost lists.
    '''
    check_reset(cache_snapshot)
    global m_small, m_main, m_ghost_s, m_ghost_m, m_freq
    
    key = evicted_obj.key
    capacity = cache_snapshot.capacity
    
    # Remove from our internal queues
    # The item should be at the head of one of them usually, or removed during evict() selection?
    # No, evict() only *returns* the key. It does not delete the victim from m_small/m_main 
    # if it returns it. It only moves *kept* items.
    if key in m_small:
        del m_small[key]
        m_ghost_s[key] = None
    elif key in m_main:
        del m_main[key]
        m_ghost_m[key] = None
        
    if key in m_freq:
        del m_freq[key]
        
    # Maintain ghost sizes (e.g., up to capacity size each)
    if len(m_ghost_s) > capacity:
        m_ghost_s.popitem(last=False)
    if len(m_ghost_m) > capacity:
        m_ghost_m.popitem(last=False)
# EVOLVE-BLOCK-END