# EVOLVE-BLOCK-START
"""Cache eviction algorithm: S3-FIFO with LIFO-Small, Ghost-Freq, and Aging"""
from collections import OrderedDict
import random

# Global State
s3_small = OrderedDict() # Small/Probationary items (LIFO Eviction)
s3_main = OrderedDict()  # Main/Protected items (LRU Eviction)
s3_ghost = OrderedDict() # Ghost registry: key -> freq at eviction
s3_freq = {}             # Frequency map: key -> count
s3_config = {}           # Configuration parameters
ops_count = 0

def _reset_state(cache_snapshot):
    """Resets global state if a new trace is detected."""
    global s3_small, s3_main, s3_ghost, s3_freq, s3_config, ops_count
    # Detect reset via access count rollback
    if cache_snapshot.access_count < ops_count:
        s3_small.clear()
        s3_main.clear()
        s3_ghost.clear()
        s3_freq.clear()
        s3_config.clear()
    ops_count = cache_snapshot.access_count
    
    # Initialize config once per trace
    if not s3_config:
        cap = cache_snapshot.capacity
        s3_config['small_ratio'] = 0.1
        # Jitter: Allow target to fluctuate significantly to enable rotation/adaptation
        # Use 15% range to force frequent shifts between Main and Small eviction
        s3_config['jitter_range'] = max(1, int(cap * 0.15)) 
        # Aging interval: Decay frequencies every 'capacity' operations
        s3_config['age_interval'] = cap
        s3_config['next_age'] = cap

def _perform_aging():
    """Decay frequency counters to prioritize recent popularity."""
    global s3_freq
    for k in s3_freq:
        s3_freq[k] >>= 1 # Integer divide by 2

def evict(cache_snapshot, obj):
    '''
    S3-FIFO Hardened Eviction Policy:
    - Calculates a jittered target size for Small.
    - If Small is over target (or Main empty): Evict from Small using LIFO (Tail).
      - This protects the 'Head' of Small (older items) and effectively handles loops > capacity.
    - Else: Evict from Main using LRU (Head).
    '''
    _reset_state(cache_snapshot)
    global ops_count
    
    capacity = cache_snapshot.capacity
    
    # Periodic Frequency Aging
    if ops_count >= s3_config.get('next_age', float('inf')):
        _perform_aging()
        s3_config['next_age'] = ops_count + s3_config['age_interval']
    
    # Dynamic Target for Small (Jitter prevents LIFO lock-up)
    jitter = random.randint(-s3_config['jitter_range'], s3_config['jitter_range'])
    target_small = max(1, int(capacity * s3_config['small_ratio']) + jitter)
    
    # 1. Check Small Queue (LIFO Eviction Strategy)
    # Evict from Small if it exceeds target OR if Main is empty
    if len(s3_small) > target_small or len(s3_main) == 0:
        # LIFO: Pick from Tail (Most Recently Inserted)
        # This acts as a filter for scans and loops.
        
        # Loop for "Lucky Save" (Anti-Thrashing)
        for _ in range(3):
            if not s3_small: break
            victim_key, _ = s3_small.popitem(last=True) # Pop Tail
            
            # Lucky Save (1%): Move to Head (Safe Zone)
            # Helps retain items that might be useful but got caught in LIFO churn
            if random.random() < 0.01:
                s3_small[victim_key] = 1
                s3_small.move_to_end(victim_key, last=False) # Move to Head
                continue
            else:
                # Restore to Tail (at the end) to maintain state consistency
                # The harness will evict this key, and update_after_evict will handle cleanup.
                s3_small[victim_key] = 1
                return victim_key
        
        # Fallback if loop exhausted (return Tail)
        if s3_small:
            return next(reversed(s3_small))
    
    # 2. Check Main Queue (LRU Eviction Strategy)
    # LRU is at Head of s3_main
    if s3_main:
        return next(iter(s3_main))
    
    # Emergency fallback
    return next(iter(s3_small)) if s3_small else None

def update_after_hit(cache_snapshot, obj):
    '''
    On Hit:
    - Main: Move to MRU (True LRU).
    - Small: Increment Freq. Move to Head (Safety). Promote if Freq >= 2.
    '''
    _reset_state(cache_snapshot)
    key = obj.key
    
    if key in s3_main:
        s3_main.move_to_end(key)
    elif key in s3_small:
        f = s3_freq.get(key, 0) + 1
        s3_freq[key] = f
        
        # Move to Head (Safety from LIFO eviction at Tail)
        s3_small.move_to_end(key, last=False)
        
        # Promotion (Freq Gating: Requires 2 hits)
        if f >= 2:
            del s3_small[key]
            s3_main[key] = 1
            s3_main.move_to_end(key)
    else:
        # Recovery
        s3_main[key] = 1
        s3_main.move_to_end(key)

def update_after_insert(cache_snapshot, obj):
    '''
    On Insert:
    - Ghost: Restore Freq. Promote directly if Freq high.
    - Else: Insert into Small at Tail (LIFO Danger Zone).
    '''
    _reset_state(cache_snapshot)
    key = obj.key
    
    # Ghost Restoration
    if key in s3_ghost:
        f = s3_ghost[key]
        del s3_ghost[key]
        s3_freq[key] = f
        # Ghost Rescue: if highly frequent, skip probation
        if f >= 2:
            s3_main[key] = 1
            s3_main.move_to_end(key)
            return
    else:
        s3_freq[key] = 0
        
    # Insert into Small at Tail (LIFO position)
    s3_small[key] = 1
    s3_small.move_to_end(key) 

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    On Eviction:
    - Remove from queues.
    - Store frequency in Ghost map.
    '''
    key = evicted_obj.key
    
    if key in s3_small:
        del s3_small[key]
    elif key in s3_main:
        del s3_main[key]
        
    # Store Ghost Freq
    f = s3_freq.get(key, 0)
    s3_ghost[key] = f
    s3_ghost.move_to_end(key) # Mark as recent ghost
    
    # Cleanup Freq Map to save memory (we rely on ghost for history)
    if key in s3_freq:
        del s3_freq[key]

    # Ghost Capacity Management (2x Cache for better history)
    if len(s3_ghost) > 2 * cache_snapshot.capacity:
        s3_ghost.popitem(last=False) # Remove oldest ghost
# EVOLVE-BLOCK-END