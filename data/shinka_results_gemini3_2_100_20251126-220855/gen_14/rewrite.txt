# EVOLVE-BLOCK-START
"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""
from collections import OrderedDict

# S3-FIFO Global State
s3_small = OrderedDict() # S: Small FIFO queue for new insertions
s3_main = OrderedDict()  # M: Main FIFO queue for frequent items
s3_ghost = OrderedDict() # G: Ghost FIFO queue for history
s3_freq = {}             # Frequency counter (small bits)
m_last_access_count = -1

def _check_reset(cache_snapshot):
    """Resets global state if a new trace is detected."""
    global s3_small, s3_main, s3_ghost, s3_freq, m_last_access_count
    if cache_snapshot.access_count < m_last_access_count:
        s3_small.clear()
        s3_main.clear()
        s3_ghost.clear()
        s3_freq.clear()
    m_last_access_count = cache_snapshot.access_count

def evict(cache_snapshot, obj):
    '''
    S3-FIFO Eviction Policy.
    - S (Small) buffers new items. M (Main) holds frequent items.
    - Scans S then M. Items with hits are promoted/reinserted.
    - Victim is chosen from tail of S or M that has no hits.
    '''
    _check_reset(cache_snapshot)
    capacity = cache_snapshot.capacity
    target_s_size = max(1, int(capacity * 0.1))

    # Loop until a victim is found. 
    # Logic: "Lazy promotion" happens during eviction scan.
    while True:
        # 1. Check Small Queue
        # Evict from S if it's larger than target size, or if M is empty (must evict from S)
        if len(s3_small) > target_s_size or len(s3_main) == 0:
            if s3_small:
                candidate_key = next(iter(s3_small))
                freq = s3_freq.get(candidate_key, 0)
                
                if freq > 0:
                    # Hit in S: Move to M (Tail)
                    s3_small.popitem(last=False)
                    s3_main[candidate_key] = 1
                    s3_freq[candidate_key] = 0 # Reset frequency
                else:
                    # No Hit in S: Evict
                    return candidate_key
            else:
                # Should not be reached if len(s3_main) == 0 checks passed
                if not s3_main: return None

        # 2. Check Main Queue
        # If we didn't evict from S (because S is small), check M
        if s3_main:
            candidate_key = next(iter(s3_main))
            freq = s3_freq.get(candidate_key, 0)
            
            if freq > 0:
                # Hit in M: Reinsert to M (Tail)
                s3_main.popitem(last=False)
                s3_main[candidate_key] = 1
                s3_freq[candidate_key] = 0 # Reset frequency
            else:
                # No Hit in M: Evict
                return candidate_key

def update_after_hit(cache_snapshot, obj):
    '''
    On Hit: Increment frequency counter (capped).
    '''
    _check_reset(cache_snapshot)
    key = obj.key
    s3_freq[key] = min(3, s3_freq.get(key, 0) + 1)

def update_after_insert(cache_snapshot, obj):
    '''
    On Insert:
    - If in Ghost (G), insert to Main (M).
    - Else, insert to Small (S).
    '''
    _check_reset(cache_snapshot)
    key = obj.key
    
    if key in s3_ghost:
        # Recall from Ghost
        del s3_ghost[key]
        s3_main[key] = 1
        s3_freq[key] = 0
    else:
        # New Insert
        s3_small[key] = 1
        s3_freq[key] = 0

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    On Evict: Remove from queues and manage Ghost.
    '''
    key = evicted_obj.key
    
    if key in s3_small:
        del s3_small[key]
        # Evicted from S -> Add to G
        s3_ghost[key] = 1
    elif key in s3_main:
        del s3_main[key]
        # Evicted from M -> Discard (Standard S3-FIFO)
    
    if key in s3_freq:
        del s3_freq[key]

    # Limit Ghost size
    if len(s3_ghost) > cache_snapshot.capacity:
        s3_ghost.popitem(last=False)

# EVOLVE-BLOCK-END