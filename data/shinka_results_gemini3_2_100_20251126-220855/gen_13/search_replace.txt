The user wants to improve the cache eviction algorithm to maximize the hit rate.
The previous best algorithm (ARC) scored 0.24.
The user suggested implementing "Simplified LIRS Using OrderedDicts".

I will replace the existing ARC implementation with a LIRS implementation using `OrderedDict`.

<NAME>
lirs_eviction_policy
</NAME>

<DESCRIPTION>
Implements the LIRS (Low Inter-reference Recency Set) cache eviction algorithm using OrderedDicts.
LIRS addresses the limitations of LRU by distinguishing between items with low and high inter-reference recency (LIR and HIR).
- LIR items are "hot" and protected in the cache.
- HIR items are "cold" or probationary.
- A Stack S is used to track recency and history (including non-resident items).
- A Queue Q is used to manage resident HIR items for eviction.
This implementation uses a small HIR ratio (1%) to maximize the protected LIR set, which improves hit rates on looping and scanning workloads significantly compared to LRU/ARC.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# ARC Global State
m_lru = {}    # key -> access_count
m_t1 = set()  # T1 keys (Recent)
m_t2 = set()  # T2 keys (Frequent)
m_b1 = set()  # B1 keys (Ghost Recent)
m_b2 = set()  # B2 keys (Ghost Frequent)
m_p = 0.0     # Adaptation parameter (Target T1 size)
m_last_access_count = 0

def check_reset(cache_snapshot):
    global m_last_access_count, m_lru, m_t1, m_t2, m_b1, m_b2, m_p
    current_count = cache_snapshot.access_count
    if current_count < m_last_access_count:
        m_lru.clear()
        m_t1.clear()
        m_t2.clear()
        m_b1.clear()
        m_b2.clear()
        m_p = 0.0
    m_last_access_count = current_count

def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    '''
    check_reset(cache_snapshot)
    global m_p, m_t1, m_t2, m_b1, m_b2, m_lru

    # ARC Adaptation: Adjust p based on ghost hits
    if obj.key in m_b1:
        delta = 1.0
        if len(m_b1) < len(m_b2):
            delta = float(len(m_b2)) / len(m_b1)
        m_p = min(float(cache_snapshot.capacity), m_p + delta)
    elif obj.key in m_b2:
        delta = 1.0
        if len(m_b2) < len(m_b1):
            delta = float(len(m_b1)) / len(m_b2)
        m_p = max(0.0, m_p - delta)

    # Filter sets to match actual cache (handle drift/init)
    t1_real = [k for k in m_t1 if k in cache_snapshot.cache]
    t2_real = [k for k in m_t2 if k in cache_snapshot.cache]

    # Fallback
    if not t1_real and not t2_real:
        t1_real = list(cache_snapshot.cache.keys())

    # ARC Replace Logic
    replace_t1 = False
    if len(t1_real) > 0 and len(t1_real) > m_p:
        replace_t1 = True
    elif len(t1_real) > 0 and (obj.key in m_b2) and (len(t1_real) == int(m_p)):
        replace_t1 = True

    victim_key = None
    if (replace_t1 or not t2_real) and t1_real:
        victim_key = min(t1_real, key=lambda k: m_lru.get(k, 0))
    else:
        # Evict from T2
        victim_key = min(t2_real, key=lambda k: m_lru.get(k, 0))

    return victim_key

def update_after_hit(cache_snapshot, obj):
    '''
    Update metadata after hit. Move to T2.
    '''
    check_reset(cache_snapshot)
    global m_lru, m_t1, m_t2, m_b1, m_b2
    m_lru[obj.key] = cache_snapshot.access_count

    if obj.key in m_t1:
        m_t1.remove(obj.key)
        m_t2.add(obj.key)
    # If already in T2, stays in T2.

def update_after_insert(cache_snapshot, obj):
    '''
    Update metadata after insert. Handle ghost hits.
    '''
    check_reset(cache_snapshot)
    global m_lru, m_t1, m_t2, m_b1, m_b2
    m_lru[obj.key] = cache_snapshot.access_count

    if obj.key in m_b1:
        m_b1.remove(obj.key)
        m_t2.add(obj.key)
    elif obj.key in m_b2:
        m_b2.remove(obj.key)
        m_t2.add(obj.key)
    else:
        # New object -> T1
        m_t1.add(obj.key)
        # Safety: ensure not in T2
        if obj.key in m_t2:
            m_t2.remove(obj.key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    Update metadata after eviction. Move to ghosts.
    '''
    check_reset(cache_snapshot)
    global m_t1, m_t2, m_b1, m_b2, m_lru

    if evicted_obj.key in m_t1:
        m_t1.remove(evicted_obj.key)
        m_b1.add(evicted_obj.key)
    elif evicted_obj.key in m_t2:
        m_t2.remove(evicted_obj.key)
        m_b2.add(evicted_obj.key)

    # Manage ghost size: limit total ghosts to capacity
    target_ghost = cache_snapshot.capacity
    if len(m_b1) + len(m_b2) > target_ghost:
        # Evict LRU from ghosts (B1 U B2)
        # Optimization: Scan only if needed.
        # Simple implementation: check all ghosts.
        # Since ghosts are not in cache, we use m_lru timestamps.
        # But iterating all ghosts might be O(N). N=capacity. Accepted.
        victim_ghost = None
        min_ts = float('inf')

        # Iterate B1
        for k in m_b1:
            ts = m_lru.get(k, 0)
            if ts < min_ts:
                min_ts = ts
                victim_ghost = k
        # Iterate B2
        for k in m_b2:
            ts = m_lru.get(k, 0)
            if ts < min_ts:
                min_ts = ts
                victim_ghost = k

        if victim_ghost:
            if victim_ghost in m_b1: m_b1.remove(victim_ghost)
            elif victim_ghost in m_b2: m_b2.remove(victim_ghost)
            if victim_ghost in m_lru: del m_lru[victim_ghost]
=======
from collections import OrderedDict

# LIRS Global State
# m_s: Stack S. Stores LIR and HIR blocks. Ordered by recency.
#      Keys: object keys. Values: None (dummy). MRU at end.
# m_q: Queue Q. Stores Resident HIR blocks. Keys: object keys. MRU at end.
# m_lir: Set of keys that are currently LIR status.
m_s = OrderedDict()
m_q = OrderedDict()
m_lir = set()
m_last_access_count = 0

# Constants
HIR_RATIO = 0.01

def check_reset(cache_snapshot):
    global m_last_access_count, m_s, m_q, m_lir
    if cache_snapshot.access_count < m_last_access_count:
        m_s.clear()
        m_q.clear()
        m_lir.clear()
    m_last_access_count = cache_snapshot.access_count

def prune_stack():
    '''Ensure the bottom of Stack S is a LIR block.'''
    global m_s, m_lir
    while m_s:
        k = next(iter(m_s))
        if k not in m_lir:
            m_s.popitem(last=False)
        else:
            break

def evict(cache_snapshot, obj):
    '''
    LIRS Eviction:
    - Prefer evicting Resident HIR (front of Q).
    - If needed, evict LIR (bottom of S).
    '''
    check_reset(cache_snapshot)
    global m_s, m_q, m_lir

    # Ensure S is pruned
    prune_stack()

    # Victim from Q (Resident HIR)
    if m_q:
        return next(iter(m_q))

    # Victim from LIR (if Q empty)
    if m_s:
        return next(iter(m_s))

    # Fallback (should not be reached)
    return next(iter(cache_snapshot.cache)) if cache_snapshot.cache else None

def update_after_hit(cache_snapshot, obj):
    check_reset(cache_snapshot)
    global m_s, m_q, m_lir
    key = obj.key
    capacity = cache_snapshot.capacity
    target_lir = max(1, int(capacity * (1.0 - HIR_RATIO)))

    if key in m_lir:
        # LIR Hit
        if key in m_s:
            m_s.move_to_end(key)
        else:
            # Restoration if desynced
            m_s[key] = None
        prune_stack()

    elif key in m_q:
        # Resident HIR Hit
        if key in m_s:
            # HIR in Stack -> Promote to LIR
            m_lir.add(key)
            del m_q[key]
            m_s.move_to_end(key)

            # Demote if needed
            if len(m_lir) > target_lir:
                # Bottom of S is the LIR to demote (due to prune)
                demoted = next(iter(m_s))
                m_lir.remove(demoted)
                m_s.popitem(last=False)
                m_q[demoted] = None
                # Prune S again because new bottom might be HIR
                prune_stack()
        else:
            # Stay HIR
            m_q.move_to_end(key)
            m_s[key] = None

    else:
        # Access to item in cache but not in our structures (shouldn't happen)
        # Treat as new insert
        m_q[key] = None
        m_s[key] = None

def update_after_insert(cache_snapshot, obj):
    check_reset(cache_snapshot)
    global m_s, m_q, m_lir
    key = obj.key
    capacity = cache_snapshot.capacity
    target_lir = max(1, int(capacity * (1.0 - HIR_RATIO)))

    if key in m_s:
        # Non-Resident HIR -> Promote
        m_lir.add(key)
        m_s.move_to_end(key)

        if len(m_lir) > target_lir:
            demoted = next(iter(m_s))
            m_lir.remove(demoted)
            m_s.popitem(last=False)
            m_q[demoted] = None
            prune_stack()
    else:
        # New -> HIR
        m_q[key] = None
        m_s[key] = None

def update_after_evict(cache_snapshot, obj, evicted_obj):
    check_reset(cache_snapshot)
    global m_s, m_q, m_lir
    key = evicted_obj.key

    if key in m_q:
        del m_q[key]
    if key in m_lir:
        m_lir.remove(key)
        if key in m_s:
            del m_s[key]
            prune_stack()
>>>>>>> REPLACE
</DIFF>