<NAME>
update_ghost_and_persist_freq
</NAME>

<DESCRIPTION>
Modify update_after_evict to extend ghost registry capacity to 3x cache capacity to capture larger working sets (e.g. loops). Also, prevent immediate deletion of frequency counters for evicted items, allowing them to be restored if they return from ghost (Extended Ghost Registry & Persistent Frequency).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    Clean up internal structures after eviction.
    Add evicted items to respective ghost lists.
    '''
    check_reset(cache_snapshot)
    global m_small, m_main, m_ghost, m_ghost_main, m_freq

    key = evicted_obj.key

    if key in m_small:
        del m_small[key]
        m_ghost[key] = None
    elif key in m_main:
        del m_main[key]
        m_ghost_main[key] = None

    # Manage Ghost sizes
    cap = cache_snapshot.capacity
    while len(m_ghost) > cap:
        m_ghost.popitem(last=False)
    while len(m_ghost_main) > cap:
        m_ghost_main.popitem(last=False)

    if key in m_freq:
        del m_freq[key]
=======
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    Clean up internal structures after eviction.
    Add evicted items to respective ghost lists.
    '''
    check_reset(cache_snapshot)
    global m_small, m_main, m_ghost, m_ghost_main, m_freq

    key = evicted_obj.key

    if key in m_small:
        del m_small[key]
        m_ghost[key] = None
    elif key in m_main:
        del m_main[key]
        m_ghost_main[key] = None

    # Manage Ghost sizes (Extended capacity to 3x to catch larger loops)
    cap = cache_snapshot.capacity * 3
    while len(m_ghost) > cap:
        k, _ = m_ghost.popitem(last=False)
        if k in m_freq:
            del m_freq[k]
    while len(m_ghost_main) > cap:
        k, _ = m_ghost_main.popitem(last=False)
        if k in m_freq:
            del m_freq[k]

    # Note: We do NOT delete from m_freq here if it goes to ghost.
    # We want to preserve history for restoration.
    # For safety, if key is not in either ghost (rare/impossible here), remove freq.
    if key not in m_ghost and key not in m_ghost_main:
        if key in m_freq:
            del m_freq[key]
>>>>>>> REPLACE
</DIFF>

<NAME>
restore_decayed_freq
</NAME>

<DESCRIPTION>
Modify update_after_insert to restore the frequency of items returning from ghost state, applying a decay factor (halving) to give them a warm start without locking them in. Also removes the unconditional deletion of frequency on insert.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    '''
    Handle new insertion with adaptive sizing logic.
    '''
    check_reset(cache_snapshot)
    global m_small, m_main, m_ghost, m_ghost_main, m_freq, m_s_ratio

    key = obj.key
    if key in m_freq:
        # Reset freq on new insertion
        del m_freq[key]

    # Adaptation logic: Adjust S target based on ghost hits
    delta = max(0.01, 1.0 / cache_snapshot.capacity) if cache_snapshot.capacity > 0 else 0.01

    if key in m_ghost:
        # Ghost S hit -> S was too small, increase S target
        m_s_ratio = min(0.9, m_s_ratio + delta)
        del m_ghost[key]
        m_main[key] = None
    elif key in m_ghost_main:
        # Ghost M hit -> M was too small (S too big), decrease S target
        m_s_ratio = max(0.01, m_s_ratio - delta)
        del m_ghost_main[key]
        m_main[key] = None
    else:
        # New Item: Insert into S
        m_small[key] = None
=======
def update_after_insert(cache_snapshot, obj):
    '''
    Handle new insertion with adaptive sizing logic.
    '''
    check_reset(cache_snapshot)
    global m_small, m_main, m_ghost, m_ghost_main, m_freq, m_s_ratio

    key = obj.key
    # Adaptation logic: Adjust S target based on ghost hits
    delta = max(0.01, 1.0 / cache_snapshot.capacity) if cache_snapshot.capacity > 0 else 0.01

    if key in m_ghost:
        # Ghost S hit -> S was too small, increase S target
        m_s_ratio = min(0.9, m_s_ratio + delta)
        del m_ghost[key]
        m_main[key] = None
        # Restore frequency with decay
        if key in m_freq:
            m_freq[key] = m_freq[key] // 2
    elif key in m_ghost_main:
        # Ghost M hit -> M was too small (S too big), decrease S target
        m_s_ratio = max(0.01, m_s_ratio - delta)
        del m_ghost_main[key]
        m_main[key] = None
        # Restore frequency with decay
        if key in m_freq:
            m_freq[key] = m_freq[key] // 2
    else:
        # New Item: Insert into S
        m_small[key] = None
        # New item starts with freq 0
        m_freq[key] = 0
>>>>>>> REPLACE
</DIFF>

<NAME>
evict_probabilistic_lifo
</NAME>

<DESCRIPTION>
Modify evict function to include a probabilistic LIFO eviction strategy for the Small queue. This helps in breaking synchronized loops where strict FIFO/LRU policies fail (Trace 14).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    '''
    S3-FIFO eviction policy with Adaptive Sizing, Randomized Window and Frequency Counters.
    '''
    check_reset(cache_snapshot)
    global m_small, m_main, m_freq, m_s_ratio

    import itertools

    capacity = cache_snapshot.capacity
    # Adaptive target size for S
    target_s = max(1, int(capacity * m_s_ratio))

    while True:
        process_s = False
        if len(m_small) > target_s:
            process_s = True
        elif len(m_main) == 0:
            process_s = True

        if process_s:
            if not m_small:
                if m_main:
                    process_s = False
                else:
                    return next(iter(cache_snapshot.cache))

            if process_s:
                # Randomized Window Eviction: Check bottom K items
                k = 5
                window = list(itertools.islice(m_small, k))
                victim = None

                # Find first item with 0 frequency in window
                for key in window:
                    if m_freq.get(key, 0) == 0:
                        victim = key
                        break

                if victim:
                    return victim

                # All K items accessed? Process head.
                key = next(iter(m_small))
                freq = m_freq.get(key, 0)
                if freq > 0:
                    m_freq[key] = freq - 1
                    del m_small[key]
                    m_main[key] = None
                else:
                    return key
=======
def evict(cache_snapshot, obj):
    '''
    S3-FIFO eviction policy with Adaptive Sizing, Randomized Window and Frequency Counters.
    Includes Probabilistic LIFO to break loops.
    '''
    check_reset(cache_snapshot)
    global m_small, m_main, m_freq, m_s_ratio

    import itertools
    import random

    capacity = cache_snapshot.capacity
    # Adaptive target size for S
    target_s = max(1, int(capacity * m_s_ratio))

    while True:
        process_s = False
        if len(m_small) > target_s:
            process_s = True
        elif len(m_main) == 0:
            process_s = True

        if process_s:
            if not m_small:
                if m_main:
                    process_s = False
                else:
                    return next(iter(cache_snapshot.cache))

            if process_s:
                # Probabilistic LIFO (Anti-Thrashing)
                # Small chance to evict the newest item from Small to desynchronize loops
                if random.random() < 0.01:
                    return next(reversed(m_small))

                # Randomized Window Eviction: Check bottom K items
                k = 5
                window = list(itertools.islice(m_small, k))
                victim = None

                # Find first item with 0 frequency in window
                for key in window:
                    if m_freq.get(key, 0) == 0:
                        victim = key
                        break

                if victim:
                    return victim

                # All K items accessed? Process head.
                key = next(iter(m_small))
                freq = m_freq.get(key, 0)
                if freq > 0:
                    m_freq[key] = freq - 1
                    del m_small[key]
                    m_main[key] = None
                else:
                    return key
>>>>>>> REPLACE
</DIFF>