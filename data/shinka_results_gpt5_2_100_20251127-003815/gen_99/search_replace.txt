<NAME>
dualsample_recency_tinylfu_plus_hot_bypass
</NAME>

<DESCRIPTION>
I introduce a dual-segment, recency-aware TinyLFU sampling strategy with lightweight timestamps and a small direct-to-protected “hot bypass” admission budget. Specifically:
- Add last_touch timestamps and a small recent-membership ring to boost phase-shifting items without overfitting.
- Replace single-segment candidate sampling with dual-segment tail sampling (M1 and M2) using a lexicographic comparator of (TinyLFU estimate ascending, older last_touch ascending), with a +1 bias to M2 candidates. This better preserves truly hot protected items while still allowing colder probationary items to be replaced.
- Enhance choose_victim to compare the new object's boosted frequency against the best candidate across M1 and M2; otherwise evict from the window. This implements competitive admission that reduces main pollution.
- Add a bounded hot bypass budget to allow rare direct M2 admissions when the new item is significantly hotter than M2’s tail. Reset this budget periodically and disable during scan cooldowns.
- Make tuning adaptive: adjust TinyLFU aging period and sampling width based on protected hit share (M2 hit ratio), and decay counters over time.
- Maintain recency metadata on hits/inserts, clean it on evictions/self-heal, and demote protected items using the new tail sampler.

These changes collectively improve stability during scans (via bias/cooldown), speed phase transitions, and sharpen victim selection—reducing miss rates across heterogeneous workloads.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "miss_streak", "scan_cooldown"
    )
=======
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "miss_streak", "scan_cooldown",
        # Recency and recent-membership tracking
        "last_touch", "recent_ring", "recent_set", "recent_idx", "recent_cap",
        # Hot bypass admission budget
        "hot_bypass_budget", "last_budget_reset", "budget_period",
        # Protected hits for adaptive tuning
        "hits_m2"
    )
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.last_tune_time = 0
        self.tune_period = 0
        # Scan detection
        self.miss_streak = 0
        self.scan_cooldown = 0
=======
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.last_tune_time = 0
        self.tune_period = 0
        # Scan detection
        self.miss_streak = 0
        self.scan_cooldown = 0
        # Recency and recent-membership tracking
        self.last_touch = {}
        self.recent_ring = []
        self.recent_set = set()
        self.recent_idx = 0
        self.recent_cap = 0
        # Hot bypass admission budget
        self.hot_bypass_budget = 0
        self.last_budget_reset = 0
        self.budget_period = 0
        # Protected hits for adaptive tuning
        self.hits_m2 = 0
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _ensure_capacity(self, cap: int):
        if self.capacity is None:
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            # Age faster for smaller caches
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
            # Set adaptive tuning period relative to capacity
            self.tune_period = max(256, self.capacity * 4)
            self.last_tune_time = 0
            return
        if self.capacity != cap:
            # Reset segments if external capacity changes to avoid desync.
            self.W.clear(); self.M1.clear(); self.M2.clear()
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
            self.tune_period = max(256, self.capacity * 4)
            self.last_tune_time = 0
=======
    def _ensure_capacity(self, cap: int):
        if self.capacity is None:
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            # Age faster for smaller caches
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
            # Set adaptive tuning period relative to capacity
            self.tune_period = max(256, self.capacity * 4)
            self.last_tune_time = 0
            # Recency ring and budget initialization
            self.recent_cap = max(32, min(4096, self.capacity))
            self.recent_ring = [None] * self.recent_cap
            self.recent_set.clear()
            self.recent_idx = 0
            self.budget_period = self.tune_period
            self.hot_bypass_budget = min(8, max(1, int(self.capacity * 0.02)))
            self.last_budget_reset = 0
            return
        if self.capacity != cap:
            # Reset segments if external capacity changes to avoid desync.
            self.W.clear(); self.M1.clear(); self.M2.clear()
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
            self.tune_period = max(256, self.capacity * 4)
            self.last_tune_time = 0
            # Reset recency ring and budget with new capacity
            self.recent_cap = max(32, min(4096, self.capacity))
            self.recent_ring = [None] * self.recent_cap
            self.recent_set.clear()
            self.recent_idx = 0
            self.budget_period = self.tune_period
            self.hot_bypass_budget = min(8, max(1, int(self.capacity * 0.02)))
            self.last_budget_reset = 0
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _self_heal(self, cache_snapshot):
        # Ensure all cached keys are tracked and no phantom entries remain.
        cache_keys = set(cache_snapshot.cache.keys())
        for od in (self.W, self.M1, self.M2):
            for k in list(od.keys()):
                if k not in cache_keys:
                    od.pop(k, None)
        tracked = set(self.W.keys()) | set(self.M1.keys()) | set(self.M2.keys())
        missing = cache_keys - tracked
        if missing:
            w_tgt, _, _ = self._targets()
            # Place missing into W until target, then into M1
            for k in missing:
                if len(self.W) < w_tgt:
                    self.W[k] = None
                else:
                    self.M1[k] = None
=======
    def _self_heal(self, cache_snapshot):
        # Ensure all cached keys are tracked and no phantom entries remain.
        cache_keys = set(cache_snapshot.cache.keys())
        for od in (self.W, self.M1, self.M2):
            for k in list(od.keys()):
                if k not in cache_keys:
                    od.pop(k, None)
        tracked = set(self.W.keys()) | set(self.M1.keys()) | set(self.M2.keys())
        missing = cache_keys - tracked
        if missing:
            w_tgt, _, _ = self._targets()
            # Place missing into W until target, then into M1
            for k in missing:
                if len(self.W) < w_tgt:
                    self.W[k] = None
                else:
                    self.M1[k] = None
        # Clean up recency metadata for keys not in cache
        for k in list(self.last_touch.keys()):
            if k not in cache_keys:
                self.last_touch.pop(k, None)
        if self.recent_set:
            for k in list(self.recent_set):
                if k not in cache_keys:
                    # Remove from recent_set; ring will overwrite lazily
                    self.recent_set.discard(k)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _maybe_tune(self, now: int):
        # Periodically adapt window size based on relative hits.
        if self.tune_period <= 0:
            return
        if (now - self.last_tune_time) >= self.tune_period:
            # If window is relatively more useful, grow it; otherwise shrink.
            if self.hits_w > self.hits_main * 1.1:
                self.win_frac = min(0.5, self.win_frac + 0.05)
            elif self.hits_main > self.hits_w * 1.1:
                self.win_frac = max(0.05, self.win_frac - 0.05)
            # Decay counters and update tune timestamp
            self.hits_w >>= 1
            self.hits_main >>= 1
            self.last_tune_time = now
=======
    def _maybe_tune(self, now: int):
        # Periodically adapt window size and TinyLFU params.
        if self.tune_period <= 0:
            return
        if (now - self.last_tune_time) >= self.tune_period:
            # Window fraction tuning
            if self.hits_w > self.hits_main * 1.1:
                self.win_frac = min(0.5, self.win_frac + 0.05)
            elif self.hits_main > self.hits_w * 1.1:
                self.win_frac = max(0.05, self.win_frac - 0.05)
            # Adapt sketch aging and sampling k based on M2 dominance
            total_main = max(1, self.hits_main)
            m2_ratio = self.hits_m2 / total_main
            if m2_ratio > 0.7:
                target_age = min(16384, (self.capacity or 1) * 16)
                target_k = 12 if (self.capacity or 0) >= 64 else 10
            elif m2_ratio > 0.4:
                target_age = max(512, (self.capacity or 1) * 8)
                target_k = 8
            else:
                target_age = max(512, (self.capacity or 1) * 4)
                target_k = 6 if m2_ratio > 0.2 else 4
            # Smoothly move toward target parameters
            try:
                self.sketch.age_period = int((self.sketch.age_period * 3 + target_age) // 4)
            except Exception:
                pass
            if self._sample_k < target_k:
                self._sample_k = min(target_k, self._sample_k + 1)
            elif self._sample_k > target_k:
                self._sample_k = max(target_k, self._sample_k - 1)
            # Decay counters and update tune timestamp
            self.hits_w >>= 1
            self.hits_main >>= 1
            self.hits_m2 >>= 1
            self.last_tune_time = now
            # Refresh hot-bypass budget periodically
            self._maybe_reset_budget(now)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _lru(self, od: OrderedDict):
        return next(iter(od)) if od else None

    def _touch(self, od: OrderedDict, key: str):
        od[key] = None
        od.move_to_end(key)

    def _sample_lru_min_freq(self, od: OrderedDict) -> str:
        if not od:
            return None
        k = min(self._sample_k, len(od))
        it = iter(od.keys())  # from LRU to MRU
        min_key, min_f = None, None
        for _ in range(k):
            key = next(it)
            f = self.sketch.estimate(key)
            if min_f is None or f < min_f:
                min_f, min_key = f, key
        return min_key if min_key is not None else self._lru(od)
=======
    def _lru(self, od: OrderedDict):
        return next(iter(od)) if od else None

    def _touch(self, od: OrderedDict, key: str):
        od[key] = None
        od.move_to_end(key)

    def _get_last_touch(self, key: str) -> int:
        return self.last_touch.get(key, 0)

    def _recent_add(self, key: str):
        # Maintain a small recent-membership structure to accelerate phase shifts.
        if self.recent_cap <= 0:
            return
        if key in self.recent_set:
            return
        if self.recent_ring[self.recent_idx] is not None:
            old = self.recent_ring[self.recent_idx]
            if old in self.recent_set:
                self.recent_set.discard(old)
        self.recent_ring[self.recent_idx] = key
        self.recent_set.add(key)
        self.recent_idx = (self.recent_idx + 1) % self.recent_cap

    def _recent_remove(self, key: str):
        # Opportunistic removal from recent set (ring will overwrite stale entries).
        if key in self.recent_set:
            self.recent_set.discard(key)

    def _sample_tail_min(self, od: OrderedDict) -> str:
        """
        Sample the LRU tail (size ~ 4k) and choose the candidate with minimal
        (frequency, last_touch) lexicographically.
        """
        if not od:
            return None
        tail_len = min(len(od), max(1, self._sample_k * 4))
        it = iter(od.keys())  # from LRU to MRU
        min_key, min_f, min_t = None, None, None
        for _ in range(tail_len):
            key = next(it)
            f = self.sketch.estimate(key)
            t = self._get_last_touch(key)
            if (min_key is None) or (f < min_f) or (f == min_f and t < min_t):
                min_key, min_f, min_t = key, f, t
        return min_key if min_key is not None else self._lru(od)

    def _sample_lru_min_freq(self, od: OrderedDict) -> str:
        # Backward-compatible wrapper
        return self._sample_tail_min(od)

    def _maybe_reset_budget(self, now: int):
        if self.budget_period <= 0:
            return
        if (now - self.last_budget_reset) >= self.budget_period:
            self.hot_bypass_budget = min(8, max(1, int((self.capacity or 1) * 0.02)))
            self.last_budget_reset = now
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        W-TinyLFU eviction with scan-aware bias:
        - Compare f(new) to a sampled low-frequency candidate from M1.
          * If f(new) > f(cand_M1) + bias: evict cand_M1 (admit new to W).
          * Else: evict W's LRU (reject new from main this round).
        - If M1 is empty, fall back to comparing against M2 (with same bias), else use window LRU.
        - bias = 1 normally; bias = 3 during scan cooldown to protect main.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        # Decay scan cooldown on each miss-driven eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        # Candidates
        cand_w = self._lru(self.W)
        cand_m1 = self._sample_lru_min_freq(self.M1)
        cand_m2 = self._sample_lru_min_freq(self.M2) if cand_m1 is None else None

        f_new = self.sketch.estimate(new_obj.key)
        f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
        f_m2 = self.sketch.estimate(cand_m2) if cand_m2 is not None else -1
        bias = 3 if self.scan_cooldown > 0 else 1

        # Prefer replacing a cold M1 entry if new is sufficiently hotter
        if cand_m1 is not None and f_new > (f_m1 + bias):
            return cand_m1

        # Otherwise evict from the window to preserve main
        if cand_w is not None:
            return cand_w

        # If no window, consider replacing a cold protected entry if new is sufficiently hotter
        if cand_m2 is not None and f_new > (f_m2 + bias):
            return cand_m2

        # Fallbacks
        if self.M1:
            return self._lru(self.M1)
        if self.M2:
            return self._lru(self.M2)

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Dual-segment TinyLFU competitive admission with recency-aware sampling:
        - Sample tails of M1 and M2; choose weakest by (freq + seg_bias, last_touch).
        - If f(new) + recent_boost > f(cand) + bias: evict that candidate (prefer M1).
        - Else evict W's LRU to preserve main from pollution.
        - bias = 1 normally; bias = 3 during scan cooldown to protect main.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        # Decay scan cooldown on each miss-driven eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        # Candidates from segments
        cand_w = self._lru(self.W)
        cand_m1 = self._sample_tail_min(self.M1)
        cand_m2 = self._sample_tail_min(self.M2)

        # Frequency estimates
        f_new = self.sketch.estimate(new_obj.key)
        # Small recent-membership boost to accelerate phase shifts
        if new_obj.key in self.recent_set:
            f_new += 1

        # Prepare candidate comparison
        def cand_tuple(key, seg_bias=0):
            if key is None:
                return (None, (1 << 30), (1 << 30))  # effectively infinite
            return (key, self.sketch.estimate(key) + seg_bias, self._get_last_touch(key))

        k1, f1, t1 = cand_tuple(cand_m1, 0)
        # Make M2 harder to replace with +1 bias
        extra = 2 if self.scan_cooldown > 0 else 1
        k2, f2, t2 = cand_tuple(cand_m2, extra)

        # Choose weakest between M1 and M2
        choose_m2 = False
        if f2 < f1 or (f2 == f1 and t2 < t1):
            victim_key, victim_freq = k2, f2
            choose_m2 = True
        else:
            victim_key, victim_freq = k1, f1

        bias = 3 if self.scan_cooldown > 0 else 1

        if victim_key is not None and f_new > (victim_freq + bias):
            return victim_key

        # Otherwise evict from the window to preserve main
        if cand_w is not None:
            return cand_w

        # If no window entries, fall back to the chosen main candidate
        if victim_key is not None:
            return victim_key

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU.
        - W hit: refresh or conservatively promote if sufficiently hot.
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Any hit resets the ongoing miss streak and cools down scan bias
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strongly frequent to avoid window churn
            est = self.sketch.estimate(key)
            thr = 4 if self.scan_cooldown > 0 else 3
            if est >= thr:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                # Keep protected region within target using frequency-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote = self._sample_lru_min_freq(self.M2)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            # Rebalance protected size if needed (freq-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote = self._sample_lru_min_freq(self.M2)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
        self._maybe_tune(now)
=======
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU.
        - Maintain last_touch and recent-membership.
        - W hit: refresh or conservatively promote if sufficiently hot.
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update recency metadata
        self.last_touch[key] = now
        self._recent_add(key)

        # Any hit resets the ongoing miss streak and cools down scan bias
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strongly frequent to avoid window churn
            est = self.sketch.estimate(key)
            thr = 4 if self.scan_cooldown > 0 else 3
            if est >= thr and self.scan_cooldown == 0:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                # Keep protected region within target using frequency-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote = self._sample_tail_min(self.M2)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            # Rebalance protected size if needed (freq-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote = self._sample_tail_min(self.M2)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self.hits_m2 += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote = self._sample_tail_min(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
        self._maybe_tune(now)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - If W exceeds target, consider TinyLFU-gated move of W's LRU to M1.
        - Keep protected region within target by demoting its LRU to M1 if needed.
        - Maintain scan detector state.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update scan detector: count consecutive misses
        self.miss_streak += 1
        if self.miss_streak > (self.capacity or 1):
            # Enter/extend scan-biased cooldown
            self.scan_cooldown = max(self.scan_cooldown, self.capacity or 1)
        else:
            # Gradually cool down if not clearly scanning
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, TinyLFU-gated move of W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                cand_m1 = self._sample_lru_min_freq(self.M1)
                f_w = self.sketch.estimate(w_lru)
                f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
                bias = 3 if self.scan_cooldown > 0 else 1
                if f_w >= (f_m1 + bias):
                    # Admit into probationary
                    self.W.pop(w_lru, None)
                    self._touch(self.M1, w_lru)
                else:
                    # Keep in window; refresh to MRU to avoid immediate churn
                    self._touch(self.W, w_lru)

        # Keep protected region within target (freq-aware demotion)
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)

        # Periodically tune window size
        self._maybe_tune(now)
=======
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - Optional hot bypass: direct admission to M2 when new is much hotter than M2 tail.
        - If W exceeds target, TinyLFU-gated move of W's LRU to M1.
        - Keep protected region within target by demoting its LRU to M1 if needed.
        - Maintain scan detector state.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update recency metadata and recent-membership
        self.last_touch[key] = now
        self._recent_add(key)

        # Update scan detector: count consecutive misses
        self.miss_streak += 1
        if self.miss_streak > (self.capacity or 1):
            # Enter/extend scan-biased cooldown
            self.scan_cooldown = max(self.scan_cooldown, self.capacity or 1)
        else:
            # Gradually cool down if not clearly scanning
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Optional hot-bypass to protected, budget-limited and disabled during cooldown
        self._maybe_reset_budget(now)
        if self.scan_cooldown == 0 and self.hot_bypass_budget > 0:
            f_new = self.sketch.estimate(key)
            cand_m2 = self._sample_tail_min(self.M2)
            f_m2 = self.sketch.estimate(cand_m2) if cand_m2 is not None else -1
            if f_new >= (f_m2 + 2):
                # Directly protect this very hot item
                self.W.pop(key, None)
                self._touch(self.M2, key)
                self.hot_bypass_budget -= 1
                # Keep protected region within target (freq-aware demotion)
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote = self._sample_tail_min(self.M2)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)

        # Rebalance: if W is beyond target, TinyLFU-gated move of W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                cand_m1 = self._sample_tail_min(self.M1)
                f_w = self.sketch.estimate(w_lru)
                f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
                bias = 3 if self.scan_cooldown > 0 else 1
                # Lexicographic tie-breaker by recency for equal frequency
                if (f_w > (f_m1 + bias)) or (f_w == (f_m1 + bias) and self._get_last_touch(w_lru) < self._get_last_touch(cand_m1) if cand_m1 is not None else True):
                    # Admit into probationary
                    self.W.pop(w_lru, None)
                    self._touch(self.M1, w_lru)
                else:
                    # Keep in window; refresh to MRU to avoid immediate churn
                    self._touch(self.W, w_lru)

        # Keep protected region within target (freq-aware demotion)
        if len(self.M2) > prot_tgt:
            demote = self._sample_tail_min(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)

        # Periodically tune window size and parameters
        self._maybe_tune(now)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_evict(self, cache_snapshot, obj, evicted_obj):
        """
        Eviction post-processing:
        - Remove evicted key from whichever segment it resides in.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        k = evicted_obj.key
        self.W.pop(k, None)
        self.M1.pop(k, None)
        self.M2.pop(k, None)
=======
    def on_evict(self, cache_snapshot, obj, evicted_obj):
        """
        Eviction post-processing:
        - Remove evicted key from whichever segment it resides in.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        k = evicted_obj.key
        self.W.pop(k, None)
        self.M1.pop(k, None)
        self.M2.pop(k, None)
        # Clean recency metadata
        self.last_touch.pop(k, None)
        self._recent_remove(k)
>>>>>>> REPLACE
</DIFF>