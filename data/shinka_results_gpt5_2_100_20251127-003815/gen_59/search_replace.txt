<NAME>
arc_tinylfu_scan_guard_random_tail
</NAME>

<DESCRIPTION>
I introduce a scan-aware cooldown that throttles promotions and prefers evicting from the probationary set during scan-like phases, thereby preserving the protected (frequent) set from pollution. I also randomize the LRU-tail sampling region when picking victims to avoid deterministic bias, and I strengthen the TinyLFU guard when evicting from the protected set during scans. Concretely:

- Add scan_cooldown: triggered by long miss streaks, decays faster on hits. While active, promotion from T1 to T2 requires hotness (TinyLFU or decayed score), and early promotion thresholds are raised. Eviction prefers T1 under cooldown, and T2-vs-new comparison uses a higher bias.
- Randomized tail sampling: when sampling eviction candidates, I choose a random offset within the oldest min(4k, len) keys and evaluate only k keys. This reduces bias and better detects stale items.
- Minor tweaks: decay cooldown on events; retain LRFU updates.

These changes improve robustness under scans and phase shifts and should reduce miss rates by avoiding protected-set pollution while still allowing genuinely hot items to be promoted rapidly.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from collections import OrderedDict
=======
from collections import OrderedDict
import random
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    __slots__ = (
        # ARC segments
        "T1", "T2", "B1", "B2", "p",
        # TinyLFU sketch
        "SKETCH_DEPTH", "sketch_w", "sketch", "sketch_ops", "age_threshold",
        # LRFU metadata
        "score", "last_time", "decay_half_life", "decay_base",
        # run/misc
        "last_access_seen", "miss_streak",
        # victim bookkeeping
        "last_victim_key", "last_victim_from",
        # sampling
        "_sample_k",
    )
=======
    __slots__ = (
        # ARC segments
        "T1", "T2", "B1", "B2", "p",
        # TinyLFU sketch
        "SKETCH_DEPTH", "sketch_w", "sketch", "sketch_ops", "age_threshold",
        # LRFU metadata
        "score", "last_time", "decay_half_life", "decay_base",
        # run/misc
        "last_access_seen", "miss_streak", "scan_cooldown",
        # victim bookkeeping
        "last_victim_key", "last_victim_from",
        # sampling
        "_sample_k",
    )
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Misc
        self.last_access_seen = -1
        self.miss_streak = 0
=======
        # Misc
        self.last_access_seen = -1
        self.miss_streak = 0
        self.scan_cooldown = 0
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            self.miss_streak = 0
            self.last_victim_key = None
            self.last_victim_from = None
            self._sample_k = 8
=======
            self.miss_streak = 0
            self.last_victim_key = None
            self.last_victim_from = None
            self._sample_k = 8
            self.scan_cooldown = 0
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _eviction_sample(self, cache_snapshot, seg):
        """
        Sample up to K LRU keys from seg; choose with lexicographic min:
        (TinyLFU estimate, LRFU decayed score). Lower is colder.
        """
        if not seg:
            return None
        now = cache_snapshot.access_count
        sample_k = min(self._sample_k, len(seg))
        it = iter(seg.keys())  # LRU -> MRU
        best_k, best_f, best_d = None, None, None
        for _ in range(sample_k):
            k = next(it)
            f = self._sketch_est(cache_snapshot, k)
            d = self._decayed_score(k, now)
            if (best_k is None
                or f < best_f
                or (f == best_f and d < best_d)):
                best_k, best_f, best_d = k, f, d
                if best_f == 0 and best_d == 0.0:
                    # Can't do better
                    break
        return best_k
=======
    def _eviction_sample(self, cache_snapshot, seg):
        """
        Sample up to K keys from a randomized window within the LRU tail
        (oldest min(4K, |seg|) keys). Choose lexicographic min:
        (TinyLFU estimate, LRFU decayed score). Lower is colder.
        """
        if not seg:
            return None
        now = cache_snapshot.access_count
        n = len(seg)
        k = max(1, min(self._sample_k, n))
        tail_len = min(n, k * 4)
        # Collect the LRU-tail keys up to tail_len
        tail_keys = []
        it = iter(seg.keys())  # LRU -> MRU
        for _ in range(tail_len):
            try:
                tail_keys.append(next(it))
            except StopIteration:
                break
        if not tail_keys:
            # Fallback: pick the LRU
            for kk in seg.keys():
                return kk
            return None
        # Randomized offset into the tail to avoid deterministic bias
        max_start = max(0, len(tail_keys) - k)
        start = random.randint(0, max_start) if max_start > 0 else 0
        sample_keys = tail_keys[start:start + k]

        best_k = None
        best_f = None
        best_d = None
        for kk in sample_keys:
            f = self._sketch_est(cache_snapshot, kk)
            d = self._decayed_score(kk, now)
            if (best_k is None
                or f < best_f
                or (f == best_f and d < best_d)):
                best_k, best_f, best_d = kk, f, d
                if best_f == 0 and best_d == 0.0:
                    break
        return best_k
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def evict(self, cache_snapshot, obj):
        self._reset_if_new_run(cache_snapshot)
        self._prune_metadata(cache_snapshot)
        self._ensure_sketch(cache_snapshot)
        self._seed_from_cache(cache_snapshot)

        seg_name = self._replace_segment(cache_snapshot, obj.key)
        victim = None

        if seg_name == "T1" and self.T1:
            victim = self._eviction_sample(cache_snapshot, self.T1)
        elif seg_name == "T2" and self.T2:
            cand_t2 = self._eviction_sample(cache_snapshot, self.T2)
            if cand_t2 is not None:
                # TinyLFU guard: protect much hotter T2 vs incoming
                f_new = self._sketch_est(cache_snapshot, obj.key)
                f_t2 = self._sketch_est(cache_snapshot, cand_t2)
                if f_t2 > f_new + 1 and len(self.T1) > 0:
                    alt = self._eviction_sample(cache_snapshot, self.T1)
                    if alt is not None:
                        victim = alt
                        seg_name = "T1"
                    else:
                        victim = cand_t2
                else:
                    victim = cand_t2

        if victim is None:
            # Fallback to any cached key
            for k in cache_snapshot.cache.keys():
                victim = k
                seg_name = "T1" if k in self.T1 else ("T2" if k in self.T2 else None)
                break

        self.last_victim_key = victim
        self.last_victim_from = seg_name
        return victim
=======
    def evict(self, cache_snapshot, obj):
        self._reset_if_new_run(cache_snapshot)
        self._prune_metadata(cache_snapshot)
        self._ensure_sketch(cache_snapshot)
        self._seed_from_cache(cache_snapshot)

        seg_name = self._replace_segment(cache_snapshot, obj.key)
        # Scan-aware: prefer evicting from probation during cooldown
        if self.scan_cooldown > 0 and self.T1:
            seg_name = "T1"
        victim = None

        if seg_name == "T1" and self.T1:
            victim = self._eviction_sample(cache_snapshot, self.T1)
        elif seg_name == "T2" and self.T2:
            cand_t2 = self._eviction_sample(cache_snapshot, self.T2)
            if cand_t2 is not None:
                # TinyLFU guard: protect much hotter T2 vs incoming
                f_new = self._sketch_est(cache_snapshot, obj.key)
                f_t2 = self._sketch_est(cache_snapshot, cand_t2)
                bias = 2 if self.scan_cooldown > 0 else 1
                if f_t2 > f_new + bias and len(self.T1) > 0:
                    alt = self._eviction_sample(cache_snapshot, self.T1)
                    if alt is not None:
                        victim = alt
                        seg_name = "T1"
                    else:
                        victim = cand_t2
                else:
                    victim = cand_t2

        if victim is None:
            # Fallback to any cached key
            for k in cache_snapshot.cache.keys():
                victim = k
                seg_name = "T1" if k in self.T1 else ("T2" if k in self.T2 else None)
                break

        self.last_victim_key = victim
        self.last_victim_from = seg_name
        return victim
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def update_after_hit(self, cache_snapshot, obj):
        self._reset_if_new_run(cache_snapshot)
        self._prune_metadata(cache_snapshot)
        self._ensure_sketch(cache_snapshot)

        now = cache_snapshot.access_count
        key = obj.key
        # Reset scan indicator and learn
        self.miss_streak = 0
        self._sketch_add(cache_snapshot, key, 1)
        # Bump decayed score
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        if key in self.T2:
            self._move_to_mru(self.T2, key)
        elif key in self.T1:
            # Promote T1 -> T2 on hit
            self.T1.pop(key, None)
            self._move_to_mru(self.T2, key)
        else:
            # Metadata miss but hit in cache: conservatively place in T1
            self._move_to_mru(self.T1, key)
=======
    def update_after_hit(self, cache_snapshot, obj):
        self._reset_if_new_run(cache_snapshot)
        self._prune_metadata(cache_snapshot)
        self._ensure_sketch(cache_snapshot)

        now = cache_snapshot.access_count
        key = obj.key
        # Reset scan indicator and learn
        self.miss_streak = 0
        # Cooldown decays faster on hits
        if self.scan_cooldown > 0:
            self.scan_cooldown = max(0, self.scan_cooldown - 2)
        self._sketch_add(cache_snapshot, key, 1)
        # Bump decayed score
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        if key in self.T2:
            self._move_to_mru(self.T2, key)
        elif key in self.T1:
            # Promote T1 -> T2 on hit unless in scan cooldown and not hot
            if self.scan_cooldown > 0:
                if self._sketch_est(cache_snapshot, key) >= 2 or self._decayed_score(key, now) >= 1.0:
                    self.T1.pop(key, None)
                    self._move_to_mru(self.T2, key)
                else:
                    self._move_to_mru(self.T1, key)
            else:
                self.T1.pop(key, None)
                self._move_to_mru(self.T2, key)
        else:
            # Metadata miss but hit in cache: conservatively place in T1
            self._move_to_mru(self.T1, key)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def update_after_insert(self, cache_snapshot, obj):
        self._reset_if_new_run(cache_snapshot)
        self._prune_metadata(cache_snapshot)
        self._ensure_sketch(cache_snapshot)

        now = cache_snapshot.access_count
        key = obj.key
        self.miss_streak += 1
        # Learn on admission and initialize decayed metadata
        self._sketch_add(cache_snapshot, key, 1)
        self.last_time[key] = now
        # Start with small score to reduce scan pollution
        self.score[key] = 0.5

        cap = self._cap(cache_snapshot)
        # ARC adaptive p tuning based on ghost refaults
        if key in self.B1:
            delta = max(1, len(self.B2) // max(1, len(self.B1)))
            self.p = min(float(cap), self.p + float(delta))
            self.B1.pop(key, None)
            self._move_to_mru(self.T2, key)
        elif key in self.B2:
            delta = max(1, len(self.B1) // max(1, len(self.B2)))
            self.p = max(0.0, self.p - float(delta))
            self.B2.pop(key, None)
            self._move_to_mru(self.T2, key)
        else:
            # Fresh miss: early promotion if clearly hot
            if self._sketch_est(cache_snapshot, key) >= 4:
                self._move_to_mru(self.T2, key)
            else:
                self._move_to_mru(self.T1, key)

        # Bound ghosts
        self._trim_ghosts(cache_snapshot)
=======
    def update_after_insert(self, cache_snapshot, obj):
        self._reset_if_new_run(cache_snapshot)
        self._prune_metadata(cache_snapshot)
        self._ensure_sketch(cache_snapshot)

        now = cache_snapshot.access_count
        key = obj.key
        self.miss_streak += 1
        # Slow cooldown decay on continued misses
        if self.scan_cooldown > 0:
            self.scan_cooldown = max(0, self.scan_cooldown - 1)
        # Trigger scan cooldown if too many consecutive misses
        cap = self._cap(cache_snapshot)
        if self.miss_streak >= max(32, cap // 2):
            self.scan_cooldown = max(self.scan_cooldown, min(cap, self.miss_streak))

        # Learn on admission and initialize decayed metadata
        self._sketch_add(cache_snapshot, key, 1)
        self.last_time[key] = now
        # Start with small score to reduce scan pollution
        self.score[key] = 0.5

        # ARC adaptive p tuning based on ghost refaults
        if key in self.B1:
            delta = max(1, len(self.B2) // max(1, len(self.B1)))
            self.p = min(float(cap), self.p + float(delta))
            self.B1.pop(key, None)
            # Under scan cooldown, only place into T2 if modestly hot
            if self.scan_cooldown > 0 and self._sketch_est(cache_snapshot, key) < 2:
                self._move_to_mru(self.T1, key)
            else:
                self._move_to_mru(self.T2, key)
        elif key in self.B2:
            delta = max(1, len(self.B1) // max(1, len(self.B2)))
            self.p = max(0.0, self.p - float(delta))
            self.B2.pop(key, None)
            if self.scan_cooldown > 0 and self._sketch_est(cache_snapshot, key) < 2:
                self._move_to_mru(self.T1, key)
            else:
                self._move_to_mru(self.T2, key)
        else:
            # Fresh miss: early promotion if clearly hot
            thr = 6 if self.scan_cooldown > 0 else 4
            if self._sketch_est(cache_snapshot, key) >= thr:
                self._move_to_mru(self.T2, key)
            else:
                self._move_to_mru(self.T1, key)

        # Bound ghosts
        self._trim_ghosts(cache_snapshot)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def update_after_evict(self, cache_snapshot, obj, evicted_obj):
        self._reset_if_new_run(cache_snapshot)
        evk = evicted_obj.key

        # Remove from resident sets, track origin
        removed_from = None
        if evk in self.T1:
            self.T1.pop(evk, None)
            removed_from = "T1"
        elif evk in self.T2:
            self.T2.pop(evk, None)
            removed_from = "T2"
        else:
            removed_from = self.last_victim_from

        # Place into ghost according to origin
        if removed_from == "T1":
            self.B1[evk] = None
        elif removed_from == "T2":
            self.B2[evk] = None

        # Clean up LRFU metadata
        self.score.pop(evk, None)
        self.last_time.pop(evk, None)

        self._trim_ghosts(cache_snapshot)
        if self.last_victim_key == evk:
            self.last_victim_key = None
            self.last_victim_from = None
=======
    def update_after_evict(self, cache_snapshot, obj, evicted_obj):
        self._reset_if_new_run(cache_snapshot)
        evk = evicted_obj.key

        # Remove from resident sets, track origin
        removed_from = None
        if evk in self.T1:
            self.T1.pop(evk, None)
            removed_from = "T1"
        elif evk in self.T2:
            self.T2.pop(evk, None)
            removed_from = "T2"
        else:
            removed_from = self.last_victim_from

        # Place into ghost according to origin
        if removed_from == "T1":
            self.B1[evk] = None
        elif removed_from == "T2":
            self.B2[evk] = None

        # Clean up LRFU metadata
        self.score.pop(evk, None)
        self.last_time.pop(evk, None)

        self._trim_ghosts(cache_snapshot)
        if self.last_victim_key == evk:
            self.last_victim_key = None
            self.last_victim_from = None
        # Mild cooldown decay on eviction progression
        if self.scan_cooldown > 0:
            self.scan_cooldown = max(0, self.scan_cooldown - 1)
>>>>>>> REPLACE

</DIFF>