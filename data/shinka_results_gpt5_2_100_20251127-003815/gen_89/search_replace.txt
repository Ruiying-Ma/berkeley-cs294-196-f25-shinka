<NAME>
tiny_door_and_dual_main_sampling
</NAME>

<DESCRIPTION>
I introduce two targeted enhancements to reduce miss rate:
1) A lightweight doorkeeper (OrderedDict) to suppress TinyLFU pollution from one-hit wonders. On insert (miss), we only increment the TinyLFU sketch if the key has been seen before in the doorkeeper; otherwise we record it without incrementing. On hit, we always increment and update the doorkeeper. This approximates TinyLFUâ€™s doorkeeper concept without heavy overhead and significantly reduces misadmissions during scans.
2) Improve victim selection by always sampling cold candidates from both M1 and M2 (probationary and protected), comparing lexicographically by (TinyLFU estimate, decayed recency) with a +1 bias to make M2 harder to evict. This makes eviction more robust across workloads by properly considering both main segments instead of only M1.

Additionally, I size and maintain the doorkeeper with the cache capacity and clean it on evictions. These changes keep the main hot set more stable and reduce churn under scans while still admitting re-referenced items quickly.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "score", "last_time", "decay_base", "decay_half_life",
        "miss_streak", "scan_cooldown"
    )
=======
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "score", "last_time", "decay_base", "decay_half_life",
        "miss_streak", "scan_cooldown", "door", "door_max"
    )
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.last_tune_time = 0
        self.tune_period = 0
        # LRFU decayed score state
        self.score = {}     # key -> float decayed score
        self.last_time = {} # key -> last access_count
        self.decay_half_life = 16
        self.decay_base = 2 ** (-1.0 / self.decay_half_life)
        # Scan detection state
        self.miss_streak = 0
        self.scan_cooldown = 0
=======
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.last_tune_time = 0
        self.tune_period = 0
        # LRFU decayed score state
        self.score = {}     # key -> float decayed score
        self.last_time = {} # key -> last access_count
        self.decay_half_life = 16
        self.decay_base = 2 ** (-1.0 / self.decay_half_life)
        # Scan detection state
        self.miss_streak = 0
        self.scan_cooldown = 0
        # Doorkeeper to reduce TinyLFU pollution from one-hit wonders
        self.door = OrderedDict()
        self.door_max = 0
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            self.decay_base = 2 ** (-1.0 / float(self.decay_half_life))
            return
=======
            self.decay_base = 2 ** (-1.0 / float(self.decay_half_life))
            # Size doorkeeper similar to cache capacity
            self.door_max = max(256, self.capacity)
            # Trim doorkeeper if needed
            while len(self.door) > self.door_max:
                self.door.popitem(last=False)
            return
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
            self.decay_base = 2 ** (-1.0 / float(self.decay_half_life))
=======
            self.decay_base = 2 ** (-1.0 / float(self.decay_half_life))
            # Resize doorkeeper
            self.door_max = max(256, self.capacity)
            while len(self.door) > self.door_max:
                self.door.popitem(last=False)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Hybrid eviction with scan-aware bias and window sizing:
        - Maintain window near its target: evict from W if it's above target; if below, prefer evicting from M1.
        - TinyLFU admission: compare f(new) to a sampled cold candidate from M1.
          * If f(new) >= f(cand_M1) + bias: evict cand_M1 (admit new).
          * Else: evict W's LRU (reject new from main this round).
        - If M1 is empty, compare against a cold candidate from M2 with stronger bias.
        - Demotions/victim choices within segments rely on decayed scores.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Cool down scan bias gradually on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, _, _ = self._targets()

        # Candidates from segments
        cand_w = self._lru(self.W)
        cand_m1, f_m1, dec_m1 = self._sample_cold_candidate(self.M1, now)
        cand_m2, f_m2, dec_m2 = (None, None, None)
        if cand_m1 is None:
            cand_m2, f_m2, dec_m2 = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)
        bias = 2 if self.scan_cooldown > 0 else 1

        # Keep window near its target
        if len(self.W) > w_tgt and cand_w is not None:
            return cand_w
        if len(self.W) < w_tgt and cand_m1 is not None:
            return cand_m1

        # Admission-vs-eviction: if new is hotter than a cold M1 entry, replace that M1 entry.
        if cand_m1 is not None and f_new >= (f_m1 or 0) + bias:
            return cand_m1

        # Otherwise, prefer the colder between window LRU and cold M1 candidate
        if cand_w is not None and cand_m1 is not None:
            est_w = self.sketch.estimate(cand_w)
            dec_w = self._decayed_score(cand_w, now)
            # Choose lexicographically by (est, decayed)
            if est_w < (f_m1 or 0) or (est_w == (f_m1 or 0) and dec_w <= (dec_m1 or 0.0)):
                return cand_w
            else:
                return cand_m1

        # If only window has a candidate, evict from window
        if cand_w is not None:
            return cand_w

        # If no window/M1 option, consider replacing a cold protected entry (with stronger bias)
        if cand_m2 is not None:
            if f_new >= (f_m2 or 0) + (bias + 1):
                return cand_m2
            # Otherwise pick the colder of window (if any) and M2 candidate
            est_w = self.sketch.estimate(cand_w) if cand_w is not None else None
            dec_w = self._decayed_score(cand_w, now) if cand_w is not None else None
            if cand_w is not None and (est_w is not None) and (est_w < (f_m2 or 0) or (est_w == (f_m2 or 0) and dec_w <= (dec_m2 or 0.0))):
                return cand_w
            return cand_m2

        # Fallbacks: evict coldest in M1 else M2 by decayed score
        if self.M1:
            k, _, _ = self._sample_cold_candidate(self.M1, now)
            if k is not None:
                return k
            return self._lru(self.M1)
        if self.M2:
            k, _, _ = self._sample_cold_candidate(self.M2, now)
            if k is not None:
                return k
            return self._lru(self.M2)

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Hybrid eviction with scan-aware bias and window sizing:
        - Maintain window near its target: evict from W if it's above target; if below, prefer evicting from main.
        - Competitive admission: compare f(new) to sampled cold candidates from both M1 and M2,
          with a stronger bias against evicting from M2.
        - Use lexicographic coldness (TinyLFU estimate, decayed score) when comparing across segments and W.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Cool down scan bias gradually on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, _, _ = self._targets()

        # Candidates from segments
        cand_w = self._lru(self.W)
        cand_m1, f_m1, dec_m1 = self._sample_cold_candidate(self.M1, now)
        cand_m2, f_m2, dec_m2 = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)
        bias = 2 if self.scan_cooldown > 0 else 1

        # Keep window near its target
        if len(self.W) > w_tgt and cand_w is not None:
            return cand_w
        if len(self.W) < w_tgt:
            # Pull from main to let window grow
            if cand_m1 is not None:
                return cand_m1
            if cand_m2 is not None:
                return cand_m2

        # Competitive admission with bias toward protecting M2
        if cand_m1 is not None and f_new >= (f_m1 or 0) + bias:
            return cand_m1
        if cand_m2 is not None and f_new >= (f_m2 or 0) + (bias + 1):
            return cand_m2

        # Choose the colder main candidate lexicographically
        main_k, main_f, main_dec = None, None, None
        if cand_m1 is not None and cand_m2 is not None:
            if (f_m1 < (f_m2 or 1 << 30)) or (f_m1 == f_m2 and (dec_m1 or 0.0) <= (dec_m2 or 0.0)):
                main_k, main_f, main_dec = cand_m1, f_m1, dec_m1
            else:
                main_k, main_f, main_dec = cand_m2, f_m2, dec_m2
        elif cand_m1 is not None:
            main_k, main_f, main_dec = cand_m1, f_m1, dec_m1
        elif cand_m2 is not None:
            main_k, main_f, main_dec = cand_m2, f_m2, dec_m2

        # If both window and main have candidates, pick the lexicographically colder
        if cand_w is not None and main_k is not None:
            est_w = self.sketch.estimate(cand_w)
            dec_w = self._decayed_score(cand_w, now)
            if est_w < (main_f or 0) or (est_w == (main_f or 0) and dec_w <= (main_dec or 0.0)):
                return cand_w
            else:
                return main_k

        # If only one side has a candidate
        if cand_w is not None:
            return cand_w
        if main_k is not None:
            return main_k

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU and LRFU-decayed score.
        - W hit: refresh or early promote if sufficiently hot (stricter during scan).
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key

        # Update TinyLFU and LRFU score
        self.sketch.increment(key, 1)
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        # Any hit breaks a miss streak and cools scan bias slightly
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strong frequency to avoid window churn
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            # Lower thresholds to recognize hot items sooner
            thr_est = 3 if self.scan_cooldown > 0 else 2
            thr_dec = 1.5 if self.scan_cooldown > 0 else 1.0
            if est >= thr_est or dec >= thr_dec:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                # Keep protected region within target using decayed-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote, _, _ = self._sample_cold_candidate(self.M2, now)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            # Rebalance protected size if needed (decayed-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote, _, _ = self._sample_cold_candidate(self.M2, now)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
        self._maybe_tune(now)
=======
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU and LRFU-decayed score.
        - W hit: refresh or early promote if sufficiently hot (stricter during scan).
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key

        # Update TinyLFU and LRFU score
        self.sketch.increment(key, 1)
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        # Update doorkeeper
        self.door[key] = None
        self.door.move_to_end(key)
        if self.door_max > 0 and len(self.door) > self.door_max:
            self.door.popitem(last=False)

        # Any hit breaks a miss streak and cools scan bias slightly
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strong frequency to avoid window churn
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            # Lower thresholds to recognize hot items sooner
            thr_est = 3 if self.scan_cooldown > 0 else 2
            thr_dec = 1.5 if self.scan_cooldown > 0 else 1.0
            if est >= thr_est or dec >= thr_dec:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                # Keep protected region within target using decayed-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote, _, _ = self._sample_cold_candidate(self.M2, now)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            # Rebalance protected size if needed (decayed-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote, _, _ = self._sample_cold_candidate(self.M2, now)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Initialize LRFU metadata modestly (to reduce scan pollution).
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - If W exceeds target, TinyLFU-gated move of W's LRU to M1 (admission path).
        - Keep protected region within target by demoting a decayed-cold entry if needed.
        - Maintain scan detector state.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Initialize decayed metadata
        self.last_time[key] = now
        self.score[key] = 0.5

        # Update scan detector: count consecutive misses
        self.miss_streak += 1
        if self.miss_streak > (self.capacity or 1):
            # Enter/extend scan-biased cooldown
            self.scan_cooldown = max(self.scan_cooldown, self.capacity or 1)
        else:
            # Gradually cool down if not clearly scanning
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, TinyLFU-gated move of W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                cand_m1, f_m1, _ = self._sample_cold_candidate(self.M1, now)
                f_w = self.sketch.estimate(w_lru)
                bias = 2 if self.scan_cooldown > 0 else 1
                # Admit into M1 only if at least as hot as a cold M1 candidate (with bias)
                if f_w >= (f_m1 or 0) + bias:
                    self.W.pop(w_lru, None)
                    self._touch(self.M1, w_lru)
                else:
                    # Keep at LRU to be evicted first; avoid refreshing to MRU
                    pass

        # Keep protected region within target (decayed-aware demotion)
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)

        # Periodically tune window size
        self._maybe_tune(now)
=======
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Initialize LRFU metadata modestly (to reduce scan pollution).
        - Doorkeeper-gated TinyLFU increment to reduce one-hit-wonder pollution.
        - Insert new key into window W (MRU).
        - If W exceeds target, TinyLFU-gated move of W's LRU to M1 (admission path).
        - Keep protected region within target by demoting a decayed-cold entry if needed.
        - Maintain scan detector state.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key

        # Doorkeeper-gated TinyLFU increment
        if key in self.door:
            self.sketch.increment(key, 1)
            # refresh in doorkeeper
            self.door.move_to_end(key)
        else:
            self.door[key] = None
            self.door.move_to_end(key)
            if self.door_max > 0 and len(self.door) > self.door_max:
                self.door.popitem(last=False)

        # Initialize decayed metadata
        self.last_time[key] = now
        self.score[key] = 0.5

        # Update scan detector: count consecutive misses
        self.miss_streak += 1
        if self.miss_streak > (self.capacity or 1):
            # Enter/extend scan-biased cooldown
            self.scan_cooldown = max(self.scan_cooldown, self.capacity or 1)
        else:
            # Gradually cool down if not clearly scanning
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, TinyLFU-gated move of W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                cand_m1, f_m1, _ = self._sample_cold_candidate(self.M1, now)
                f_w = self.sketch.estimate(w_lru)
                bias = 2 if self.scan_cooldown > 0 else 1
                # Admit into M1 only if at least as hot as a cold M1 candidate (with bias)
                if f_w >= (f_m1 or 0) + bias:
                    self.W.pop(w_lru, None)
                    self._touch(self.M1, w_lru)
                else:
                    # Keep at LRU to be evicted first; avoid refreshing to MRU
                    pass

        # Keep protected region within target (decayed-aware demotion)
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)

        # Periodically tune window size
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def on_evict(self, cache_snapshot, obj, evicted_obj):
        """
        Eviction post-processing:
        - Remove evicted key from whichever segment it resides in and purge LRFU meta.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        k = evicted_obj.key
        self.W.pop(k, None)
        self.M1.pop(k, None)
        self.M2.pop(k, None)
        self.score.pop(k, None)
        self.last_time.pop(k, None)
=======
    def on_evict(self, cache_snapshot, obj, evicted_obj):
        """
        Eviction post-processing:
        - Remove evicted key from whichever segment it resides in and purge LRFU meta.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        k = evicted_obj.key
        self.W.pop(k, None)
        self.M1.pop(k, None)
        self.M2.pop(k, None)
        self.score.pop(k, None)
        self.last_time.pop(k, None)
        # Clean from doorkeeper to avoid unbounded growth
        if k in self.door:
            self.door.pop(k, None)
>>>>>>> REPLACE

</DIFF>