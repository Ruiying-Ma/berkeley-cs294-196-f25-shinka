# EVOLVE-BLOCK-START
"""ARC + TinyLFU(CMS) + LRFU-decayed scoring with scan-aware SLRU-style protection.

Public API:
- evict(cache_snapshot, obj) -> key
- update_after_hit(cache_snapshot, obj)
- update_after_insert(cache_snapshot, obj)
- update_after_evict(cache_snapshot, obj, evicted_obj)
"""

from collections import OrderedDict


class _CmSketch:
    """
    Count-Min Sketch with conservative aging (TinyLFU-like).
    - d hash functions, width w (power-of-two >= 256).
    - Periodic right-shift halves counters to forget stale history.
    """
    __slots__ = ("d", "w", "tables", "mask", "ops", "age_period", "seeds")

    def __init__(self, width_power=12, d=3):
        self.d = int(max(1, d))
        w = 1 << int(max(8, width_power))  # min 256
        self.w = w
        self.mask = w - 1
        self.tables = [[0] * w for _ in range(self.d)]
        self.ops = 0
        self.age_period = max(1024, w)
        self.seeds = (0x9e3779b1, 0x85ebca77, 0xc2b2ae3d, 0x27d4eb2f)

    def _hash(self, key_hash: int, i: int) -> int:
        h = key_hash ^ self.seeds[i % len(self.seeds)]
        h ^= (h >> 33) & 0xFFFFFFFFFFFFFFFF
        h *= 0xff51afd7ed558ccd
        h &= 0xFFFFFFFFFFFFFFFF
        h ^= (h >> 33)
        h *= 0xc4ceb9fe1a85ec53
        h &= 0xFFFFFFFFFFFFFFFF
        h ^= (h >> 33)
        return h & self.mask

    def _maybe_age(self):
        self.ops += 1
        if self.ops % self.age_period == 0:
            for t in self.tables:
                for i in range(self.w):
                    t[i] >>= 1

    def increment(self, key: str, amount: int = 1):
        h = hash(key)
        for i in range(self.d):
            idx = self._hash(h, i)
            v = self.tables[i][idx] + amount
            if v > 255:
                v = 255
            self.tables[i][idx] = v
        self._maybe_age()

    def estimate(self, key: str) -> int:
        h = hash(key)
        est = 1 << 30
        for i in range(self.d):
            idx = self._hash(h, i)
            v = self.tables[i][idx]
            if v < est:
                est = v
        return est


class _ArcTinyLfuLrfu:
    """
    ARC resident sets with B1/B2 ghosts + TinyLFU (CMS) for admission
    + LRFU decayed scores for intra-segment selection, with scan-aware bias
    and SLRU-like protected target enforcement.

    Segments:
    - T1: probationary (recency)
    - T2: protected (frequency)
    - B1, B2: ghost lists
    """

    __slots__ = (
        "T1", "T2", "B1", "B2", "p",
        "cms", "capacity", "_sample_k",
        "score", "last_time", "decay_half_life", "decay_base",
        "last_access_seen", "miss_streak", "scan_cooldown",
        "last_victim_key", "last_victim_from"
    )

    def __init__(self):
        self.T1 = OrderedDict()
        self.T2 = OrderedDict()
        self.B1 = OrderedDict()
        self.B2 = OrderedDict()
        self.p = 0.0

        self.cms = _CmSketch(width_power=12, d=3)
        self.capacity = None
        self._sample_k = 6

        self.score = {}
        self.last_time = {}
        self.decay_half_life = 16
        self.decay_base = 2 ** (-1.0 / float(self.decay_half_life))

        self.last_access_seen = -1
        self.miss_streak = 0
        self.scan_cooldown = 0

        self.last_victim_key = None
        self.last_victim_from = None

    # ---------- setup / maintenance ----------

    def _cap(self, cache_snapshot):
        return max(1, int(cache_snapshot.capacity))

    def _ensure_capacity(self, cache_snapshot):
        cap = self._cap(cache_snapshot)
        if self.capacity is None or self.capacity != cap:
            self.capacity = cap
            self._sample_k = max(4, min(12, (cap // 8) or 4))
            # Tune CMS aging relative to capacity
            try:
                self.cms.age_period = max(512, min(16384, cap * 8))
            except Exception:
                pass
            # LRFU decay tuned to capacity
            self.decay_half_life = max(8, min(64, (cap // 2) or 8))
            self.decay_base = 2 ** (-1.0 / float(self.decay_half_life))

    def _reset_if_new_run(self, cache_snapshot):
        # Reset when a new trace starts (access counter restarts)
        if cache_snapshot.access_count <= 1 or self.last_access_seen > cache_snapshot.access_count:
            self.T1.clear(); self.T2.clear(); self.B1.clear(); self.B2.clear()
            self.p = 0.0
            self.score.clear(); self.last_time.clear()
            # Do not reset CMS structure to preserve sizing; counters will age
            self.cms.ops = 0
            self.miss_streak = 0
            self.scan_cooldown = 0
            self.last_victim_key = None
            self.last_victim_from = None
        self.last_access_seen = cache_snapshot.access_count
        self._ensure_capacity(cache_snapshot)

    def _prune_metadata(self, cache_snapshot):
        # Keep resident sets consistent with actual cache
        cache_keys = cache_snapshot.cache.keys()
        for seg in (self.T1, self.T2):
            stale = [k for k in seg.keys() if k not in cache_keys]
            for k in stale:
                seg.pop(k, None)

    def _seed_from_cache(self, cache_snapshot):
        # If both segments empty but cache has content, seed into T1
        if not self.T1 and not self.T2 and cache_snapshot.cache:
            for k in cache_snapshot.cache.keys():
                self.T1[k] = None

    def _protected_target_size(self):
        # SLRU-like target for T2 to avoid over-protection
        cap = self.capacity or 1
        return max(1, int(cap * 0.8))

    def _enforce_protected_target(self):
        tgt = self._protected_target_size()
        while len(self.T2) > tgt:
            demote_k, _ = self.T2.popitem(last=False)  # LRU of T2
            # Demote to MRU of T1
            self.T1[demote_k] = None
            self.T1.move_to_end(demote_k, last=True)

    # ---------- decayed score ----------

    def _ensure_meta(self, k: str, now: int):
        if k not in self.last_time:
            self.last_time[k] = now
        if k not in self.score:
            self.score[k] = 0.0

    def _decayed_score(self, k: str, now: int) -> float:
        self._ensure_meta(k, now)
        dt = now - self.last_time[k]
        if dt > 0:
            self.score[k] *= self.decay_base ** dt
            self.last_time[k] = now
        return self.score[k]

    # ---------- ARC helpers ----------

    def _replace_segment(self, incoming_key: str) -> str:
        """
        ARC Replace rule:
        if |T1| >= 1 and ((incoming in B2 and |T1| == p) or |T1| > p) -> evict from T1
        else evict from T2 (if non-empty), otherwise from T1.
        """
        t1 = len(self.T1)
        t2 = len(self.T2)
        p_int = int(round(max(0.0, min(float(self.capacity or 1), self.p))))
        if t1 >= 1 and ((incoming_key in self.B2 and t1 == p_int) or (t1 > p_int)):
            return "T1"
        if t2 == 0 and t1 > 0:
            return "T1"
        return "T2" if t2 > 0 else "T1"

    def _trim_ghosts(self):
        # Bound ghost sizes to 2Ã—capacity combined
        max_g = 2 * (self.capacity or 1)
        while len(self.B1) + len(self.B2) > max_g:
            if len(self.B1) > len(self.B2):
                self.B1.popitem(last=False)
            else:
                self.B2.popitem(last=False)

    # ---------- sampling ----------

    def _eviction_sample(self, seg: OrderedDict, now: int):
        """
        Sample up to K keys from the LRU tail and choose lexicographic min:
        (CMS estimate ascending, decayed score ascending).
        """
        if not seg:
            return None
        k = max(1, min(self._sample_k, len(seg)))
        it = iter(seg.keys())  # LRU -> MRU
        best_k, best_f, best_d = None, None, None
        for _ in range(k):
            try:
                key = next(it)
            except StopIteration:
                break
            f = self.cms.estimate(key)
            d = self._decayed_score(key, now)
            if (best_k is None
                or f < best_f
                or (f == best_f and d < best_d)):
                best_k, best_f, best_d = key, f, d
                if best_f == 0 and best_d == 0.0:
                    break
        return best_k if best_k is not None else next(iter(seg))

    # ---------- public API ----------

    def evict(self, cache_snapshot, obj):
        """
        Choose a victim:
        - Use ARC replace to choose segment.
        - During scan cooldown bias to evict from T1 if possible.
        - Within segment, pick lexicographic-cold victim using CMS + decayed score.
        - Guard: if chosen T2 victim is much hotter than incoming, try T1 instead.
        """
        self._reset_if_new_run(cache_snapshot)
        self._prune_metadata(cache_snapshot)
        self._seed_from_cache(cache_snapshot)

        now = cache_snapshot.access_count
        seg_name = self._replace_segment(obj.key)

        # Scan-aware: prefer T1 during cooldown
        if self.scan_cooldown > 0 and self.T1:
            seg_name = "T1"

        victim = None
        if seg_name == "T1" and self.T1:
            victim = self._eviction_sample(self.T1, now)
        elif seg_name == "T2" and self.T2:
            cand_t2 = self._eviction_sample(self.T2, now)
            if cand_t2 is not None:
                f_new = self.cms.estimate(obj.key)
                f_t2 = self.cms.estimate(cand_t2)
                bias = 1 if self.scan_cooldown == 0 else 2
                if f_t2 > f_new + bias and len(self.T1) > 0:
                    alt = self._eviction_sample(self.T1, now)
                    victim = alt if alt is not None else cand_t2
                    seg_name = "T1" if alt is not None else "T2"
                else:
                    victim = cand_t2

        if victim is None:
            # Fallback to any cached key
            for k in cache_snapshot.cache.keys():
                victim = k
                seg_name = "T1" if k in self.T1 else ("T2" if k in self.T2 else None)
                break

        self.last_victim_key = victim
        self.last_victim_from = seg_name
        return victim

    def update_after_hit(self, cache_snapshot, obj):
        """
        - Increment CMS and LRFU decayed score.
        - T1 hit: promote to T2 unless in scan cooldown and not hot.
        - T2 hit: refresh.
        - Untracked hit: conservatively place into T2.
        """
        self._reset_if_new_run(cache_snapshot)
        self._prune_metadata(cache_snapshot)

        now = cache_snapshot.access_count
        key = obj.key

        # Any hit breaks miss streak; cooldown decays faster on hits
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown = max(0, self.scan_cooldown - 2)

        # Learn frequency and bump decayed score
        self.cms.increment(key, 1)
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        if key in self.T2:
            self.T2.move_to_end(key, last=True)
        elif key in self.T1:
            hot = (self.cms.estimate(key) >= 2) or (self._decayed_score(key, now) >= 1.0)
            if self.scan_cooldown > 0 and not hot:
                self.T1.move_to_end(key, last=True)
            else:
                self.T1.pop(key, None)
                self.T2[key] = None
                self.T2.move_to_end(key, last=True)
        else:
            # Desync: treat as warm/hot
            self.T2[key] = None
            self.T2.move_to_end(key, last=True)

        # Keep protected region within target
        self._enforce_protected_target()

    def update_after_insert(self, cache_snapshot, obj):
        """
        - Increment CMS and initialize decayed score modestly.
        - ARC p-adaptation on B1/B2 hits.
        - Fresh miss: early promote to T2 if clearly hot; else place in T1.
        - Scan-aware: avoid promoting during cooldown unless hot.
        """
        self._reset_if_new_run(cache_snapshot)
        self._prune_metadata(cache_snapshot)

        now = cache_snapshot.access_count
        key = obj.key
        cap = self.capacity or 1

        # Scan detection and cooldown
        self.miss_streak += 1
        if self.scan_cooldown > 0:
            self.scan_cooldown = max(0, self.scan_cooldown - 1)
        if self.miss_streak >= max(24, cap // 3):
            self.scan_cooldown = max(self.scan_cooldown, min(cap, self.miss_streak))

        # Learn on admission and initialize decayed metadata
        self.cms.increment(key, 1)
        self.last_time[key] = now
        # Start modest to limit scan pollution
        self.score[key] = max(self.score.get(key, 0.0), 0.5)

        # Remove any stale placements
        self.T1.pop(key, None)
        self.T2.pop(key, None)

        # ARC adaptation on ghost hits
        if key in self.B1:
            delta = max(1, len(self.B2) // max(1, len(self.B1)))
            self.p = min(float(cap), self.p + float(delta))
            self.B1.pop(key, None)
            # Prefer T2 unless in scan cooldown and not hot
            if self.scan_cooldown > 0 and self.cms.estimate(key) < 2:
                self.T1[key] = None
                self.T1.move_to_end(key, last=True)
            else:
                self.T2[key] = None
                self.T2.move_to_end(key, last=True)
        elif key in self.B2:
            delta = max(1, len(self.B1) // max(1, len(self.B2)))
            self.p = max(0.0, self.p - float(delta))
            self.B2.pop(key, None)
            if self.scan_cooldown > 0 and self.cms.estimate(key) < 2:
                self.T1[key] = None
                self.T1.move_to_end(key, last=True)
            else:
                self.T2[key] = None
                self.T2.move_to_end(key, last=True)
        else:
            # Fresh miss: decide T1 vs T2
            thr = 6 if self.scan_cooldown > 0 else 4
            if self.cms.estimate(key) >= thr:
                self.T2[key] = None
                self.T2.move_to_end(key, last=True)
            else:
                self.T1[key] = None
                self.T1.move_to_end(key, last=True)

        # Keep protected region within target
        self._enforce_protected_target()
        # Bound ghosts
        self._trim_ghosts()

    def update_after_evict(self, cache_snapshot, obj, evicted_obj):
        """
        - Remove from resident and place into corresponding ghost list.
        - Cleanup decayed metadata.
        - Mild cooldown decay on eviction.
        """
        self._reset_if_new_run(cache_snapshot)
        evk = evicted_obj.key

        removed_from = None
        if evk in self.T1:
            self.T1.pop(evk, None)
            removed_from = "T1"
        elif evk in self.T2:
            self.T2.pop(evk, None)
            removed_from = "T2"
        else:
            removed_from = self.last_victim_from

        if removed_from == "T1":
            self.B1.pop(evk, None)
            self.B1[evk] = None
        elif removed_from == "T2":
            self.B2.pop(evk, None)
            self.B2[evk] = None

        self.score.pop(evk, None)
        self.last_time.pop(evk, None)

        self._trim_ghosts()
        if self.last_victim_key == evk:
            self.last_victim_key = None
            self.last_victim_from = None

        if self.scan_cooldown > 0:
            self.scan_cooldown = max(0, self.scan_cooldown - 1)


# Singleton policy instance
_policy = _ArcTinyLfuLrfu()


def evict(cache_snapshot, obj):
    return _policy.evict(cache_snapshot, obj)


def update_after_hit(cache_snapshot, obj):
    _policy.update_after_hit(cache_snapshot, obj)


def update_after_insert(cache_snapshot, obj):
    _policy.update_after_insert(cache_snapshot, obj)


def update_after_evict(cache_snapshot, obj, evicted_obj):
    _policy.update_after_evict(cache_snapshot, obj, evicted_obj)

# EVOLVE-BLOCK-END