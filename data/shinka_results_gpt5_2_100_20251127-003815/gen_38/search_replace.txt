<NAME>
conservative_sketch_and_window_eviction_fixes
</NAME>

<DESCRIPTION>
I propose three targeted improvements that address the observed regressions and reduce miss rates:

1) Switch the TinyLFU sketch to conservative updates. The current increment increases all counters for a key, which inflates estimates and harms the competitive admission/eviction decisions. Conservative updates increment only counters at the current minimum, reducing noise and better distinguishing hot vs. cold items, especially important under mixed and bursty workloads.

2) Remove harmful window undershoot enforcement in victim selection and reduce scan bias. The existing choose_victim evicts from M1 whenever the window is below target, which unnecessarily sacrifices main-cache entries to “grow” the window. Victim selection should be guided by competitive admission (new vs. M1/M2 candidates) and window overflow only. I remove the undershoot path and lower scan bias from +3 to +2 to reduce over-reaction during scans.

3) Fix window overflow handling to avoid refreshing rejected W_LRU to MRU and lower early-promotion thresholds. When the W→M1 admission fails, moving the W_LRU to MRU prevents shedding cold items and causes churn. I keep it at LRU (do nothing), letting it be the first to go if space is needed. Early-promotion thresholds in on_hit are slightly lowered to recognize hot items sooner, improving warm-up without over-protecting one-timers.

Together these changes align the policy closer to proven W-TinyLFU behavior (like Caffeine), correct pollution paths, and strengthen the frequency signal fidelity, improving hit rates across diverse traces.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def increment(self, key: str, amount: int = 1):
        h = hash(key)
        for i in range(self.d):
            idx = self._hash(h, i)
            v = self.tables[i][idx] + amount
            if v > 255:
                v = 255
            self.tables[i][idx] = v
        self._maybe_age()
=======
    def increment(self, key: str, amount: int = 1):
        # Conservative update: increment only counters at the current minimum to reduce noise
        h = hash(key)
        idxs = [self._hash(h, i) for i in range(self.d)]
        vals = [self.tables[i][idxs[i]] for i in range(self.d)]
        mn = min(vals) if vals else 0
        for i in range(self.d):
            if self.tables[i][idxs[i]] == mn:
                v = self.tables[i][idxs[i]] + amount
                if v > 255:
                    v = 255
                self.tables[i][idxs[i]] = v
        self._maybe_age()
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Hybrid eviction with scan-aware bias and window sizing:
        - Maintain window near its target: evict from W if it's above target; if below, prefer evicting from M1.
        - TinyLFU admission: compare f(new) to a sampled cold candidate from M1.
          * If f(new) >= f(cand_M1) + bias: evict cand_M1 (admit new).
          * Else: evict W's LRU (reject new from main this round).
        - If M1 is empty, compare against a cold candidate from M2 with stronger bias.
        - Demotions/victim choices within segments rely on decayed scores.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Cool down scan bias gradually on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, _, _ = self._targets()

        # Candidates from segments
        cand_w = self._lru(self.W)
        cand_m1, f_m1, dec_m1 = self._sample_cold_candidate(self.M1, now)
        cand_m2, f_m2, dec_m2 = (None, None, None)
        if cand_m1 is None:
            cand_m2, f_m2, dec_m2 = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)
        bias = 3 if self.scan_cooldown > 0 else 1

        # Keep window near its target
        if len(self.W) > w_tgt and cand_w is not None:
            return cand_w
        if len(self.W) < w_tgt and cand_m1 is not None:
            return cand_m1

        # Admission-vs-eviction: if new is hotter than a cold M1 entry, replace that M1 entry.
        if cand_m1 is not None and f_new >= (f_m1 or 0) + bias:
            return cand_m1

        # Otherwise, prefer the colder between window LRU and cold M1 candidate
        if cand_w is not None and cand_m1 is not None:
            est_w = self.sketch.estimate(cand_w)
            dec_w = self._decayed_score(cand_w, now)
            # Choose lexicographically by (est, decayed)
            if est_w < (f_m1 or 0) or (est_w == (f_m1 or 0) and dec_w <= (dec_m1 or 0.0)):
                return cand_w
            else:
                return cand_m1

        # If only window has a candidate, evict from window
        if cand_w is not None:
            return cand_w

        # If no window/M1 option, consider replacing a cold protected entry (with stronger bias)
        if cand_m2 is not None:
            if f_new >= (f_m2 or 0) + (bias + 1):
                return cand_m2
            # Otherwise pick the colder of window (if any) and M2 candidate
            est_w = self.sketch.estimate(cand_w) if cand_w is not None else None
            dec_w = self._decayed_score(cand_w, now) if cand_w is not None else None
            if cand_w is not None and (est_w is not None) and (est_w < (f_m2 or 0) or (est_w == (f_m2 or 0) and dec_w <= (dec_m2 or 0.0))):
                return cand_w
            return cand_m2

        # Fallbacks: evict coldest in M1 else M2 by decayed score
        if self.M1:
            k, _, _ = self._sample_cold_candidate(self.M1, now)
            if k is not None:
                return k
            return self._lru(self.M1)
        if self.M2:
            k, _, _ = self._sample_cold_candidate(self.M2, now)
            if k is not None:
                return k
            return self._lru(self.M2)

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Hybrid eviction with scan-aware bias:
        - Trim window when above target by evicting W's LRU.
        - Otherwise, base eviction on TinyLFU competitive admission against a cold M1 (or M2) candidate.
        - Demotions/victim choices within segments rely on decayed scores.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Cool down scan bias gradually on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, _, _ = self._targets()

        # Candidates from segments
        cand_w = self._lru(self.W)
        cand_m1, f_m1, dec_m1 = self._sample_cold_candidate(self.M1, now)
        cand_m2, f_m2, dec_m2 = (None, None, None)
        if cand_m1 is None:
            cand_m2, f_m2, dec_m2 = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)
        bias = 2 if self.scan_cooldown > 0 else 1

        # Keep window from exceeding its target
        if len(self.W) > w_tgt and cand_w is not None:
            return cand_w

        # Admission-vs-eviction: if new is hotter than a cold M1 entry, replace that M1 entry.
        if cand_m1 is not None and f_new >= (f_m1 or 0) + bias:
            return cand_m1

        # Otherwise, prefer the colder between window LRU and cold M1 candidate
        if cand_w is not None and cand_m1 is not None:
            est_w = self.sketch.estimate(cand_w)
            dec_w = self._decayed_score(cand_w, now)
            # Choose lexicographically by (est, decayed)
            if est_w < (f_m1 or 0) or (est_w == (f_m1 or 0) and dec_w <= (dec_m1 or 0.0)):
                return cand_w
            else:
                return cand_m1

        # If only window has a candidate, evict from window
        if cand_w is not None:
            return cand_w

        # If no window/M1 option, consider replacing a cold protected entry (with modestly stronger bias)
        if cand_m2 is not None:
            if f_new >= (f_m2 or 0) + (bias + 1):
                return cand_m2
            # Otherwise pick the colder of window (if any) and M2 candidate
            est_w = self.sketch.estimate(cand_w) if cand_w is not None else None
            dec_w = self._decayed_score(cand_w, now) if cand_w is not None else None
            if cand_w is not None and (est_w is not None) and (est_w < (f_m2 or 0) or (est_w == (f_m2 or 0) and dec_w <= (dec_m2 or 0.0))):
                return cand_w
            return cand_m2

        # Fallbacks: evict coldest in M1 else M2 by decayed score
        if self.M1:
            k, _, _ = self._sample_cold_candidate(self.M1, now)
            if k is not None:
                return k
            return self._lru(self.M1)
        if self.M2:
            k, _, _ = self._sample_cold_candidate(self.M2, now)
            if k is not None:
                return k
            return self._lru(self.M2)

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
            # Early promotion if strong frequency to avoid window churn
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            # Slightly stricter early-promotion thresholds to reduce pollution
            thr_est = 4 if self.scan_cooldown > 0 else 3
            thr_dec = 2.0 if self.scan_cooldown > 0 else 1.5
            if est >= thr_est or dec >= thr_dec:
=======
            # Early promotion if strong frequency to avoid window churn
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            # Lower thresholds to recognize hot items sooner
            thr_est = 3 if self.scan_cooldown > 0 else 2
            thr_dec = 1.5 if self.scan_cooldown > 0 else 1.0
            if est >= thr_est or dec >= thr_dec:
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
                cand_m1, f_m1, _ = self._sample_cold_candidate(self.M1, now)
                f_w = self.sketch.estimate(w_lru)
                bias = 3 if self.scan_cooldown > 0 else 1
                # Admit into M1 only if at least as hot as a cold M1 candidate (with bias)
                if f_w >= (f_m1 or 0) + bias:
                    self.W.pop(w_lru, None)
                    self._touch(self.M1, w_lru)
                else:
                    # Keep in window; refresh to MRU to avoid immediate churn
                    self._touch(self.W, w_lru)
=======
                cand_m1, f_m1, _ = self._sample_cold_candidate(self.M1, now)
                f_w = self.sketch.estimate(w_lru)
                bias = 2 if self.scan_cooldown > 0 else 1
                # Admit into M1 only if at least as hot as a cold M1 candidate (with bias)
                if f_w >= (f_m1 or 0) + bias:
                    self.W.pop(w_lru, None)
                    self._touch(self.M1, w_lru)
                else:
                    # Keep at LRU to be evicted first; avoid refreshing to MRU
                    pass
>>>>>>> REPLACE

</DIFF>