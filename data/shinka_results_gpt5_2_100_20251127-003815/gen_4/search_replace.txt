<NAME>
lrfu_decay_eviction
</NAME>

<DESCRIPTION>
I replace the pure LRU implementation with an adaptive LRFU-like policy that combines recency and frequency via exponential decay. LRU alone suffers on frequency-heavy workloads and scans; LFU without aging suffers during phase changes. LRFU (recency-frequency fusion) mitigates both by maintaining a per-key score that decays over time and increases on hits.

Key ideas:
- Maintain per-key score and last_access_time.
- On each hit, decay the score to now and add 1.0 (capturing frequency and recency).
- On insertion, initialize a modest score (0.5) to dampen scan pollution (new objects are not overvalued).
- On eviction, lazily decay all candidatesâ€™ scores to the current time and evict the minimum score; break ties by older last access (LRU fallback).

This design adapts to different workloads: frequent items accumulate higher scores, but decay allows new phases to take over; scan bursts get low initial scores and are evicted quickly. This generally reduces miss rates across mixed traces compared to plain LRU.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""

m_key_timestamp = dict()

def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_ts = min(m_key_timestamp.values())
    candid_obj_keys = list(key for key in cache_snapshot.cache if m_key_timestamp[key] == min_ts)
    candid_obj_key = candid_obj_keys[0]
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global m_key_timestamp
    assert obj.key in m_key_timestamp
    m_key_timestamp[obj.key] = cache_snapshot.access_count

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global m_key_timestamp
    assert obj.key not in m_key_timestamp
    m_key_timestamp[obj.key] = cache_snapshot.access_count

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global m_key_timestamp
    assert obj.key not in m_key_timestamp
    assert evicted_obj.key in m_key_timestamp
    m_key_timestamp.pop(evicted_obj.key)
=======
"""Adaptive LRFU-like eviction: combine recency and frequency with exponential decay"""

# Configuration: half-life in number of accesses for score decay.
# After DECAY_HALF_LIFE accesses without a hit, a key's score halves.
DECAY_HALF_LIFE = 16
DECAY_BASE = 2 ** (-1.0 / DECAY_HALF_LIFE)

# Per-key metadata for cached objects
_key_score = dict()      # key -> float decayed frequency score
_key_last_time = dict()  # key -> int last access_count when we updated its score

def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    global _key_score, _key_last_time
    now = cache_snapshot.access_count

    # Choose the object with the minimum decayed score; tie-break on older last access (LRU fallback).
    min_key = None
    min_score = None
    min_old_time = None

    # Lazily decay scores to "now" during victim selection to avoid global walks elsewhere.
    for k in cache_snapshot.cache.keys():
        # Initialize metadata if missing (robustness)
        if k not in _key_last_time:
            _key_last_time[k] = now
        if k not in _key_score:
            _key_score[k] = 0.0

        old_time = _key_last_time[k]
        dt = now - old_time
        if dt > 0:
            _key_score[k] *= pow(DECAY_BASE, dt)
            _key_last_time[k] = now
        s = _key_score[k]

        if (min_score is None) or (s < min_score) or (s == min_score and old_time < min_old_time):
            min_score = s
            min_key = k
            min_old_time = old_time

    return min_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global _key_score, _key_last_time
    now = cache_snapshot.access_count

    # Ensure metadata exists
    if obj.key not in _key_last_time:
        _key_last_time[obj.key] = now
    if obj.key not in _key_score:
        _key_score[obj.key] = 0.0

    dt = now - _key_last_time[obj.key]
    if dt > 0:
        _key_score[obj.key] *= pow(DECAY_BASE, dt)
    _key_score[obj.key] += 1.0  # frequency boost
    _key_last_time[obj.key] = now

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global _key_score, _key_last_time
    now = cache_snapshot.access_count
    _key_last_time[obj.key] = now
    # Start with a modest score to reduce scan pollution; frequent re-references will quickly boost it.
    _key_score[obj.key] = 0.5

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global _key_score, _key_last_time
    _key_score.pop(evicted_obj.key, None)
    _key_last_time.pop(evicted_obj.key, None)
>>>>>>> REPLACE

</DIFF>