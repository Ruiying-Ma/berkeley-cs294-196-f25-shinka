<NAME>
ema_tinylfu_ring_boost
</NAME>

<DESCRIPTION>
I introduce an EMA-based scan detector and a recent-membership ring buffer to strengthen scan resistance and accelerate phase adaptation, while restoring the TinyLFU sketch to conservative updates to reduce noise. Specifically:

1) Conservative TinyLFU increments: Switch Count-Min Sketch increment to a conservative update (increment only the minimum counters). This reduces overcounting noise and improves admission decisions.

2) EMA-based scan guard: Track an EMA of the miss rate (ema_miss with α=0.05). When ema_miss is high (>0.8), the policy assumes a scan/phase churn and:
   - Raises admission bias and early-promotion thresholds.
   - Prefers evicting from the window (W) over main segments unless the incoming item clearly outclasses a cold M1 candidate.

3) Recent-phase ring buffer: Maintain a ring buffer and set with size ≈ capacity. If a key is in this ring, we grant it a small admission boost (+1) when competing against cold candidates, accelerating the capture of newly-hot items without inflating the protected segment.

4) Eviction comparator improvements: The choose_victim function integrates EMA and ring-boosted frequency for new items, while protecting M2 with stronger bias.

5) Integration across updates: on_hit and on_insert update the EMA and the ring; on_evict cleans up the ring. Early promotion thresholds in W are tightened under detected scans (via EMA or cooldown), reducing pollution.

These changes improve resilience to scans and phase changes (weak traces) without sacrificing stable-performance traces, aiming to reduce overall miss rate.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from collections import OrderedDict
import random
from itertools import islice
=======
from collections import OrderedDict, deque
import random
from itertools import islice
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    __slots__ = ("d", "w", "tables", "mask", "ops", "age_period", "seeds")

    def __init__(self, width_power=12, d=3):
        self.d = int(max(1, d))
        w = 1 << int(max(8, width_power))  # min 256
        self.w = w
        self.mask = w - 1
        self.tables = [[0] * w for _ in range(self.d)]
        self.ops = 0
        self.age_period = max(1024, w)
        self.seeds = (0x9e3779b1, 0x85ebca77, 0xc2b2ae3d, 0x27d4eb2f)

    def _hash(self, key_hash: int, i: int) -> int:
        h = key_hash ^ self.seeds[i % len(self.seeds)]
        h ^= (h >> 33) & 0xFFFFFFFFFFFFFFFF
        h *= 0xff51afd7ed558ccd
        h &= 0xFFFFFFFFFFFFFFFF
        h ^= (h >> 33)
        h *= 0xc4ceb9fe1a85ec53
        h &= 0xFFFFFFFFFFFFFFFF
        h ^= (h >> 33)
        return h & self.mask

    def _maybe_age(self):
        self.ops += 1
        if self.ops % self.age_period == 0:
            for t in self.tables:
                for i in range(self.w):
                    t[i] >>= 1

    def increment(self, key: str, amount: int = 1):
        h = hash(key)
        for i in range(self.d):
            idx = self._hash(h, i)
            v = self.tables[i][idx] + amount
            if v > 255:
                v = 255
            self.tables[i][idx] = v
        self._maybe_age()
=======
    __slots__ = ("d", "w", "tables", "mask", "ops", "age_period", "seeds")

    def __init__(self, width_power=12, d=3):
        self.d = int(max(1, d))
        w = 1 << int(max(8, width_power))  # min 256
        self.w = w
        self.mask = w - 1
        self.tables = [[0] * w for _ in range(self.d)]
        self.ops = 0
        self.age_period = max(1024, w)
        self.seeds = (0x9e3779b1, 0x85ebca77, 0xc2b2ae3d, 0x27d4eb2f)

    def _hash(self, key_hash: int, i: int) -> int:
        h = key_hash ^ self.seeds[i % len(self.seeds)]
        h ^= (h >> 33) & 0xFFFFFFFFFFFFFFFF
        h *= 0xff51afd7ed558ccd
        h &= 0xFFFFFFFFFFFFFFFF
        h ^= (h >> 33)
        h *= 0xc4ceb9fe1a85ec53
        h &= 0xFFFFFFFFFFFFFFFF
        h ^= (h >> 33)
        return h & self.mask

    def _maybe_age(self):
        self.ops += 1
        if self.ops % self.age_period == 0:
            for t in self.tables:
                for i in range(self.w):
                    t[i] >>= 1

    def increment(self, key: str, amount: int = 1):
        # Conservative update: increment only counters at the current minimum to reduce noise
        h = hash(key)
        idxs = [self._hash(h, i) for i in range(self.d)]
        vals = [self.tables[i][idxs[i]] for i in range(self.d)]
        mn = min(vals) if vals else 0
        for i in range(self.d):
            if self.tables[i][idxs[i]] == mn:
                v = self.tables[i][idxs[i]] + amount
                if v > 255:
                    v = 255
                self.tables[i][idxs[i]] = v
        self._maybe_age()
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "score", "last_time", "decay_base", "decay_half_life",
        "miss_streak", "scan_cooldown",
        "prom_cnt", "demo_cnt", "hits_m2"
    )
=======
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "score", "last_time", "decay_base", "decay_half_life",
        "miss_streak", "scan_cooldown",
        "prom_cnt", "demo_cnt", "hits_m2",
        "ema_miss", "ema_alpha", "recent_ring", "recent_set", "ring_max"
    )
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.hits_m2 = 0
        self.last_tune_time = 0
        self.tune_period = 0
        self.prom_cnt = 0
        self.demo_cnt = 0
        # LRFU decayed score state
        self.score = {}     # key -> float decayed score
        self.last_time = {} # key -> last access_count
        self.decay_half_life = 16
        self.decay_base = 2 ** (-1.0 / self.decay_half_life)
        # Scan detection state
        self.miss_streak = 0
        self.scan_cooldown = 0
=======
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.hits_m2 = 0
        self.last_tune_time = 0
        self.tune_period = 0
        self.prom_cnt = 0
        self.demo_cnt = 0
        # LRFU decayed score state
        self.score = {}     # key -> float decayed score
        self.last_time = {} # key -> last access_count
        self.decay_half_life = 16
        self.decay_base = 2 ** (-1.0 / self.decay_half_life)
        # Scan detection state
        self.miss_streak = 0
        self.scan_cooldown = 0
        # EMA miss-rate and recent-phase accelerator
        self.ema_miss = 0.0
        self.ema_alpha = 0.05
        self.recent_ring = deque()
        self.recent_set = set()
        self.ring_max = 0
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _ensure_capacity(self, cap: int):
        if self.capacity is None:
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            # Age faster for smaller caches
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
            # Set adaptive tuning period relative to capacity
            self.tune_period = max(256, self.capacity * 4)
            self.last_tune_time = 0
            # LRFU decay tuned to capacity: shorter half-life for small caches
            self.decay_half_life = max(8, min(64, (self.capacity // 2) or 8))
            self.decay_base = 2 ** (-1.0 / float(self.decay_half_life))
            return
        if self.capacity != cap:
            # Reset segments if external capacity changes to avoid desync.
            self.W.clear(); self.M1.clear(); self.M2.clear()
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
            self.tune_period = max(256, self.capacity * 4)
            self.last_tune_time = 0
            self.decay_half_life = max(8, min(64, (self.capacity // 2) or 8))
            self.decay_base = 2 ** (-1.0 / float(self.decay_half_life))
=======
    def _ensure_capacity(self, cap: int):
        if self.capacity is None:
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            # Age faster for smaller caches
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
            # Set adaptive tuning period relative to capacity
            self.tune_period = max(256, self.capacity * 4)
            self.last_tune_time = 0
            # LRFU decay tuned to capacity: shorter half-life for small caches
            self.decay_half_life = max(8, min(64, (self.capacity // 2) or 8))
            self.decay_base = 2 ** (-1.0 / float(self.decay_half_life))
            # Recent ring sizing
            self.ring_max = max(1, self.capacity)
            # trim if needed
            while len(self.recent_ring) > self.ring_max:
                old = self.recent_ring.popleft()
                self.recent_set.discard(old)
            return
        if self.capacity != cap:
            # Reset segments if external capacity changes to avoid desync.
            self.W.clear(); self.M1.clear(); self.M2.clear()
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
            self.tune_period = max(256, self.capacity * 4)
            self.last_tune_time = 0
            self.decay_half_life = max(8, min(64, (self.capacity // 2) or 8))
            self.decay_base = 2 ** (-1.0 / float(self.decay_half_life))
            # Resize recent ring
            self.ring_max = max(1, self.capacity)
            while len(self.recent_ring) > self.ring_max:
                old = self.recent_ring.popleft()
                self.recent_set.discard(old)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Hybrid eviction with scan-aware bias and window sizing:
        - Keep window near target: evict from W if it's above target; if below, prefer evicting from M1.
        - Competitive admission: compare f(new) against sampled cold candidates from M1 and M2.
        - Use lexicographic coldness (TinyLFU est, decayed score) when comparing across segments and W.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Cool down scan bias gradually on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, _, _ = self._targets()

        # Candidates from segments
        cand_w = self._lru(self.W)
        cand_m1, f_m1, dec_m1 = self._sample_cold_candidate(self.M1, now)
        cand_m2, f_m2, dec_m2 = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)
        bias = 2 if self.scan_cooldown > 0 else 1

        # Keep window near its target
        if len(self.W) > w_tgt and cand_w is not None:
            return cand_w
        if len(self.W) < w_tgt:
            # Pull from main to let window grow
            if cand_m1 is not None:
                return cand_m1
            if cand_m2 is not None:
                return cand_m2

        # Competitive admission with bias toward protecting M2
        if cand_m1 is not None and f_new >= (f_m1 or 0) + bias:
            return cand_m1
        if cand_m2 is not None and f_new >= (f_m2 or 0) + (bias + 1):
            return cand_m2

        # Choose the colder main candidate lexicographically
        main_k, main_f, main_dec = None, None, None
        if cand_m1 is not None and cand_m2 is not None:
            if (f_m1 < (f_m2 or 1 << 30)) or (f_m1 == f_m2 and (dec_m1 or 0.0) <= (dec_m2 or 0.0)):
                main_k, main_f, main_dec = cand_m1, f_m1, dec_m1
            else:
                main_k, main_f, main_dec = cand_m2, f_m2, dec_m2
        elif cand_m1 is not None:
            main_k, main_f, main_dec = cand_m1, f_m1, dec_m1
        elif cand_m2 is not None:
            main_k, main_f, main_dec = cand_m2, f_m2, dec_m2

        # If both window and main have candidates, pick the lexicographically colder
        if cand_w is not None and main_k is not None:
            est_w = self.sketch.estimate(cand_w)
            dec_w = self._decayed_score(cand_w, now)
            if est_w < (main_f or 0) or (est_w == (main_f or 0) and dec_w <= (main_dec or 0.0)):
                return cand_w
            else:
                return main_k

        # If only one side has a candidate
        if cand_w is not None:
            return cand_w
        if main_k is not None:
            return main_k

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Hybrid eviction with scan-aware bias and window sizing:
        - Keep window near target: evict from W if it's above target; if below, prefer evicting from M1.
        - Competitive admission: compare f(new) against sampled cold candidates from M1 and M2.
        - Use lexicographic coldness (TinyLFU est, decayed score) when comparing across segments and W.
        - EMA-based scan guard: when ema_miss is high, bias strongly toward evicting from the window.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Cool down scan bias gradually on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        em_high = self.ema_miss > 0.8

        w_tgt, _, _ = self._targets()

        # Candidates from segments
        cand_w = self._lru(self.W)
        cand_m1, f_m1, dec_m1 = self._sample_cold_candidate(self.M1, now)
        cand_m2, f_m2, dec_m2 = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)
        # Recent-phase boost for new item if seen in recent ring
        if new_obj.key in self.recent_set:
            f_new += 1

        bias = 3 if (self.scan_cooldown > 0 or em_high) else 1

        # Keep window near its target
        if len(self.W) > w_tgt and cand_w is not None:
            return cand_w
        if len(self.W) < w_tgt:
            # Pull from main to let window grow
            if cand_m1 is not None:
                return cand_m1
            if cand_m2 is not None:
                return cand_m2

        # If scanning/heavy churn, favor window eviction unless new clearly beats a cold M1
        if em_high and cand_w is not None:
            if cand_m1 is not None and f_new >= (f_m1 or 0) + bias:
                return cand_m1
            return cand_w

        # Competitive admission with bias toward protecting M2
        if cand_m1 is not None and f_new >= (f_m1 or 0) + bias:
            return cand_m1
        if cand_m2 is not None and f_new >= (f_m2 or 0) + (bias + 1):
            return cand_m2

        # Choose the colder main candidate lexicographically
        main_k, main_f, main_dec = None, None, None
        if cand_m1 is not None and cand_m2 is not None:
            if (f_m1 < (f_m2 or 1 << 30)) or (f_m1 == f_m2 and (dec_m1 or 0.0) <= (dec_m2 or 0.0)):
                main_k, main_f, main_dec = cand_m1, f_m1, dec_m1
            else:
                main_k, main_f, main_dec = cand_m2, f_m2, dec_m2
        elif cand_m1 is not None:
            main_k, main_f, main_dec = cand_m1, f_m1, dec_m1
        elif cand_m2 is not None:
            main_k, main_f, main_dec = cand_m2, f_m2, dec_m2

        # If both window and main have candidates, pick the lexicographically colder
        if cand_w is not None and main_k is not None:
            est_w = self.sketch.estimate(cand_w)
            dec_w = self._decayed_score(cand_w, now)
            if est_w < (main_f or 0) or (est_w == (main_f or 0) and dec_w <= (main_dec or 0.0)):
                return cand_w
            else:
                return main_k

        # If only one side has a candidate
        if cand_w is not None:
            return cand_w
        if main_k is not None:
            return main_k

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU and LRFU-decayed score.
        - W hit: refresh or early promote if sufficiently hot (stricter during scan).
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key

        # Update TinyLFU and LRFU score
        self.sketch.increment(key, 1)
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        # Any hit breaks a miss streak and cools scan bias slightly
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strong frequency to avoid window churn
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            thr_est = 3 if self.scan_cooldown > 0 else 2
            thr_dec = 1.5 if self.scan_cooldown > 0 else 1.0
            if est >= thr_est or dec >= thr_dec:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                self.prom_cnt += 1
                # Keep protected region within target using decayed-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote, _, _ = self._sample_cold_candidate(self.M2, now)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
                        self.demo_cnt += 1
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            self.prom_cnt += 1
            # Rebalance protected size if needed (decayed-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote, _, _ = self._sample_cold_candidate(self.M2, now)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
                    self.demo_cnt += 1
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self.hits_m2 += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self.hits_m2 += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.demo_cnt += 1
        self._maybe_tune(now)
=======
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU and LRFU-decayed score.
        - W hit: refresh or early promote if sufficiently hot (stricter during scan).
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key

        # Update TinyLFU and LRFU score
        self.sketch.increment(key, 1)
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        # EMA update for hit
        self.ema_miss = self.ema_miss * (1.0 - self.ema_alpha)

        # Update recent ring
        if self.ring_max > 0 and key not in self.recent_set:
            self.recent_set.add(key)
            self.recent_ring.append(key)
            while len(self.recent_ring) > self.ring_max:
                old = self.recent_ring.popleft()
                self.recent_set.discard(old)

        # Any hit breaks a miss streak and cools scan bias slightly
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        em_high = self.ema_miss > 0.8

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strong frequency to avoid window churn
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            thr_est = 3 if self.scan_cooldown > 0 else 2
            thr_dec = 1.5 if self.scan_cooldown > 0 else 1.0
            if em_high:
                thr_est += 1
                thr_dec += 0.5
            if est >= thr_est or dec >= thr_dec:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                self.prom_cnt += 1
                # Keep protected region within target using decayed-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote, _, _ = self._sample_cold_candidate(self.M2, now)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
                        self.demo_cnt += 1
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            self.prom_cnt += 1
            # Rebalance protected size if needed (decayed-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote, _, _ = self._sample_cold_candidate(self.M2, now)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
                    self.demo_cnt += 1
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self.hits_m2 += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self.hits_m2 += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.demo_cnt += 1
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Initialize LRFU metadata modestly (to reduce scan pollution).
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - If W exceeds target, TinyLFU-gated move of W's LRU to M1 (admission path).
        - Keep protected region within target by demoting a decayed-cold entry if needed.
        - Maintain scan detector state.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Initialize decayed metadata
        self.last_time[key] = now
        self.score[key] = 0.5

        # Update scan detector: count consecutive misses
        self.miss_streak += 1
        if self.miss_streak > (self.capacity or 1):
            # Enter/extend scan-biased cooldown
            self.scan_cooldown = max(self.scan_cooldown, self.capacity or 1)
        else:
            # Gradually cool down if not clearly scanning
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, TinyLFU-gated move of W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                cand_m1, f_m1, _ = self._sample_cold_candidate(self.M1, now)
                f_w = self.sketch.estimate(w_lru)
                bias = 2 if self.scan_cooldown > 0 else 1
                # Admit into M1 only if at least as hot as a cold M1 candidate (with bias)
                if f_w >= (f_m1 or 0) + bias:
                    self.W.pop(w_lru, None)
                    self._touch(self.M1, w_lru)
                else:
                    # Keep at LRU to be evicted first; avoid refreshing to MRU
                    pass

        # Keep protected region within target (decayed-aware demotion)
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.demo_cnt += 1

        # Periodically tune window size
        self._maybe_tune(now)
=======
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Initialize LRFU metadata modestly (to reduce scan pollution).
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - If W exceeds target, TinyLFU-gated move of W's LRU to M1 (admission path).
        - Keep protected region within target by demoting a decayed-cold entry if needed.
        - Maintain scan detector state and EMA miss rate.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Initialize decayed metadata
        self.last_time[key] = now
        self.score[key] = 0.5

        # EMA update for miss
        self.ema_miss = self.ema_miss * (1.0 - self.ema_alpha) + self.ema_alpha * 1.0

        # Update recent ring
        if self.ring_max > 0 and key not in self.recent_set:
            self.recent_set.add(key)
            self.recent_ring.append(key)
            while len(self.recent_ring) > self.ring_max:
                old = self.recent_ring.popleft()
                self.recent_set.discard(old)

        # Update scan detector: count consecutive misses
        self.miss_streak += 1
        if self.miss_streak > (self.capacity or 1):
            # Enter/extend scan-biased cooldown
            self.scan_cooldown = max(self.scan_cooldown, self.capacity or 1)
        else:
            # Gradually cool down if not clearly scanning
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, TinyLFU-gated move of W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                cand_m1, f_m1, _ = self._sample_cold_candidate(self.M1, now)
                f_w = self.sketch.estimate(w_lru)
                # Recent-phase boost
                if w_lru in self.recent_set:
                    f_w += 1
                em_high = self.ema_miss > 0.8
                bias = 3 if (self.scan_cooldown > 0 or em_high) else 1
                # Admit into M1 only if at least as hot as a cold M1 candidate (with bias)
                if f_w >= (f_m1 or 0) + bias:
                    self.W.pop(w_lru, None)
                    self._touch(self.M1, w_lru)
                else:
                    # Keep at LRU to be evicted first; avoid refreshing to MRU under scans
                    if not em_high:
                        pass  # leave as LRU without touching

        # Keep protected region within target (decayed-aware demotion)
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.demo_cnt += 1

        # Periodically tune window size
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_evict(self, cache_snapshot, obj, evicted_obj):
        """
        Eviction post-processing:
        - Remove evicted key from whichever segment it resides in and purge LRFU meta.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        k = evicted_obj.key
        self.W.pop(k, None)
        self.M1.pop(k, None)
        self.M2.pop(k, None)
        self.score.pop(k, None)
        self.last_time.pop(k, None)
=======
    def on_evict(self, cache_snapshot, obj, evicted_obj):
        """
        Eviction post-processing:
        - Remove evicted key from whichever segment it resides in and purge LRFU meta.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        k = evicted_obj.key
        self.W.pop(k, None)
        self.M1.pop(k, None)
        self.M2.pop(k, None)
        self.score.pop(k, None)
        self.last_time.pop(k, None)
        # Cleanup recent ring
        if k in self.recent_set:
            self.recent_set.discard(k)
            try:
                self.recent_ring.remove(k)
            except ValueError:
                pass
>>>>>>> REPLACE

</DIFF>