<NAME>
wtinylfu_adaptive_window_m2_sampling
</NAME>

<DESCRIPTION>
I improved the W-TinyLFU policy by:
- Making the admission decision in evict always compare new frequency against a main (M1) candidate, even when the window is at target, and falling back to M2 comparison when M1 is empty. This avoids over-biasing toward evicting from the window and reduces pollution.
- Introducing a lightweight adaptive tuner to adjust the window size (win_frac) based on a decayed ratio of hits in the window vs main. This helps handle scans (shrink window) and bursty recency (grow window) without heavy ghost lists.
- Adding conservative early promotion from window to protected (M2) for keys with sufficiently high TinyLFU estimate, so hot items are shielded more quickly.
- Using TinyLFU-guided sampling when demoting from M2, replacing plain LRU demotion, which better preserves frequently reused items.

These changes strengthen admission and replacement decisions, maintain protected space quality, and adapt to workload phases, which should reduce miss rates across diverse traces.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k"
    )
=======
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period"
    )
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
=======
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.last_tune_time = 0
        self.tune_period = 0
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _ensure_capacity(self, cap: int):
        if self.capacity is None:
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            # Age faster for smaller caches
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
            return
        if self.capacity != cap:
            # Reset segments if external capacity changes to avoid desync.
            self.W.clear(); self.M1.clear(); self.M2.clear()
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
=======
    def _ensure_capacity(self, cap: int):
        if self.capacity is None:
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            # Age faster for smaller caches
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
            # Set adaptive tuning period relative to capacity
            self.tune_period = max(256, self.capacity * 4)
            self.last_tune_time = 0
            return
        if self.capacity != cap:
            # Reset segments if external capacity changes to avoid desync.
            self.W.clear(); self.M1.clear(); self.M2.clear()
            self.capacity = max(int(cap), 1)
            self._sample_k = max(4, min(12, (self.capacity // 8) or 4))
            try:
                self.sketch.age_period = max(512, min(16384, self.capacity * 8))
            except Exception:
                pass
            self.tune_period = max(256, self.capacity * 4)
            self.last_tune_time = 0
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _self_heal(self, cache_snapshot):
        # Ensure all cached keys are tracked and no phantom entries remain.
        cache_keys = set(cache_snapshot.cache.keys())
        for od in (self.W, self.M1, self.M2):
            for k in list(od.keys()):
                if k not in cache_keys:
                    od.pop(k, None)
        tracked = set(self.W.keys()) | set(self.M1.keys()) | set(self.M2.keys())
        missing = cache_keys - tracked
        if missing:
            w_tgt, _, _ = self._targets()
            # Place missing into W until target, then into M1
            for k in missing:
                if len(self.W) < w_tgt:
                    self.W[k] = None
                else:
                    self.M1[k] = None

    def _lru(self, od: OrderedDict):
        return next(iter(od)) if od else None
=======
    def _self_heal(self, cache_snapshot):
        # Ensure all cached keys are tracked and no phantom entries remain.
        cache_keys = set(cache_snapshot.cache.keys())
        for od in (self.W, self.M1, self.M2):
            for k in list(od.keys()):
                if k not in cache_keys:
                    od.pop(k, None)
        tracked = set(self.W.keys()) | set(self.M1.keys()) | set(self.M2.keys())
        missing = cache_keys - tracked
        if missing:
            w_tgt, _, _ = self._targets()
            # Place missing into W until target, then into M1
            for k in missing:
                if len(self.W) < w_tgt:
                    self.W[k] = None
                else:
                    self.M1[k] = None

    def _maybe_tune(self, now: int):
        # Periodically adapt window size based on relative hits.
        if self.tune_period <= 0:
            return
        if (now - self.last_tune_time) >= self.tune_period:
            # If window is relatively more useful, grow it; otherwise shrink.
            if self.hits_w > self.hits_main * 1.1:
                self.win_frac = min(0.5, self.win_frac + 0.05)
            elif self.hits_main > self.hits_w * 1.1:
                self.win_frac = max(0.05, self.win_frac - 0.05)
            # Decay counters and update tune timestamp
            self.hits_w >>= 1
            self.hits_main >>= 1
            self.last_tune_time = now

    def _lru(self, od: OrderedDict):
        return next(iter(od)) if od else None
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        W-TinyLFU eviction:
        - Prefer evicting from window W if W is at/over target (recency buffer).
        - Else, compare f(new) to a sampled low-frequency candidate from M1:
          * If f(new) > f(cand_M1): evict cand_M1 (admit new to W, later move from W to M1).
          * Else: evict W's LRU (bias recency).
        - Robust fallbacks if some segments are empty.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        w_tgt, _, _ = self._targets()

        # If window is already at or above target, free space by evicting window LRU
        if len(self.W) >= w_tgt and self.W:
            return self._lru(self.W)

        # Evaluate admission vs M1 victim
        cand_m1 = self._sample_lru_min_freq(self.M1)
        f_new = self.sketch.estimate(new_obj.key)
        f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1  # treat empty M1 as very cold

        if cand_m1 is not None and f_new > f_m1:
            return cand_m1

        # Otherwise evict from window if possible to preserve main
        if self.W:
            return self._lru(self.W)

        # Fallbacks: evict from M1 else M2
        if self.M1:
            return self._sample_lru_min_freq(self.M1) or self._lru(self.M1)
        if self.M2:
            return self._lru(self.M2)

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        W-TinyLFU eviction:
        - Compare f(new) to a sampled low-frequency candidate from M1.
          * If f(new) > f(cand_M1): evict cand_M1 (admit new to W).
          * Else: evict W's LRU (reject new from main).
        - If M1 is empty, fall back to comparing against M2; else use window LRU.
        - Robust fallbacks if some segments are empty.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        # Candidates
        cand_w = self._lru(self.W)
        cand_m1 = self._sample_lru_min_freq(self.M1)
        cand_m2 = self._sample_lru_min_freq(self.M2) if cand_m1 is None else None

        f_new = self.sketch.estimate(new_obj.key)
        f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
        f_m2 = self.sketch.estimate(cand_m2) if cand_m2 is not None else -1

        # Prefer replacing a cold M1 entry if new is hotter
        if cand_m1 is not None and f_new > f_m1:
            return cand_m1

        # Otherwise evict from the window to preserve main
        if cand_w is not None:
            return cand_w

        # If no window, consider replacing a cold protected entry if new is hotter
        if cand_m2 is not None and f_new > f_m2:
            return cand_m2

        # Fallbacks
        if self.M1:
            return self._lru(self.M1)
        if self.M2:
            return self._lru(self.M2)

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU.
        - W hit: refresh in W.
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as hot and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        key = obj.key
        self.sketch.increment(key, 1)

        if key in self.W:
            self._touch(self.W, key)
            return

        if key in self.M1:
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            # Rebalance protected size if needed
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                # Demote protected LRU to probationary
                demote = self._lru(self.M2)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
            return

        if key in self.M2:
            self._touch(self.M2, key)
            return

        # Desync: assume it's warm
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote = self._lru(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
=======
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU.
        - W hit: refresh or conservatively promote if sufficiently hot.
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strongly frequent to avoid window churn
            est = self.sketch.estimate(key)
            if est >= 3:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                # Keep protected region within target using frequency-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote = self._sample_lru_min_freq(self.M2)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            # Rebalance protected size if needed (freq-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote = self._sample_lru_min_freq(self.M2)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - If W exceeds target, move W's LRU to main probationary (M1).
        - Keep protected region within target by demoting its LRU to M1 if needed.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        key = obj.key
        self.sketch.increment(key, 1)

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, move W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                self.W.pop(w_lru, None)
                # Move into M1 probationary
                self._touch(self.M1, w_lru)

        # Keep protected region within target
        if len(self.M2) > prot_tgt:
            demote = self._lru(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
=======
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - If W exceeds target, move W's LRU to main probationary (M1).
        - Keep protected region within target by demoting its LRU to M1 if needed.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, move W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                self.W.pop(w_lru, None)
                # Move into M1 probationary
                self._touch(self.M1, w_lru)

        # Keep protected region within target (freq-aware demotion)
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)

        # Periodically tune window size
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>