<NAME>
splitwin_tlfu_tail_sampling_promo
</NAME>

<DESCRIPTION>
I propose three targeted improvements to reduce miss rate by better aligning admission and eviction with item hotness while improving scan resistance:

1) Randomized tail sampling for candidate selection: Replace deterministic “first k LRU” sampling with randomized sampling from the LRU tail (first 4k items). This reduces bias and improves the chance of evicting truly cold items when the LRU tail contains mixtures of recency and coldness.

2) Early direct promotion from the window probationary (W1) to main protected (M2) on W1 hits if the TinyLFU estimate is high, bypassing W2. This prevents hot items from churning in the window and accelerates them into the protected main segment, improving hit rates in repeated-use workloads.

3) Scan-aware tweaks: Use a lower, capacity-aware threshold for scan detection (half capacity with a floor of 16) and a proportional cooldown. Also, allow high-TinyLFU new items to bypass W1 straight to M1 on insert (gated by TinyLFU comparison) and prefer evicting W2 before main in fallbacks. These changes more quickly engage scan protection and keep main segments from being polluted during scans.

Together, these adjustments strengthen frequency-oriented decisions, reduce window churn, and protect main cache content from scans, which should improve overall hit rates across diverse traces.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def _sample_lru_min_freq(self, od: OrderedDict) -> str:
        if not od:
            return None
        k = min(self._sample_k, len(od))
        it = iter(od.keys())  # from LRU to MRU
        min_key, min_f = None, None
        for _ in range(k):
            key = next(it)
            f = self.sketch.estimate(key)
            if min_f is None or f < min_f:
                min_f, min_key = f, key
        return min_key if min_key is not None else self._lru(od)
=======
    def _sample_lru_min_freq(self, od: OrderedDict) -> str:
        if not od:
            return None
        # Randomized sampling from the LRU tail to reduce deterministic bias.
        import random
        k = min(self._sample_k, len(od))
        tail_len = min(len(od), self._sample_k * 4)
        keys_tail = list(od.keys())[:tail_len]  # LRU-most region
        if tail_len <= k:
            candidates = keys_tail
        else:
            # Sample without replacement from the tail region
            candidates = random.sample(keys_tail, k)
        min_key, min_f = None, None
        for key in candidates:
            f = self.sketch.estimate(key)
            if min_f is None or f < min_f:
                min_f, min_key = f, key
        return min_key if min_key is not None else self._lru(od)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Competitive, scan-aware choice:
        - Prefer evicting a cold M1 entry if new is clearly hotter (TinyLFU + bias).
        - Else evict from W1 (window probationary) to protect main and W2.
        - Else consider replacing a cold M2 if new is much hotter.
        - Robust fallbacks maintain progress.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        # Cool down scan bias slightly on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        # Candidates
        cand_w1 = self._lru(self.W1)
        cand_m1 = self._sample_lru_min_freq(self.M1)
        cand_m2 = self._sample_lru_min_freq(self.M2) if cand_m1 is None else None

        f_new = self.sketch.estimate(new_obj.key)
        f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
        f_m2 = self.sketch.estimate(cand_m2) if cand_m2 is not None else -1

        bias = 3 if self.scan_cooldown > 0 else 1

        # Replace a cold probationary main entry if new is clearly hotter
        if cand_m1 is not None and f_new > (f_m1 + bias):
            return cand_m1

        # Otherwise, evict from window probationary (W1) first
        if cand_w1 is not None:
            return cand_w1

        # If window probationary empty, consider replacing a cold protected main
        if cand_m2 is not None and f_new > (f_m2 + bias + 1):
            return cand_m2

        # Fallbacks
        if self.M1:
            return self._lru(self.M1)
        if self.M2:
            return self._lru(self.M2)
        if self.W2:
            return self._lru(self.W2)
        # Last resort: any key present
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Competitive, scan-aware choice:
        - Prefer evicting a cold M1 entry if new is clearly hotter (TinyLFU + bias).
        - Else evict from W1 (window probationary) to protect main and W2.
        - Else consider replacing a cold M2 if new is much hotter.
        - Robust fallbacks maintain progress with preference to evict from window before main.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        # Cool down scan bias slightly on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        # Candidates
        cand_w1 = self._lru(self.W1)
        cand_w2 = self._lru(self.W2)
        cand_m1 = self._sample_lru_min_freq(self.M1)
        cand_m2 = self._sample_lru_min_freq(self.M2) if cand_m1 is None else None

        f_new = self.sketch.estimate(new_obj.key)
        f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
        f_m2 = self.sketch.estimate(cand_m2) if cand_m2 is not None else -1

        bias = 3 if self.scan_cooldown > 0 else 1

        # Replace a cold probationary main entry if new is clearly hotter
        if cand_m1 is not None and f_new > (f_m1 + bias):
            return cand_m1

        # Otherwise, evict from window probationary (W1) first
        if cand_w1 is not None:
            return cand_w1

        # If window probationary empty, consider replacing a cold protected main
        if cand_m2 is not None and f_new > (f_m2 + bias + 1):
            return cand_m2

        # Fallbacks: prefer evicting from window protected (W2) before main
        if self.W2:
            return self._lru(self.W2)
        if self.M1:
            return self._lru(self.M1)
        if self.M2:
            return self._lru(self.M2)
        # Last resort: any key present
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing with split window and main SLRU:
        - W1 hit: promote to W2 (protected).
        - W2 hit: refresh W2.
        - M1 hit: promote to M2 (protected).
        - M2 hit: refresh M2.
        - Desync hit: treat as warm, place in M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Any hit resets miss streak and cools down scan bias
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, w2_tgt, _, prot_tgt = self._targets()

        if key in self.W1:
            self.hits_w += 1
            # Promote to window protected
            self.W1.pop(key, None)
            self._touch(self.W2, key)
            self.hits_w2 += 1
            # Keep W2 within target using simple demotion back to W1
            if len(self.W2) > w2_tgt:
                demote = self._lru(self.W2)
                if demote is not None:
                    self.W2.pop(demote, None)
                    self._touch(self.W1, demote)
            self._maybe_tune(now)
            return

        if key in self.W2:
            self.hits_w += 1
            self.hits_w2 += 1
            self._touch(self.W2, key)
            # If W2 grew past target (could happen due to prior changes), demote LRU to W1
            if len(self.W2) > w2_tgt:
                demote = self._lru(self.W2)
                if demote is not None:
                    self.W2.pop(demote, None)
                    self._touch(self.W1, demote)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to main protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            self.prom_m2 += 1
            # Keep M2 within target by demoting low-freq from M2 to M1
            if len(self.M2) > prot_tgt:
                demote = self._sample_lru_min_freq(self.M2)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
                    self.dem_m2 += 1
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm and place into M2
        self.hits_main += 1
        self._touch(self.M2, key)
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.dem_m2 += 1
        self._maybe_tune(now)
=======
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing with split window and main SLRU:
        - W1 hit: promote to W2, or directly to M2 if TinyLFU estimate is high.
        - W2 hit: refresh W2.
        - M1 hit: promote to M2 (protected).
        - M2 hit: refresh M2.
        - Desync hit: treat as warm, place in M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Any hit resets miss streak and cools down scan bias
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, w2_tgt, _, prot_tgt = self._targets()

        if key in self.W1:
            self.hits_w += 1
            # Directly promote to main protected if sufficiently hot
            est = self.sketch.estimate(key)
            thr_hi = 4 if self.scan_cooldown > 0 else 3
            if est >= thr_hi:
                self.W1.pop(key, None)
                self._touch(self.M2, key)
                self.hits_main += 1
                self.prom_m2 += 1
                # Keep M2 within target by demoting a low-freq entry to M1
                if len(self.M2) > prot_tgt:
                    demote = self._sample_lru_min_freq(self.M2)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
                        self.dem_m2 += 1
            else:
                # Otherwise promote to window protected
                self.W1.pop(key, None)
                self._touch(self.W2, key)
                self.hits_w2 += 1
                if len(self.W2) > w2_tgt:
                    demote = self._lru(self.W2)
                    if demote is not None:
                        self.W2.pop(demote, None)
                        self._touch(self.W1, demote)
            self._maybe_tune(now)
            return

        if key in self.W2:
            self.hits_w += 1
            self.hits_w2 += 1
            self._touch(self.W2, key)
            # If W2 grew past target (could happen due to prior changes), demote LRU to W1
            if len(self.W2) > w2_tgt:
                demote = self._lru(self.W2)
                if demote is not None:
                    self.W2.pop(demote, None)
                    self._touch(self.W1, demote)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to main protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            self.prom_m2 += 1
            # Keep M2 within target by demoting low-freq from M2 to M1
            if len(self.M2) > prot_tgt:
                demote = self._sample_lru_min_freq(self.M2)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
                    self.dem_m2 += 1
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm and place into M2
        self.hits_main += 1
        self._touch(self.M2, key)
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.dem_m2 += 1
        self._maybe_tune(now)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Insert new key into W1 (window probationary).
        - If window exceeds target, consider moving W1's LRU to M1 via TinyLFU-gated admission.
        - Maintain W2 within its target (demote W2 LRU back to W1 if needed).
        - Maintain M2 within its target (demote low-freq M2 to M1).
        - Update scan detector.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update scan detector for consecutive misses
        self.miss_streak += 1
        if self.miss_streak > (self.capacity or 1):
            self.scan_cooldown = max(self.scan_cooldown, self.capacity or 1)
        else:
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere (idempotent)
        self.W1.pop(key, None)
        self.W2.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into W1 (probationary)
        self._touch(self.W1, key)

        # Rebalance window size vs target
        w_tgt, w2_tgt, _, prot_tgt = self._targets()
        # If window exceeds target, consider moving W1's LRU to M1 using TinyLFU comparison
        if (len(self.W1) + len(self.W2)) > w_tgt:
            w1_lru = self._lru(self.W1)
            if w1_lru is not None and w1_lru != key:
                cand_m1 = self._sample_lru_min_freq(self.M1)
                f_w1 = self.sketch.estimate(w1_lru)
                f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
                bias = 3 if self.scan_cooldown > 0 else 1
                if f_w1 >= (f_m1 + bias):
                    # Admit into probationary main
                    self.W1.pop(w1_lru, None)
                    self._touch(self.M1, w1_lru)
                else:
                    # Keep in window; refresh to avoid immediate churn
                    self._touch(self.W1, w1_lru)
            else:
                # If W1 empty (rare), demote W2 LRU back to W1
                w2_lru = self._lru(self.W2)
                if w2_lru is not None:
                    self.W2.pop(w2_lru, None)
                    self._touch(self.W1, w2_lru)

        # Keep W2 within its target size by demoting its LRU to W1
        if len(self.W2) > w2_tgt:
            demote_w2 = self._lru(self.W2)
            if demote_w2 is not None:
                self.W2.pop(demote_w2, None)
                self._touch(self.W1, demote_w2)

        # Keep M2 within target (freq-aware demotion)
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.dem_m2 += 1

        # Periodically tune parameters
        self._maybe_tune(now)
=======
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Insert new key into W1 (window probationary).
        - If window exceeds target, consider moving W1's LRU to M1 via TinyLFU-gated admission.
        - Maintain W2 within its target (demote W2 LRU back to W1 if needed).
        - Maintain M2 within its target (demote low-freq M2 to M1).
        - Update scan detector.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update scan detector for consecutive misses with capacity-aware threshold
        self.miss_streak += 1
        thr = max(16, (self.capacity or 1) // 2)
        if self.miss_streak > thr:
            self.scan_cooldown = max(self.scan_cooldown, thr)
        else:
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere (idempotent)
        self.W1.pop(key, None)
        self.W2.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into W1 (probationary)
        self._touch(self.W1, key)

        # Early bypass: if new is already hot by TinyLFU, admit to M1 directly (gated)
        cand_m1_early = self._sample_lru_min_freq(self.M1)
        f_new = self.sketch.estimate(key)
        f_m1_early = self.sketch.estimate(cand_m1_early) if cand_m1_early is not None else -1
        bias_early = 3 if self.scan_cooldown > 0 else 1
        thr_hi = 4 if self.scan_cooldown > 0 else 3
        if f_new >= thr_hi and f_new >= (f_m1_early + bias_early):
            self.W1.pop(key, None)
            self._touch(self.M1, key)

        # Rebalance window size vs target
        w_tgt, w2_tgt, _, prot_tgt = self._targets()
        # If window exceeds target, consider moving W1's LRU to M1 using TinyLFU comparison
        if (len(self.W1) + len(self.W2)) > w_tgt:
            w1_lru = self._lru(self.W1)
            if w1_lru is not None and w1_lru != key:
                cand_m1 = self._sample_lru_min_freq(self.M1)
                f_w1 = self.sketch.estimate(w1_lru)
                f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
                bias = 3 if self.scan_cooldown > 0 else 1
                if f_w1 >= (f_m1 + bias):
                    # Admit into probationary main
                    self.W1.pop(w1_lru, None)
                    self._touch(self.M1, w1_lru)
                else:
                    # Keep in window; refresh to avoid immediate churn
                    self._touch(self.W1, w1_lru)
            else:
                # If W1 empty (rare), demote W2 LRU back to W1
                w2_lru = self._lru(self.W2)
                if w2_lru is not None:
                    self.W2.pop(w2_lru, None)
                    self._touch(self.W1, w2_lru)

        # Keep W2 within its target size by demoting its LRU to W1
        if len(self.W2) > w2_tgt:
            demote_w2 = self._lru(self.W2)
            if demote_w2 is not None:
                self.W2.pop(demote_w2, None)
                self._touch(self.W1, demote_w2)

        # Keep M2 within target (freq-aware demotion)
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.dem_m2 += 1

        # Periodically tune parameters
        self._maybe_tune(now)
>>>>>>> REPLACE
</DIFF>