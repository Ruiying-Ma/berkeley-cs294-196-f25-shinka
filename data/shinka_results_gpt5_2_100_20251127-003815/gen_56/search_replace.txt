<NAME>
slru_adaptive_protection_and_random_tail_sampling
</NAME>

<DESCRIPTION>
I introduce two complementary improvements to the existing W-TinyLFU + SLRU policy that reduce miss rates across diverse workloads:

1) Randomized tail sampling in victim selection: Instead of sampling strictly the k oldest keys, we sample from a randomized window of the LRU tail (up to 4k oldest), then pick the coldest by (TinyLFU estimate, decayed LRFU score). This avoids deterministic tail bias and better surfaces stale entries in rapidly changing phases.

2) Adaptive protected fraction (prot_frac) tuning with scan awareness: We track promotions from M1/W to M2 and demotions from M2, as well as the share of M2 hits. Periodically, we increase or decrease prot_frac within [0.60, 0.90] based on these signals. During scan cooldown, we temporarily bias towards smaller protected to curb pollution. Additionally, we adapt TinyLFUâ€™s aging period and LRFU half-life based on whether the window or main is more effective, improving responsiveness to phase shifts.

I also count M2 hits, promotions, and demotions in on_hit and on_insert events. The evict logic is refined to always compete the incoming item against sampled candidates in both M1 and M2 with the correct biases, and to choose between window and main candidates lexicographically by coldness. These changes maintain compatibility with the existing structure while improving robustness to scans and phase changes.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from collections import OrderedDict
=======
from collections import OrderedDict
import random
from itertools import islice
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "score", "last_time", "decay_base", "decay_half_life",
        "miss_streak", "scan_cooldown"
    )
=======
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "score", "last_time", "decay_base", "decay_half_life",
        "miss_streak", "scan_cooldown",
        "prom_cnt", "demo_cnt", "hits_m2"
    )
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.last_tune_time = 0
        self.tune_period = 0
        # LRFU decayed score state
        self.score = {}     # key -> float decayed score
        self.last_time = {} # key -> last access_count
        self.decay_half_life = 16
        self.decay_base = 2 ** (-1.0 / self.decay_half_life)
        # Scan detection state
        self.miss_streak = 0
        self.scan_cooldown = 0
=======
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.hits_m2 = 0
        self.last_tune_time = 0
        self.tune_period = 0
        self.prom_cnt = 0
        self.demo_cnt = 0
        # LRFU decayed score state
        self.score = {}     # key -> float decayed score
        self.last_time = {} # key -> last access_count
        self.decay_half_life = 16
        self.decay_base = 2 ** (-1.0 / self.decay_half_life)
        # Scan detection state
        self.miss_streak = 0
        self.scan_cooldown = 0
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _sample_cold_candidate(self, od: OrderedDict, now: int):
        """
        Return (key, tiny_est, decayed) for the coldest among the k LRU keys,
        using lexicographic min on (tiny_est, decayed_score).
        """
        if not od:
            return None, None, None
        k = min(self._sample_k, len(od))
        it = iter(od.keys())  # from LRU to MRU
        best_k, best_est, best_dec = None, None, None
        for _ in range(k):
            key = next(it)
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            if (best_est is None
                or est < best_est
                or (est == best_est and dec < best_dec)):
                best_k, best_est, best_dec = key, est, dec
        return best_k, best_est, best_dec
=======
    def _sample_cold_candidate(self, od: OrderedDict, now: int):
        """
        Return (key, tiny_est, decayed) for the coldest among a randomized slice
        of the LRU tail. We sample k keys from a window of size up to 4k oldest
        entries to avoid deterministic tail bias.
        """
        if not od:
            return None, None, None
        n = len(od)
        k = min(self._sample_k, n)
        span = min(n, self._sample_k * 4)
        start = 0
        if span > k:
            start = random.randrange(0, span - k + 1)
        # Collect a slice of the LRU tail and evaluate first k within it
        keys_slice = list(islice(od.keys(), start, start + span))
        best_k, best_est, best_dec = None, None, None
        for key in islice(keys_slice, 0, k):
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            if (best_est is None
                or est < best_est
                or (est == best_est and dec < best_dec)):
                best_k, best_est, best_dec = key, est, dec
        return best_k, best_est, best_dec
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _maybe_tune(self, now: int):
        # Periodically adapt window size based on relative hits.
        if self.tune_period <= 0:
            return
        if (now - self.last_tune_time) >= self.tune_period:
            # If window is relatively more useful, grow it; otherwise shrink.
            if self.hits_w > self.hits_main * 1.1:
                self.win_frac = min(0.5, self.win_frac + 0.05)
            elif self.hits_main > self.hits_w * 1.1:
                self.win_frac = max(0.05, self.win_frac - 0.05)
            # Decay counters and update tune timestamp
            self.hits_w >>= 1
            self.hits_main >>= 1
            self.last_tune_time = now
=======
    def _maybe_tune(self, now: int):
        # Periodically adapt window/protected sizes and decay parameters.
        if self.tune_period <= 0:
            return
        if (now - self.last_tune_time) >= self.tune_period:
            # Window sizing based on hit share
            if self.hits_w > self.hits_main * 1.1:
                self.win_frac = min(0.5, self.win_frac + 0.05)
            elif self.hits_main > self.hits_w * 1.1:
                self.win_frac = max(0.05, self.win_frac - 0.05)

            # Protected fraction tuning using promotions/demotions and hit share
            total_main_hits = max(1, self.hits_main)
            m2_share = (self.hits_m2 / float(total_main_hits)) if total_main_hits > 0 else 0.0
            if self.prom_cnt < self.demo_cnt * 0.8 or self.hits_w > self.hits_main * 1.2:
                self.prot_frac = max(0.60, self.prot_frac - 0.05)
            elif m2_share > 0.7 and self.prom_cnt >= self.demo_cnt:
                self.prot_frac = min(0.90, self.prot_frac + 0.05)
            if self.scan_cooldown > 0:
                self.prot_frac = max(0.60, self.prot_frac - 0.05)

            # Adapt LRFU half-life and TinyLFU aging to phase
            cap = self.capacity or 1
            if self.hits_w >= self.hits_main:
                self.decay_half_life = max(8, self.decay_half_life - 4)
                try:
                    self.sketch.age_period = max(4 * cap, min(16 * cap, 6 * cap))
                except Exception:
                    pass
            else:
                self.decay_half_life = min(64, self.decay_half_life + 4)
                try:
                    self.sketch.age_period = max(4 * cap, min(16 * cap, 12 * cap))
                except Exception:
                    pass
            self.decay_base = 2 ** (-1.0 / float(self.decay_half_life))

            # Decay counters and reset period stats
            self.hits_w >>= 1
            self.hits_main >>= 1
            self.hits_m2 >>= 1
            self.prom_cnt = 0
            self.demo_cnt = 0
            self.last_tune_time = now
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Hybrid eviction with scan-aware bias and window sizing:
        - Maintain window near its target: evict from W if it's above target; if below, prefer evicting from M1.
        - TinyLFU admission: compare f(new) to a sampled cold candidate from M1.
          * If f(new) >= f(cand_M1) + bias: evict cand_M1 (admit new).
          * Else: evict W's LRU (reject new from main this round).
        - If M1 is empty, compare against a cold candidate from M2 with stronger bias.
        - Demotions/victim choices within segments rely on decayed scores.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Cool down scan bias gradually on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, _, _ = self._targets()

        # Candidates from segments
        cand_w = self._lru(self.W)
        cand_m1, f_m1, dec_m1 = self._sample_cold_candidate(self.M1, now)
        cand_m2, f_m2, dec_m2 = (None, None, None)
        if cand_m1 is None:
            cand_m2, f_m2, dec_m2 = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)
        bias = 2 if self.scan_cooldown > 0 else 1

        # Keep window near its target
        if len(self.W) > w_tgt and cand_w is not None:
            return cand_w
        if len(self.W) < w_tgt and cand_m1 is not None:
            return cand_m1

        # Admission-vs-eviction: if new is hotter than a cold M1 entry, replace that M1 entry.
        if cand_m1 is not None and f_new >= (f_m1 or 0) + bias:
            return cand_m1

        # Otherwise, prefer the colder between window LRU and cold M1 candidate
        if cand_w is not None and cand_m1 is not None:
            est_w = self.sketch.estimate(cand_w)
            dec_w = self._decayed_score(cand_w, now)
            # Choose lexicographically by (est, decayed)
            if est_w < (f_m1 or 0) or (est_w == (f_m1 or 0) and dec_w <= (dec_m1 or 0.0)):
                return cand_w
            else:
                return cand_m1

        # If only window has a candidate, evict from window
        if cand_w is not None:
            return cand_w

        # If no window/M1 option, consider replacing a cold protected entry (with stronger bias)
        if cand_m2 is not None:
            if f_new >= (f_m2 or 0) + (bias + 1):
                return cand_m2
            # Otherwise pick the colder of window (if any) and M2 candidate
            est_w = self.sketch.estimate(cand_w) if cand_w is not None else None
            dec_w = self._decayed_score(cand_w, now) if cand_w is not None else None
            if cand_w is not None and (est_w is not None) and (est_w < (f_m2 or 0) or (est_w == (f_m2 or 0) and dec_w <= (dec_m2 or 0.0))):
                return cand_w
            return cand_m2

        # Fallbacks: evict coldest in M1 else M2 by decayed score
        if self.M1:
            k, _, _ = self._sample_cold_candidate(self.M1, now)
            if k is not None:
                return k
            return self._lru(self.M1)
        if self.M2:
            k, _, _ = self._sample_cold_candidate(self.M2, now)
            if k is not None:
                return k
            return self._lru(self.M2)

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Hybrid eviction with scan-aware bias and window sizing:
        - Keep window near target: evict from W if it's above target; if below, prefer evicting from M1.
        - Competitive admission: compare f(new) against sampled cold candidates from M1 and M2.
        - Use lexicographic coldness (TinyLFU est, decayed score) when comparing across segments and W.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Cool down scan bias gradually on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, _, _ = self._targets()

        # Candidates from segments
        cand_w = self._lru(self.W)
        cand_m1, f_m1, dec_m1 = self._sample_cold_candidate(self.M1, now)
        cand_m2, f_m2, dec_m2 = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)
        bias = 2 if self.scan_cooldown > 0 else 1

        # Keep window near its target
        if len(self.W) > w_tgt and cand_w is not None:
            return cand_w
        if len(self.W) < w_tgt:
            # Pull from main to let window grow
            if cand_m1 is not None:
                return cand_m1
            if cand_m2 is not None:
                return cand_m2

        # Competitive admission with bias toward protecting M2
        if cand_m1 is not None and f_new >= (f_m1 or 0) + bias:
            return cand_m1
        if cand_m2 is not None and f_new >= (f_m2 or 0) + (bias + 1):
            return cand_m2

        # Choose the colder main candidate lexicographically
        main_k, main_f, main_dec = None, None, None
        if cand_m1 is not None and cand_m2 is not None:
            if (f_m1 < (f_m2 or 1 << 30)) or (f_m1 == f_m2 and (dec_m1 or 0.0) <= (dec_m2 or 0.0)):
                main_k, main_f, main_dec = cand_m1, f_m1, dec_m1
            else:
                main_k, main_f, main_dec = cand_m2, f_m2, dec_m2
        elif cand_m1 is not None:
            main_k, main_f, main_dec = cand_m1, f_m1, dec_m1
        elif cand_m2 is not None:
            main_k, main_f, main_dec = cand_m2, f_m2, dec_m2

        # If both window and main have candidates, pick the lexicographically colder
        if cand_w is not None and main_k is not None:
            est_w = self.sketch.estimate(cand_w)
            dec_w = self._decayed_score(cand_w, now)
            if est_w < (main_f or 0) or (est_w == (main_f or 0) and dec_w <= (main_dec or 0.0)):
                return cand_w
            else:
                return main_k

        # If only one side has a candidate
        if cand_w is not None:
            return cand_w
        if main_k is not None:
            return main_k

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU and LRFU-decayed score.
        - W hit: refresh or early promote if sufficiently hot (stricter during scan).
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key

        # Update TinyLFU and LRFU score
        self.sketch.increment(key, 1)
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        # Any hit breaks a miss streak and cools scan bias slightly
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strong frequency to avoid window churn
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            # Lower thresholds to recognize hot items sooner
            thr_est = 3 if self.scan_cooldown > 0 else 2
            thr_dec = 1.5 if self.scan_cooldown > 0 else 1.0
            if est >= thr_est or dec >= thr_dec:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                # Keep protected region within target using decayed-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote, _, _ = self._sample_cold_candidate(self.M2, now)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            # Rebalance protected size if needed (decayed-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote, _, _ = self._sample_cold_candidate(self.M2, now)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
        self._maybe_tune(now)
=======
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU and LRFU-decayed score.
        - W hit: refresh or early promote if sufficiently hot (stricter during scan).
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key

        # Update TinyLFU and LRFU score
        self.sketch.increment(key, 1)
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        # Any hit breaks a miss streak and cools scan bias slightly
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strong frequency to avoid window churn
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            thr_est = 3 if self.scan_cooldown > 0 else 2
            thr_dec = 1.5 if self.scan_cooldown > 0 else 1.0
            if est >= thr_est or dec >= thr_dec:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                self.prom_cnt += 1
                # Keep protected region within target using decayed-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote, _, _ = self._sample_cold_candidate(self.M2, now)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
                        self.demo_cnt += 1
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            self.prom_cnt += 1
            # Rebalance protected size if needed (decayed-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote, _, _ = self._sample_cold_candidate(self.M2, now)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
                    self.demo_cnt += 1
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self.hits_m2 += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self.hits_m2 += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.demo_cnt += 1
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Initialize LRFU metadata modestly (to reduce scan pollution).
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - If W exceeds target, TinyLFU-gated move of W's LRU to M1 (admission path).
        - Keep protected region within target by demoting a decayed-cold entry if needed.
        - Maintain scan detector state.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Initialize decayed metadata
        self.last_time[key] = now
        self.score[key] = 0.5

        # Update scan detector: count consecutive misses
        self.miss_streak += 1
        if self.miss_streak > (self.capacity or 1):
            # Enter/extend scan-biased cooldown
            self.scan_cooldown = max(self.scan_cooldown, self.capacity or 1)
        else:
            # Gradually cool down if not clearly scanning
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, TinyLFU-gated move of W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                cand_m1, f_m1, _ = self._sample_cold_candidate(self.M1, now)
                f_w = self.sketch.estimate(w_lru)
                bias = 2 if self.scan_cooldown > 0 else 1
                # Admit into M1 only if at least as hot as a cold M1 candidate (with bias)
                if f_w >= (f_m1 or 0) + bias:
                    self.W.pop(w_lru, None)
                    self._touch(self.M1, w_lru)
                else:
                    # Keep at LRU to be evicted first; avoid refreshing to MRU
                    pass

        # Keep protected region within target (decayed-aware demotion)
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)

        # Periodically tune window size
        self._maybe_tune(now)
=======
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Initialize LRFU metadata modestly (to reduce scan pollution).
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - If W exceeds target, TinyLFU-gated move of W's LRU to M1 (admission path).
        - Keep protected region within target by demoting a decayed-cold entry if needed.
        - Maintain scan detector state.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Initialize decayed metadata
        self.last_time[key] = now
        self.score[key] = 0.5

        # Update scan detector: count consecutive misses
        self.miss_streak += 1
        if self.miss_streak > (self.capacity or 1):
            # Enter/extend scan-biased cooldown
            self.scan_cooldown = max(self.scan_cooldown, self.capacity or 1)
        else:
            # Gradually cool down if not clearly scanning
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, TinyLFU-gated move of W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                cand_m1, f_m1, _ = self._sample_cold_candidate(self.M1, now)
                f_w = self.sketch.estimate(w_lru)
                bias = 2 if self.scan_cooldown > 0 else 1
                # Admit into M1 only if at least as hot as a cold M1 candidate (with bias)
                if f_w >= (f_m1 or 0) + bias:
                    self.W.pop(w_lru, None)
                    self._touch(self.M1, w_lru)
                else:
                    # Keep at LRU to be evicted first; avoid refreshing to MRU
                    pass

        # Keep protected region within target (decayed-aware demotion)
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.demo_cnt += 1

        # Periodically tune window size
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>