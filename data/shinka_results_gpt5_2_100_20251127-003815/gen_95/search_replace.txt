<NAME>
dual_main_sampling_lasttouch
</NAME>

<DESCRIPTION>
I introduce two targeted improvements inspired by modern cache policies (TinyLFU/W-TinyLFU + SLRU/ARC hybrids) to lower miss rate:

1) Dual-main competitive admission with protection bias:
   - Instead of only comparing against M1 or using M2 only when M1 is empty, I always sample cold candidates from both M1 and M2, adding a +1 bias to M2. The incoming object's TinyLFU estimate competes against the colder of these two. This preserves M2 better while allowing truly hot new items to replace cold main entries. The scan-aware bias is retained to be stricter during scans.

2) Lightweight last-touch tie-breaker in sampling:
   - I add a last_touch timestamp (using access_count) updated on every touch and use it as a secondary lexicographic tie-breaker in the LRU-tail sampling: minimize (frequency, last_touch). This makes candidate selection more robust in workloads where frequency ties occur but recency differs, improving eviction decisions and demotions.

Additional refinements:
- All touches now record last_touch.
- Frequency-aware demotions for W2 (window protected) use the same sampled tail selection instead of strict LRU.
- Early-bypass and window-overflow admissions compare new vs the colder of M1/M2 (with M2 +1 protection) to reduce polluting main during churn and capture strong emerging hot items.
- on_evict removes last_touch to avoid stale metadata.

These changes are localized and consistent with existing design, improving adaptability across mixed workloads (bursty, recency-heavy, and frequency-heavy) without altering the external API.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    __slots__ = (
        "W1", "W2", "M1", "M2", "capacity",
        "win_frac", "w2_frac", "prot_frac",
        "sketch", "_sample_k",
        "hits_w", "hits_main", "hits_w2",
        "prom_m2", "dem_m2",
        "last_tune_time", "tune_period",
        "miss_streak", "scan_cooldown"
    )
=======
    __slots__ = (
        "W1", "W2", "M1", "M2", "capacity",
        "win_frac", "w2_frac", "prot_frac",
        "sketch", "_sample_k", "last_touch",
        "hits_w", "hits_main", "hits_w2",
        "prom_m2", "dem_m2",
        "last_tune_time", "tune_period",
        "miss_streak", "scan_cooldown"
    )
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        # TinyLFU sketch
        self.sketch = _CmSketch(width_power=12, d=4)
        self._sample_k = 6
        # Adaptive state
=======
        # TinyLFU sketch
        self.sketch = _CmSketch(width_power=12, d=4)
        self._sample_k = 6
        # Last-touch timestamps for lexicographic sampling tie-breakers
        self.last_touch = {}
        # Adaptive state
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _touch(self, od: OrderedDict, key: str):
        od[key] = None
        od.move_to_end(key)
=======
    def _touch(self, od: OrderedDict, key: str, now: int = None):
        od[key] = None
        od.move_to_end(key)
        if now is not None:
            self.last_touch[key] = now
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _sample_lru_min_freq(self, od: OrderedDict) -> str:
        if not od:
            return None
        # Randomized sampling from the LRU tail to reduce deterministic bias.
        import random
        k = min(self._sample_k, len(od))
        tail_len = min(len(od), self._sample_k * 4)
        keys_tail = list(od.keys())[:tail_len]  # LRU-most region
        if tail_len <= k:
            candidates = keys_tail
        else:
            # Sample without replacement from the tail region
            candidates = random.sample(keys_tail, k)
        min_key, min_f = None, None
        for key in candidates:
            f = self.sketch.estimate(key)
            if min_f is None or f < min_f:
                min_f, min_key = f, key
        return min_key if min_key is not None else self._lru(od)
=======
    def _sample_lru_min_freq(self, od: OrderedDict) -> str:
        if not od:
            return None
        # Randomized sampling from the LRU tail, pick minimal (frequency, last_touch).
        import random
        k = min(self._sample_k, len(od))
        tail_len = min(len(od), self._sample_k * 4)
        keys_tail = list(od.keys())[:tail_len]  # LRU-most region
        candidates = keys_tail if tail_len <= k else random.sample(keys_tail, k)
        best_key, best_tuple = None, None
        for key in candidates:
            f = self.sketch.estimate(key)
            lt = self.last_touch.get(key, 0)
            t = (f, lt)
            if best_tuple is None or t < best_tuple:
                best_tuple, best_key = t, key
        return best_key if best_key is not None else self._lru(od)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Competitive, scan-aware choice:
        - Prefer evicting a cold M1 entry if new is clearly hotter (TinyLFU + bias).
        - Else evict from W1 (window probationary) to protect main and W2.
        - Else consider replacing a cold M2 if new is much hotter.
        - Robust fallbacks maintain progress with preference to evict from window before main.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        # Cool down scan bias slightly on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        # Candidates
        cand_w1 = self._lru(self.W1)
        cand_w2 = self._lru(self.W2)
        cand_m1 = self._sample_lru_min_freq(self.M1)
        cand_m2 = self._sample_lru_min_freq(self.M2) if cand_m1 is None else None

        f_new = self.sketch.estimate(new_obj.key)
        f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
        f_m2 = self.sketch.estimate(cand_m2) if cand_m2 is not None else -1

        bias = 3 if self.scan_cooldown > 0 else 1

        # Replace a cold probationary main entry if new is clearly hotter
        if cand_m1 is not None and f_new > (f_m1 + bias):
            return cand_m1

        # Otherwise, evict from window probationary (W1) first
        if cand_w1 is not None:
            return cand_w1

        # If window probationary empty, consider replacing a cold protected main
        if cand_m2 is not None and f_new > (f_m2 + bias + 1):
            return cand_m2

        # Fallbacks: prefer evicting from window protected (W2) before main
        if self.W2:
            return self._lru(self.W2)
        if self.M1:
            return self._lru(self.M1)
        if self.M2:
            return self._lru(self.M2)
        # Last resort: any key present
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Dual-main competitive, scan-aware choice:
        - Sample cold candidates from both M1 and M2 tails (M2 protected with +1).
        - If f(new) > min(effective M1/M2) + bias: evict that main candidate.
        - Else evict from W1, then W2; robust fallbacks if empty.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        # Cool down scan bias slightly on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        # Candidates
        cand_w1 = self._lru(self.W1)
        cand_w2 = self._lru(self.W2)
        cand_m1 = self._sample_lru_min_freq(self.M1)
        cand_m2 = self._sample_lru_min_freq(self.M2)

        f_new = self.sketch.estimate(new_obj.key)

        # Compute colder main candidate with M2 bias
        best_cand, best_eff = None, None
        if cand_m1 is not None:
            f1 = self.sketch.estimate(cand_m1)
            best_cand, best_eff = cand_m1, f1
        if cand_m2 is not None:
            f2 = self.sketch.estimate(cand_m2) + 1  # protect M2
            if best_eff is None or f2 < best_eff:
                best_cand, best_eff = cand_m2, f2

        bias = 3 if self.scan_cooldown > 0 else 1

        if best_cand is not None and f_new > (best_eff + bias):
            return best_cand

        # Otherwise, evict from window first
        if cand_w1 is not None:
            return cand_w1
        if cand_w2 is not None:
            return cand_w2

        # Fallbacks
        if self.M1:
            return self._lru(self.M1)
        if self.M2:
            return self._lru(self.M2)
        # Last resort: any key present
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing with split window and main SLRU:
        - W1 hit: promote to W2, or directly to M2 if TinyLFU estimate is high.
        - W2 hit: refresh W2.
        - M1 hit: promote to M2 (protected).
        - M2 hit: refresh M2.
        - Desync hit: treat as warm, place in M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Any hit resets miss streak and cools down scan bias
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, w2_tgt, _, prot_tgt = self._targets()

        if key in self.W1:
            self.hits_w += 1
            # Directly promote to main protected if sufficiently hot
            est = self.sketch.estimate(key)
            thr_hi = 4 if self.scan_cooldown > 0 else 3
            if est >= thr_hi:
                self.W1.pop(key, None)
                self._touch(self.M2, key)
                self.hits_main += 1
                self.prom_m2 += 1
                # Keep M2 within target by demoting a low-freq entry to M1
                if len(self.M2) > prot_tgt:
                    demote = self._sample_lru_min_freq(self.M2)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
                        self.dem_m2 += 1
            else:
                # Otherwise promote to window protected
                self.W1.pop(key, None)
                self._touch(self.W2, key)
                self.hits_w2 += 1
                if len(self.W2) > w2_tgt:
                    demote = self._lru(self.W2)
                    if demote is not None:
                        self.W2.pop(demote, None)
                        self._touch(self.W1, demote)
            self._maybe_tune(now)
            return

        if key in self.W2:
            self.hits_w += 1
            self.hits_w2 += 1
            self._touch(self.W2, key)
            # If W2 grew past target (could happen due to prior changes), demote LRU to W1
            if len(self.W2) > w2_tgt:
                demote = self._lru(self.W2)
                if demote is not None:
                    self.W2.pop(demote, None)
                    self._touch(self.W1, demote)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to main protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            self.prom_m2 += 1
            # Keep M2 within target by demoting low-freq from M2 to M1
            if len(self.M2) > prot_tgt:
                demote = self._sample_lru_min_freq(self.M2)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
                    self.dem_m2 += 1
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm and place into M2
        self.hits_main += 1
        self._touch(self.M2, key)
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.dem_m2 += 1
        self._maybe_tune(now)
=======
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing with split window and main SLRU:
        - W1 hit: promote to W2, or directly to M2 if TinyLFU estimate is high.
        - W2 hit: refresh W2.
        - M1 hit: promote to M2 (protected).
        - M2 hit: refresh M2.
        - Desync hit: treat as warm, place in M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Any hit resets miss streak and cools down scan bias
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, w2_tgt, _, prot_tgt = self._targets()

        if key in self.W1:
            self.hits_w += 1
            # Directly promote to main protected if sufficiently hot
            est = self.sketch.estimate(key)
            thr_hi = 4 if self.scan_cooldown > 0 else 3
            if est >= thr_hi:
                self.W1.pop(key, None)
                self._touch(self.M2, key, now)
                self.hits_main += 1
                self.prom_m2 += 1
                # Keep M2 within target by demoting a low-freq entry to M1
                while len(self.M2) > prot_tgt:
                    demote = self._sample_lru_min_freq(self.M2)
                    if demote is None:
                        break
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote, now)
                    self.dem_m2 += 1
            else:
                # Otherwise promote to window protected
                self.W1.pop(key, None)
                self._touch(self.W2, key, now)
                self.hits_w2 += 1
                # Keep W2 within target using frequency-aware demotion
                while len(self.W2) > w2_tgt:
                    demote = self._sample_lru_min_freq(self.W2)
                    if demote is None:
                        break
                    self.W2.pop(demote, None)
                    self._touch(self.W1, demote, now)
            self._maybe_tune(now)
            return

        if key in self.W2:
            self.hits_w += 1
            self.hits_w2 += 1
            self._touch(self.W2, key, now)
            # If W2 grew past target, demote coldest to W1
            while len(self.W2) > w2_tgt:
                demote = self._sample_lru_min_freq(self.W2)
                if demote is None:
                    break
                self.W2.pop(demote, None)
                self._touch(self.W1, demote, now)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to main protected
            self.M1.pop(key, None)
            self._touch(self.M2, key, now)
            self.prom_m2 += 1
            # Keep M2 within target by demoting low-freq from M2 to M1
            while len(self.M2) > prot_tgt:
                demote = self._sample_lru_min_freq(self.M2)
                if demote is None:
                    break
                self.M2.pop(demote, None)
                self._touch(self.M1, demote, now)
                self.dem_m2 += 1
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key, now)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm and place into M2
        self.hits_main += 1
        self._touch(self.M2, key, now)
        while len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is None:
                break
            self.M2.pop(demote, None)
            self._touch(self.M1, demote, now)
            self.dem_m2 += 1
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Insert new key into W1 (window probationary).
        - If window exceeds target, consider moving W1's LRU to M1 via TinyLFU-gated admission.
        - Maintain W2 within its target (demote W2 LRU back to W1 if needed).
        - Maintain M2 within its target (demote low-freq M2 to M1).
        - Update scan detector.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update scan detector for consecutive misses with capacity-aware threshold
        self.miss_streak += 1
        thr = max(16, (self.capacity or 1) // 2)
        if self.miss_streak > thr:
            self.scan_cooldown = max(self.scan_cooldown, thr)
        else:
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere (idempotent)
        self.W1.pop(key, None)
        self.W2.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into W1 (probationary)
        self._touch(self.W1, key)

        # Early bypass: if new is already hot by TinyLFU, admit to M1 directly (gated)
        cand_m1_early = self._sample_lru_min_freq(self.M1)
        f_new = self.sketch.estimate(key)
        f_m1_early = self.sketch.estimate(cand_m1_early) if cand_m1_early is not None else -1
        bias_early = 3 if self.scan_cooldown > 0 else 1
        thr_hi = 4 if self.scan_cooldown > 0 else 3
        if f_new >= thr_hi and f_new >= (f_m1_early + bias_early):
            self.W1.pop(key, None)
            self._touch(self.M1, key)

        # Rebalance window size vs target
        w_tgt, w2_tgt, _, prot_tgt = self._targets()
        # If window exceeds target, consider moving W1's LRU to M1 using TinyLFU comparison
        if (len(self.W1) + len(self.W2)) > w_tgt:
            w1_lru = self._lru(self.W1)
            if w1_lru is not None and w1_lru != key:
                cand_m1 = self._sample_lru_min_freq(self.M1)
                f_w1 = self.sketch.estimate(w1_lru)
                f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
                bias = 3 if self.scan_cooldown > 0 else 1
                if f_w1 >= (f_m1 + bias):
                    # Admit into probationary main
                    self.W1.pop(w1_lru, None)
                    self._touch(self.M1, w1_lru)
                else:
                    # Keep in window; refresh to avoid immediate churn
                    self._touch(self.W1, w1_lru)
            else:
                # If W1 empty (rare), demote W2 LRU back to W1
                w2_lru = self._lru(self.W2)
                if w2_lru is not None:
                    self.W2.pop(w2_lru, None)
                    self._touch(self.W1, w2_lru)

        # Keep W2 within its target size by demoting its LRU to W1
        if len(self.W2) > w2_tgt:
            demote_w2 = self._lru(self.W2)
            if demote_w2 is not None:
                self.W2.pop(demote_w2, None)
                self._touch(self.W1, demote_w2)

        # Keep M2 within target (freq-aware demotion)
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.dem_m2 += 1

        # Periodically tune parameters
        self._maybe_tune(now)
=======
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Insert new key into W1 (window probationary).
        - Early bypass to M1 when new is clearly hotter than the colder of M1/M2 (M2 +1 bias).
        - If window exceeds target, TinyLFU-gated move of W1's LRU to M1 using dual-main competition.
        - Maintain W2 within its target by frequency-aware demotion to W1.
        - Maintain M2 within its target by frequency-aware demotion to M1.
        - Update scan detector.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update scan detector for consecutive misses with capacity-aware threshold
        self.miss_streak += 1
        thr = max(16, (self.capacity or 1) // 2)
        if self.miss_streak > thr:
            self.scan_cooldown = max(self.scan_cooldown, thr)
        else:
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere (idempotent)
        self.W1.pop(key, None)
        self.W2.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into W1 (probationary)
        self._touch(self.W1, key, now)

        # Early bypass: compare against colder of M1 and M2 (+1 bias)
        cand_m1_early = self._sample_lru_min_freq(self.M1)
        cand_m2_early = self._sample_lru_min_freq(self.M2)
        f_new = self.sketch.estimate(key)
        effs = []
        if cand_m1_early is not None:
            effs.append(self.sketch.estimate(cand_m1_early))
        if cand_m2_early is not None:
            effs.append(self.sketch.estimate(cand_m2_early) + 1)
        comp_eff = min(effs) if effs else -1
        bias_early = 3 if self.scan_cooldown > 0 else 1
        thr_hi = 4 if self.scan_cooldown > 0 else 3
        if f_new >= thr_hi and f_new >= (comp_eff + bias_early):
            self.W1.pop(key, None)
            self._touch(self.M1, key, now)

        # Rebalance window size vs target: dual-main, TinyLFU-gated admission
        w_tgt, w2_tgt, _, prot_tgt = self._targets()
        if (len(self.W1) + len(self.W2)) > w_tgt:
            w1_lru = self._lru(self.W1)
            if w1_lru is not None and w1_lru != key:
                cand_m1 = self._sample_lru_min_freq(self.M1)
                cand_m2 = self._sample_lru_min_freq(self.M2)
                f_w1 = self.sketch.estimate(w1_lru)
                comp_list = []
                if cand_m1 is not None:
                    comp_list.append(self.sketch.estimate(cand_m1))
                if cand_m2 is not None:
                    comp_list.append(self.sketch.estimate(cand_m2) + 1)
                comp_eff = min(comp_list) if comp_list else -1
                bias = 3 if self.scan_cooldown > 0 else 1
                if f_w1 >= (comp_eff + bias):
                    # Admit into probationary main
                    self.W1.pop(w1_lru, None)
                    self._touch(self.M1, w1_lru, now)
                else:
                    # Keep in window; refresh to avoid immediate churn
                    self._touch(self.W1, w1_lru, now)
            else:
                # If W1 empty (rare), demote cold W2 back to W1
                demote_w2 = self._sample_lru_min_freq(self.W2)
                if demote_w2 is not None:
                    self.W2.pop(demote_w2, None)
                    self._touch(self.W1, demote_w2, now)

        # Keep W2 within its target size by demoting cold entries to W1
        while len(self.W2) > w2_tgt:
            demote_w2 = self._sample_lru_min_freq(self.W2)
            if demote_w2 is None:
                break
            self.W2.pop(demote_w2, None)
            self._touch(self.W1, demote_w2, now)

        # Keep M2 within target (freq-aware demotion)
        while len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is None:
                break
            self.M2.pop(demote, None)
            self._touch(self.M1, demote, now)
            self.dem_m2 += 1

        # Periodically tune parameters
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_evict(self, cache_snapshot, obj, evicted_obj):
        """
        Eviction post-processing:
        - Remove evicted key from all segments.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        k = evicted_obj.key
        self.W1.pop(k, None)
        self.W2.pop(k, None)
        self.M1.pop(k, None)
        self.M2.pop(k, None)
=======
    def on_evict(self, cache_snapshot, obj, evicted_obj):
        """
        Eviction post-processing:
        - Remove evicted key from all segments.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        k = evicted_obj.key
        self.W1.pop(k, None)
        self.W2.pop(k, None)
        self.M1.pop(k, None)
        self.M2.pop(k, None)
        self.last_touch.pop(k, None)
>>>>>>> REPLACE

</DIFF>