<NAME>
dual_competition_freqaware_demotions
</NAME>

<DESCRIPTION>
I improve eviction and admission decisions by:
- Using dual-main competitive admission: sample both M1 and M2 tails and choose the colder effective candidate (with a +1 protection bias for M2). Evict that candidate when the incoming keyâ€™s TinyLFU estimate exceeds the candidate by a scan-aware bias. This allows replacing truly cold protected entries when warranted and is robust under mixed workloads.
- Making W2 demotions frequency-aware via TinyLFU tail sampling instead of strict LRU. This preserves hot items in the protected window and demotes colder ones, reducing misses caused by suboptimal demotions.
- Adding a scan-aware promotion guard from M1 to M2: during suspected scans, require a minimal frequency before promoting to protected, reducing protected pollution.
- Enhancing early bypass and window overflow admission to compare against the colder of M1 and M2 (+1), with stronger gating for direct admission to M2 only for very hot keys. This accelerates capture of emerging hot objects without destabilizing M2.

These targeted changes reduce over-protection of cold entries, prevent scan pollution, and improve admission/eviction choices, lowering the miss rate.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Competitive, scan-aware choice:
        - Prefer evicting a cold M1 entry if new is clearly hotter (TinyLFU + bias).
        - Else evict from W1 (window probationary) to protect main and W2.
        - Else consider replacing a cold M2 if new is much hotter.
        - Robust fallbacks maintain progress with preference to evict from window before main.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        # Cool down scan bias slightly on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        # Candidates
        cand_w1 = self._lru(self.W1)
        cand_w2 = self._lru(self.W2)
        cand_m1 = self._sample_lru_min_freq(self.M1)
        cand_m2 = self._sample_lru_min_freq(self.M2) if cand_m1 is None else None

        f_new = self.sketch.estimate(new_obj.key)
        f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
        f_m2 = self.sketch.estimate(cand_m2) if cand_m2 is not None else -1

        bias = 3 if self.scan_cooldown > 0 else 1

        # Replace a cold probationary main entry if new is clearly hotter
        if cand_m1 is not None and f_new > (f_m1 + bias):
            return cand_m1

        # Otherwise, evict from window probationary (W1) first
        if cand_w1 is not None:
            return cand_w1

        # If window probationary empty, consider replacing a cold protected main
        if cand_m2 is not None and f_new > (f_m2 + bias + 1):
            return cand_m2

        # Fallbacks: prefer evicting from window protected (W2) before main
        if self.W2:
            return self._lru(self.W2)
        if self.M1:
            return self._lru(self.M1)
        if self.M2:
            return self._lru(self.M2)
        # Last resort: any key present
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Competitive, scan-aware choice with dual-main sampling:
        - Sample cold candidates from both M1 and M2 tails (M2 gets +1 protection bias).
        - If f(new) >= colder_main_eff + bias: evict that main candidate (admit new).
        - Else evict from W1 (protect main and W2); robust fallbacks cover empty segments.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        # Cool down scan bias slightly on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        # Candidates
        cand_w1 = self._lru(self.W1)
        cand_w2 = self._lru(self.W2)
        cand_m1 = self._sample_lru_min_freq(self.M1)
        cand_m2 = self._sample_lru_min_freq(self.M2)

        f_new = self.sketch.estimate(new_obj.key)
        f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else None
        f_m2 = self.sketch.estimate(cand_m2) if cand_m2 is not None else None

        bias = 3 if self.scan_cooldown > 0 else 1

        # Compute colder effective main candidate (M2 protected with +1)
        best_cand, best_eff = None, None
        if f_m1 is not None:
            best_cand, best_eff = cand_m1, f_m1
        if f_m2 is not None:
            eff2 = f_m2 + 1
            if best_eff is None or eff2 < best_eff:
                best_cand, best_eff = cand_m2, eff2

        if best_cand is not None and f_new >= (best_eff + bias):
            return best_cand

        # Otherwise, evict from window probationary (W1) first
        if cand_w1 is not None:
            return cand_w1

        # If window probationary empty, try window protected before main fallbacks
        if cand_w2 is not None:
            return cand_w2

        # Fallbacks: prefer M1 over M2 if available
        if self.M1:
            return self._lru(self.M1)
        if self.M2:
            return self._lru(self.M2)
        # Last resort: any key present
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing with split window and main SLRU:
        - W1 hit: promote to W2, or directly to M2 if TinyLFU estimate is high.
        - W2 hit: refresh W2.
        - M1 hit: promote to M2 (protected).
        - M2 hit: refresh M2.
        - Desync hit: treat as warm, place in M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Any hit resets miss streak and cools down scan bias
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, w2_tgt, _, prot_tgt = self._targets()

        if key in self.W1:
            self.hits_w += 1
            # Directly promote to main protected if sufficiently hot
            est = self.sketch.estimate(key)
            thr_hi = 4 if self.scan_cooldown > 0 else 3
            if est >= thr_hi:
                self.W1.pop(key, None)
                self._touch(self.M2, key)
                self.hits_main += 1
                self.prom_m2 += 1
                # Keep M2 within target by demoting a low-freq entry to M1
                if len(self.M2) > prot_tgt:
                    demote = self._sample_lru_min_freq(self.M2)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
                        self.dem_m2 += 1
            else:
                # Otherwise promote to window protected
                self.W1.pop(key, None)
                self._touch(self.W2, key)
                self.hits_w2 += 1
                if len(self.W2) > w2_tgt:
                    demote = self._lru(self.W2)
                    if demote is not None:
                        self.W2.pop(demote, None)
                        self._touch(self.W1, demote)
            self._maybe_tune(now)
            return

        if key in self.W2:
            self.hits_w += 1
            self.hits_w2 += 1
            self._touch(self.W2, key)
            # If W2 grew past target (could happen due to prior changes), demote LRU to W1
            if len(self.W2) > w2_tgt:
                demote = self._lru(self.W2)
                if demote is not None:
                    self.W2.pop(demote, None)
                    self._touch(self.W1, demote)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to main protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            self.prom_m2 += 1
            # Keep M2 within target by demoting low-freq from M2 to M1
            if len(self.M2) > prot_tgt:
                demote = self._sample_lru_min_freq(self.M2)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
                    self.dem_m2 += 1
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm and place into M2
        self.hits_main += 1
        self._touch(self.M2, key)
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.dem_m2 += 1
        self._maybe_tune(now)
=======
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing with split window and main SLRU:
        - W1 hit: promote to W2, or directly to M2 if TinyLFU estimate is high.
        - W2 hit: refresh W2.
        - M1 hit: promote to M2 (protected), with scan-aware guard.
        - M2 hit: refresh M2.
        - Desync hit: treat as warm, place in M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Any hit resets miss streak and cools down scan bias
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, w2_tgt, _, prot_tgt = self._targets()

        if key in self.W1:
            self.hits_w += 1
            # Directly promote to main protected if sufficiently hot
            est = self.sketch.estimate(key)
            thr_hi = 4 if self.scan_cooldown > 0 else 3
            if est >= thr_hi:
                self.W1.pop(key, None)
                self._touch(self.M2, key)
                self.hits_main += 1
                self.prom_m2 += 1
                # Keep M2 within target by demoting a low-freq entry to M1
                while len(self.M2) > prot_tgt:
                    demote = self._sample_lru_min_freq(self.M2)
                    if demote is None:
                        break
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
                    self.dem_m2 += 1
            else:
                # Otherwise promote to window protected
                self.W1.pop(key, None)
                self._touch(self.W2, key)
                self.hits_w2 += 1
                # Keep W2 within target using frequency-aware demotion
                while len(self.W2) > w2_tgt:
                    demote = self._sample_lru_min_freq(self.W2)
                    if demote is None:
                        break
                    self.W2.pop(demote, None)
                    self._touch(self.W1, demote)
            self._maybe_tune(now)
            return

        if key in self.W2:
            self.hits_w += 1
            self.hits_w2 += 1
            self._touch(self.W2, key)
            # If W2 grew past target (could happen due to prior changes), demote cold to W1
            while len(self.W2) > w2_tgt:
                demote = self._sample_lru_min_freq(self.W2)
                if demote is None:
                    break
                self.W2.pop(demote, None)
                self._touch(self.W1, demote)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            est = self.sketch.estimate(key)
            # Scan-aware promotion guard: require small frequency when in cooldown
            if self.scan_cooldown > 0 and est < 2:
                self._touch(self.M1, key)
            else:
                # Promote to main protected
                self.M1.pop(key, None)
                self._touch(self.M2, key)
                self.prom_m2 += 1
                # Keep M2 within target by demoting low-freq from M2 to M1
                while len(self.M2) > prot_tgt:
                    demote = self._sample_lru_min_freq(self.M2)
                    if demote is None:
                        break
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
                    self.dem_m2 += 1
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm and place into M2
        self.hits_main += 1
        self._touch(self.M2, key)
        while len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is None:
                break
            self.M2.pop(demote, None)
            self._touch(self.M1, demote)
            self.dem_m2 += 1
        self._maybe_tune(now)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Insert new key into W1 (window probationary).
        - If window exceeds target, consider moving W1's LRU to M1 via TinyLFU-gated admission.
        - Maintain W2 within its target (demote W2 LRU back to W1 if needed).
        - Maintain M2 within its target (demote low-freq M2 to M1).
        - Update scan detector.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update scan detector for consecutive misses with capacity-aware threshold
        self.miss_streak += 1
        thr = max(16, (self.capacity or 1) // 2)
        if self.miss_streak > thr:
            self.scan_cooldown = max(self.scan_cooldown, thr)
        else:
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere (idempotent)
        self.W1.pop(key, None)
        self.W2.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into W1 (probationary)
        self._touch(self.W1, key)

        # Early bypass: if new is already hot by TinyLFU, admit to M1 directly (gated)
        cand_m1_early = self._sample_lru_min_freq(self.M1)
        f_new = self.sketch.estimate(key)
        f_m1_early = self.sketch.estimate(cand_m1_early) if cand_m1_early is not None else -1
        bias_early = 3 if self.scan_cooldown > 0 else 1
        thr_hi = 4 if self.scan_cooldown > 0 else 3
        if f_new >= thr_hi and f_new >= (f_m1_early + bias_early):
            self.W1.pop(key, None)
            self._touch(self.M1, key)

        # Rebalance window size vs target
        w_tgt, w2_tgt, _, prot_tgt = self._targets()
        # If window exceeds target, consider moving W1's LRU to M1 using TinyLFU comparison
        if (len(self.W1) + len(self.W2)) > w_tgt:
            w1_lru = self._lru(self.W1)
            if w1_lru is not None and w1_lru != key:
                cand_m1 = self._sample_lru_min_freq(self.M1)
                f_w1 = self.sketch.estimate(w1_lru)
                f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
                bias = 3 if self.scan_cooldown > 0 else 1
                if f_w1 >= (f_m1 + bias):
                    # Admit into probationary main
                    self.W1.pop(w1_lru, None)
                    self._touch(self.M1, w1_lru)
                else:
                    # Keep in window; refresh to avoid immediate churn
                    self._touch(self.W1, w1_lru)
            else:
                # If W1 empty (rare), demote W2 LRU back to W1
                w2_lru = self._lru(self.W2)
                if w2_lru is not None:
                    self.W2.pop(w2_lru, None)
                    self._touch(self.W1, w2_lru)

        # Keep W2 within its target size by demoting its LRU to W1
        if len(self.W2) > w2_tgt:
            demote_w2 = self._lru(self.W2)
            if demote_w2 is not None:
                self.W2.pop(demote_w2, None)
                self._touch(self.W1, demote_w2)

        # Keep M2 within target (freq-aware demotion)
        if len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
                self.dem_m2 += 1

        # Periodically tune parameters
        self._maybe_tune(now)
=======
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Insert new key into W1 (window probationary).
        - Early bypass: compare against colder of M1/M2 (+1) to possibly admit to M1/M2.
        - If window exceeds target, consider moving W1's LRU to M1 via TinyLFU-gated dual-main comparison.
        - Maintain W2 within its target (demote W2 cold back to W1 if needed).
        - Maintain M2 within its target (demote low-freq M2 to M1).
        - Update scan detector.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update scan detector for consecutive misses with capacity-aware threshold
        self.miss_streak += 1
        thr = max(16, (self.capacity or 1) // 2)
        if self.miss_streak > thr:
            self.scan_cooldown = max(self.scan_cooldown, thr)
        else:
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere (idempotent)
        self.W1.pop(key, None)
        self.W2.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into W1 (probationary)
        self._touch(self.W1, key)

        # Early bypass: if new is already hot, admit to M1 or M2 directly (dual-main gated)
        cand_m1_early = self._sample_lru_min_freq(self.M1)
        cand_m2_early = self._sample_lru_min_freq(self.M2)
        f_new = self.sketch.estimate(key)
        f_m1_early = self.sketch.estimate(cand_m1_early) if cand_m1_early is not None else None
        f_m2_early = self.sketch.estimate(cand_m2_early) if cand_m2_early is not None else None
        effs = []
        if f_m1_early is not None:
            effs.append(f_m1_early)
        if f_m2_early is not None:
            effs.append(f_m2_early + 1)  # protect M2
        comp_eff = min(effs) if effs else -1
        bias_early = 3 if self.scan_cooldown > 0 else 1
        thr_hi = 4 if self.scan_cooldown > 0 else 3
        if f_new >= thr_hi and f_new >= (comp_eff + bias_early):
            # Prefer direct M2 only when clearly much hotter than M2 tail
            if f_m2_early is not None and f_new >= (f_m2_early + bias_early + 2):
                self.W1.pop(key, None)
                self._touch(self.M2, key)
            else:
                self.W1.pop(key, None)
                self._touch(self.M1, key)

        # Rebalance window size vs target
        w_tgt, w2_tgt, _, prot_tgt = self._targets()
        # If window exceeds target, consider moving W1's LRU to M1 using dual-main TinyLFU comparison
        if (len(self.W1) + len(self.W2)) > w_tgt:
            w1_lru = self._lru(self.W1)
            if w1_lru is not None and w1_lru != key:
                cand_m1 = self._sample_lru_min_freq(self.M1)
                cand_m2 = self._sample_lru_min_freq(self.M2)
                f_w1 = self.sketch.estimate(w1_lru)
                comp_list = []
                if cand_m1 is not None:
                    comp_list.append(self.sketch.estimate(cand_m1))
                if cand_m2 is not None:
                    comp_list.append(self.sketch.estimate(cand_m2) + 1)
                comp_eff = min(comp_list) if comp_list else -1
                bias = 3 if self.scan_cooldown > 0 else 1
                if f_w1 >= (comp_eff + bias):
                    # Admit into probationary main
                    self.W1.pop(w1_lru, None)
                    self._touch(self.M1, w1_lru)
                else:
                    # Keep in window; refresh to avoid immediate churn
                    self._touch(self.W1, w1_lru)
            else:
                # If W1 empty (rare), demote a cold W2 back to W1
                demote_w2 = self._sample_lru_min_freq(self.W2)
                if demote_w2 is not None:
                    self.W2.pop(demote_w2, None)
                    self._touch(self.W1, demote_w2)

        # Keep W2 within its target size by demoting its cold entries to W1
        while len(self.W2) > w2_tgt:
            demote_w2 = self._sample_lru_min_freq(self.W2)
            if demote_w2 is None:
                break
            self.W2.pop(demote_w2, None)
            self._touch(self.W1, demote_w2)

        # Keep M2 within target (freq-aware demotion)
        while len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2)
            if demote is None:
                break
            self.M2.pop(demote, None)
            self._touch(self.M1, demote)
            self.dem_m2 += 1

        # Periodically tune parameters
        self._maybe_tune(now)
>>>>>>> REPLACE
</DIFF>