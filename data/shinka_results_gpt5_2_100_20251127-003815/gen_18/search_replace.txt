<NAME>
arc_tinylfu_with_ghosts_and_adaptive_replace
</NAME>

<DESCRIPTION>
I introduce ARC-style ghost lists (B1 for probation evictions and B2 for protected evictions) combined with the existing TinyLFU frequency sketch and segmented LRU. This enables adaptive control of which segment to evict from based on learned workload characteristics via ghost hits. Specifically:

- Add B1/B2 ghost LRU lists and maintain them on evictions (update_after_evict), bounded in size (≤ capacity).
- On insert (miss), if the key is in B1 or B2 (ghost hit), adapt the protected ratio target m_p (decrease on B1 hits to favor recency/probation; increase on B2 hits to favor frequency/protected) and directly reinsert the key into protected (as ARC does on ghost hits).
- Ensure ghost entries are removed when an item becomes resident (on hit/insert) and when they collide with resident keys during pruning.
- Improve victim selection (evict) to use an ARC-like replace policy: evict from probation when probation exceeds its target size (cap − protected_target), otherwise evict from protected. Within the chosen list, select the lowest TinyLFU estimated frequency among a small LRU-tail sample.

This combination enhances scan resistance, reduces cache pollution, and adapts to recency vs. frequency dominated workloads. It keeps the existing CMS learning and promotion gating but adds robust list balancing and feedback via ghost hits. The changes are confined to the evolve block and maintain consistency across functions and globals.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from collections import OrderedDict

# Segmented LRU with TinyLFU-style bias and adaptive protected sizing.
# - m_probation: LRU list for new/cold entries (T1)
# - m_protected: LRU list for hot/promoted entries (T2)
# - Count-Min Sketch (CMS) for frequency estimates, periodically aged
# - m_p: smoothed protected ratio target via EMA, steered by hit-rate and scan detector

m_probation = OrderedDict()
m_protected = OrderedDict()
=======
from collections import OrderedDict

# Segmented LRU with TinyLFU-style bias and adaptive protected sizing + ARC ghosts.
# - m_probation (T1): LRU list for new/cold entries
# - m_protected (T2): LRU list for hot/promoted entries
# - m_B1: ghost LRU for keys evicted from probation (T1)
# - m_B2: ghost LRU for keys evicted from protected (T2)
# - Count-Min Sketch (CMS) for frequency estimates, periodically aged
# - m_p: smoothed protected ratio target via EMA, steered by hit-rate, scan detector, and ghost hits

m_probation = OrderedDict()
m_protected = OrderedDict()
m_B1 = OrderedDict()
m_B2 = OrderedDict()
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def _reset_if_new_run(cache_snapshot):
    """Reset metadata when a new trace/cache run starts."""
    global m_probation, m_protected, m_sketch, m_sketch_w, m_sketch_ops, m_sketch_age_threshold
    global m_p, m_miss_streak, _m_last_seen_access
    # New run if access counter restarts or at very beginning
    if cache_snapshot.access_count <= 1 or _m_last_seen_access > cache_snapshot.access_count:
        m_probation.clear()
        m_protected.clear()
        m_sketch_w = 0
        m_sketch = []
        m_sketch_ops = 0
        m_sketch_age_threshold = 0
        m_p = 0.5
        m_miss_streak = 0
    _m_last_seen_access = cache_snapshot.access_count
=======
def _reset_if_new_run(cache_snapshot):
    """Reset metadata when a new trace/cache run starts."""
    global m_probation, m_protected, m_B1, m_B2
    global m_sketch, m_sketch_w, m_sketch_ops, m_sketch_age_threshold
    global m_p, m_miss_streak, _m_last_seen_access
    # New run if access counter restarts or at very beginning
    if cache_snapshot.access_count <= 1 or _m_last_seen_access > cache_snapshot.access_count:
        m_probation.clear()
        m_protected.clear()
        m_B1.clear()
        m_B2.clear()
        m_sketch_w = 0
        m_sketch = []
        m_sketch_ops = 0
        m_sketch_age_threshold = 0
        m_p = 0.5
        m_miss_streak = 0
    _m_last_seen_access = cache_snapshot.access_count
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def _prune_metadata(cache_snapshot):
    """Keep metadata consistent with actual cache content."""
    cache_keys = cache_snapshot.cache.keys()
    for seg in (m_probation, m_protected):
        to_del = [k for k in seg.keys() if k not in cache_keys]
        for k in to_del:
            seg.pop(k, None)
=======
def _prune_metadata(cache_snapshot):
    """Keep metadata consistent with actual cache content."""
    cache_keys = cache_snapshot.cache.keys()
    # Resident segments must only contain keys in the cache
    for seg in (m_probation, m_protected):
        to_del = [k for k in seg.keys() if k not in cache_keys]
        for k in to_del:
            seg.pop(k, None)
    # Ghost lists must not contain keys currently resident
    for gseg in (m_B1, m_B2):
        to_del = [k for k in gseg.keys() if k in cache_keys]
        for k in to_del:
            gseg.pop(k, None)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    _reset_if_new_run(cache_snapshot)
    _prune_metadata(cache_snapshot)
    _ensure_sketch(cache_snapshot)
    _seed_from_cache(cache_snapshot)

    # Prefer evicting from probation; fall back to protected when necessary.
    if m_probation:
        victim = _eviction_sample(cache_snapshot, m_probation, sample_k=8)
        if victim is not None:
            return victim
    if m_protected:
        victim = _eviction_sample(cache_snapshot, m_protected, sample_k=8)
        if victim is not None:
            return victim
    # Fallback: choose any key from the cache
    for k in cache_snapshot.cache.keys():
        return k
    return None
=======
def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    _reset_if_new_run(cache_snapshot)
    _prune_metadata(cache_snapshot)
    _ensure_sketch(cache_snapshot)
    _seed_from_cache(cache_snapshot)

    cap = max(1, int(cache_snapshot.capacity))
    prot_target = _protected_target_size(cache_snapshot)
    t1_target = max(1, cap - prot_target)

    # ARC-style replace: evict from probation if it exceeds its target; otherwise from protected
    if m_probation and len(m_probation) > t1_target:
        victim = _eviction_sample(cache_snapshot, m_probation, sample_k=8)
        if victim is not None:
            return victim
    if m_protected:
        victim = _eviction_sample(cache_snapshot, m_protected, sample_k=8)
        if victim is not None:
            return victim
    if m_probation:
        victim = _eviction_sample(cache_snapshot, m_probation, sample_k=8)
        if victim is not None:
            return victim
    # Fallback: choose any key from the cache
    for k in cache_snapshot.cache.keys():
        return k
    return None
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global m_miss_streak
    _reset_if_new_run(cache_snapshot)
    _prune_metadata(cache_snapshot)
    _ensure_sketch(cache_snapshot)

    k = obj.key
    m_miss_streak = 0
    # Learn frequency
    _sketch_add(cache_snapshot, k, 1)

    if k in m_protected:
        # Refresh recency in protected
        m_protected.move_to_end(k, last=True)
    elif k in m_probation:
        # Promote only if sufficiently frequent; else refresh in probation
        if _sketch_est(cache_snapshot, k) >= 2:
            m_probation.pop(k, None)
            m_protected[k] = None
        else:
            m_probation.move_to_end(k, last=True)
    else:
        # Metadata miss but cache hit: re-admit conservatively
        if _sketch_est(cache_snapshot, k) >= 2:
            m_protected[k] = None
        else:
            m_probation[k] = None

    # Keep protected near its target by demoting oldest if needed
    target = _protected_target_size(cache_snapshot)
    while len(m_protected) > target:
        demote_k, _ = m_protected.popitem(last=False)  # LRU of protected
        m_probation[demote_k] = None
=======
def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global m_miss_streak
    _reset_if_new_run(cache_snapshot)
    _prune_metadata(cache_snapshot)
    _ensure_sketch(cache_snapshot)

    k = obj.key
    m_miss_streak = 0
    # Learn frequency
    _sketch_add(cache_snapshot, k, 1)

    # If present in ghosts, remove (it's now resident)
    m_B1.pop(k, None)
    m_B2.pop(k, None)

    if k in m_protected:
        # Refresh recency in protected
        m_protected.move_to_end(k, last=True)
    elif k in m_probation:
        # Promote only if sufficiently frequent; else refresh in probation
        if _sketch_est(cache_snapshot, k) >= 2:
            m_probation.pop(k, None)
            m_protected[k] = None
        else:
            m_probation.move_to_end(k, last=True)
    else:
        # Metadata miss but cache hit: re-admit conservatively
        if _sketch_est(cache_snapshot, k) >= 2:
            m_protected[k] = None
        else:
            m_probation[k] = None

    # Keep protected near its target by demoting oldest if needed
    target = _protected_target_size(cache_snapshot)
    while len(m_protected) > target:
        demote_k, _ = m_protected.popitem(last=False)  # LRU of protected
        m_probation[demote_k] = None
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global m_miss_streak
    _reset_if_new_run(cache_snapshot)
    _prune_metadata(cache_snapshot)
    _ensure_sketch(cache_snapshot)

    k = obj.key
    m_miss_streak += 1

    # New items enter probation (doorkeeper credit to sketch)
    _sketch_add(cache_snapshot, k, 1)
    m_protected.pop(k, None)
    m_probation.pop(k, None)
    m_probation[k] = None

    # Ensure protected doesn't exceed its target (shouldn't change on insert,
    # but keep the invariant in case of out-of-band changes)
    target = _protected_target_size(cache_snapshot)
    while len(m_protected) > target:
        demote_k, _ = m_protected.popitem(last=False)
        m_probation[demote_k] = None
=======
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global m_miss_streak, m_p
    _reset_if_new_run(cache_snapshot)
    _prune_metadata(cache_snapshot)
    _ensure_sketch(cache_snapshot)

    k = obj.key
    m_miss_streak += 1

    # Doorkeeper credit to sketch for new arrivals
    _sketch_add(cache_snapshot, k, 1)

    # If key is in ghosts, adapt and re-admit into protected (ARC behavior)
    if k in m_B1:
        # Favor recency: decrease protected ratio target
        m_B1.pop(k, None)
        m_B2.pop(k, None)
        m_protected.pop(k, None)
        m_probation.pop(k, None)
        m_p = max(0.1, m_p - 0.1)
        m_protected[k] = None
    elif k in m_B2:
        # Favor frequency: increase protected ratio target
        m_B2.pop(k, None)
        m_B1.pop(k, None)
        m_protected.pop(k, None)
        m_probation.pop(k, None)
        m_p = min(0.9, m_p + 0.1)
        m_protected[k] = None
    else:
        # Normal miss: enter probation to filter one-hit wonders
        m_protected.pop(k, None)
        m_probation.pop(k, None)
        m_probation[k] = None

    # Ensure protected doesn't exceed its target; demote oldest if needed
    target = _protected_target_size(cache_snapshot)
    while len(m_protected) > target:
        demote_k, _ = m_protected.popitem(last=False)
        m_probation[demote_k] = None

    # Enforce ghost bound: |B1| + |B2| ≤ capacity
    cap = max(1, int(cache_snapshot.capacity))
    while (len(m_B1) + len(m_B2)) > cap:
        if len(m_B1) > len(m_B2):
            m_B1.popitem(last=False)
        else:
            m_B2.popitem(last=False)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    _reset_if_new_run(cache_snapshot)
    # Remove evicted object from segments; keep sketch counts to preserve long-term bias
    evk = evicted_obj.key
    m_probation.pop(evk, None)
    m_protected.pop(evk, None)
=======
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    _reset_if_new_run(cache_snapshot)
    # Determine origin segment before removal, then add to corresponding ghost list.
    evk = evicted_obj.key
    in_prob = evk in m_probation
    in_prot = evk in m_protected

    # Remove from resident segments; keep sketch counts to preserve long-term bias
    m_probation.pop(evk, None)
    m_protected.pop(evk, None)

    # Add to ghosts
    if in_prob:
        m_B1.pop(evk, None)
        m_B1[evk] = None
    elif in_prot:
        m_B2.pop(evk, None)
        m_B2[evk] = None

    # Enforce ghost bound: |B1| + |B2| ≤ capacity
    cap = max(1, int(cache_snapshot.capacity))
    while (len(m_B1) + len(m_B2)) > cap:
        if len(m_B1) > len(m_B2):
            m_B1.popitem(last=False)
        else:
            m_B2.popitem(last=False)
>>>>>>> REPLACE
</DIFF>