<NAME>
tiny_lfu_ema_scan_bypass_and_competitive_victim
</NAME>

<DESCRIPTION>
I introduce three targeted improvements grounded in modern cache policy design:

1) EMA-based scan/phase detection and adaptive tuning:
- Track an exponential moving average (EMA) of the miss rate (ema_miss with alpha=0.05).
- Use this EMA together with a short miss streak to trigger a scan_cooldown more reliably than a simple consecutive-miss counter alone.
- During periodic tuning, adapt the Count-Min Sketch age period and the sample size (_sample_k) based on hit-share and the EMA, improving responsiveness to workload phases.

2) Competitive, frequency-aware victim selection improvements:
- Sample from W1’s LRU tail (not strict LRU) using the same lexicographic coldness comparator, aligning W1 victim selection with M1/M2 sampling.
- Consider both M1 and M2 candidates even when M1 is non-empty: evict from M1 if the incoming item is clearly hotter; otherwise, evict from M2 only when the new item is much hotter than M2’s candidate. This reduces churn and improves admission quality for hot items.

3) Early admission bypass on insert and safer promotions under scans:
- On insertion, with TinyLFU comparisons, directly place the new key into M1 or M2 when it significantly out-scores current M1/M2 candidates; otherwise default to W1. Under scan cooldown, avoid promoting to M2 unless the new item is clearly hot.
- On hit, gate promotions from W1→W2 and M1→M2 under scan cooldown unless TinyLFU estimate surpasses a small threshold. This protects the protected segments from scan pollution while preserving emerging hot objects.

These changes focus on the evict, update_after_hit, update_after_insert, and update_after_evict pathways, aiming to lower miss rates by improving victim selection quality, admission gating, and scan robustness while maintaining efficient metadata operations.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    __slots__ = (
        "W1", "W2", "M1", "M2", "capacity",
        "win_frac", "w2_frac", "prot_frac",
        "sketch", "_sample_k", "last_touch",
        "hits_w", "hits_main", "hits_w2",
        "prom_m2", "dem_m2",
        "last_tune_time", "tune_period",
        "miss_streak", "scan_cooldown"
    )
=======
    __slots__ = (
        "W1", "W2", "M1", "M2", "capacity",
        "win_frac", "w2_frac", "prot_frac",
        "sketch", "_sample_k", "last_touch",
        "hits_w", "hits_main", "hits_w2",
        "prom_m2", "dem_m2",
        "last_tune_time", "tune_period",
        "miss_streak", "scan_cooldown",
        "ema_miss", "ema_alpha"
    )
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
        # Scan handling
        self.miss_streak = 0
        self.scan_cooldown = 0
=======
        # Scan handling
        self.miss_streak = 0
        self.scan_cooldown = 0
        # EMA of miss rate for robust scan/phase detection
        self.ema_miss = 0.5
        self.ema_alpha = 0.05
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def _maybe_tune(self, now: int):
        # Periodically adapt window and protection fractions.
        if self.tune_period <= 0:
            return
        if (now - self.last_tune_time) >= self.tune_period:
            # Adapt window size based on relative hit share
            if self.hits_w > self.hits_main * 1.15:
                self.win_frac = min(0.55, self.win_frac + 0.05)
            elif self.hits_main > self.hits_w * 1.15:
                self.win_frac = max(0.08, self.win_frac - 0.04)

            # Adapt W2 share inside window
            if self.hits_w2 > (self.hits_w + 1) * 0.7:
                self.w2_frac = min(0.6, self.w2_frac + 0.05)
            elif self.hits_w > self.hits_w2 * 1.6:
                self.w2_frac = max(0.2, self.w2_frac - 0.05)

            # Adapt main protected fraction based on promotion/demotion balance
            if self.prom_m2 > self.dem_m2 * 1.2 and self.hits_main > self.hits_w:
                self.prot_frac = min(0.9, self.prot_frac + 0.05)
            elif self.dem_m2 > self.prom_m2 * 1.2:
                self.prot_frac = max(0.6, self.prot_frac - 0.05)

            # Decay stats
            self.hits_w >>= 1
            self.hits_w2 >>= 1
            self.hits_main >>= 1
            self.prom_m2 >>= 1
            self.dem_m2 >>= 1
            self.last_tune_time = now
=======
    def _maybe_tune(self, now: int):
        # Periodically adapt window and protection fractions.
        if self.tune_period <= 0:
            return
        if (now - self.last_tune_time) >= self.tune_period:
            # Adapt window size based on relative hit share
            if self.hits_w > self.hits_main * 1.15:
                self.win_frac = min(0.55, self.win_frac + 0.05)
            elif self.hits_main > self.hits_w * 1.15:
                self.win_frac = max(0.08, self.win_frac - 0.04)

            # Adapt W2 share inside window
            if self.hits_w2 > (self.hits_w + 1) * 0.7:
                self.w2_frac = min(0.6, self.w2_frac + 0.05)
            elif self.hits_w > self.hits_w2 * 1.6:
                self.w2_frac = max(0.2, self.w2_frac - 0.05)

            # Adapt main protected fraction based on promotion/demotion balance
            if self.prom_m2 > self.dem_m2 * 1.2 and self.hits_main > self.hits_w:
                self.prot_frac = min(0.9, self.prot_frac + 0.05)
            elif self.dem_m2 > self.prom_m2 * 1.2:
                self.prot_frac = max(0.6, self.prot_frac - 0.05)

            # Adapt sampling aggressiveness: larger samples when main is stable
            if self.hits_main > self.hits_w * 1.2:
                self._sample_k = min(12, max(self._sample_k, 8))
            elif self.hits_w > self.hits_main * 1.2:
                self._sample_k = max(4, min(self._sample_k, 6))
            else:
                self._sample_k = max(4, min(self._sample_k, 6))

            # Adjust sketch aging using EMA of misses (faster aging under churn)
            cap = self.capacity or 1
            if self.ema_miss > 0.8:
                self.sketch.age_period = max(512, min(16384, cap * 4))
            else:
                self.sketch.age_period = max(512, min(16384, cap * 8))

            # Decay stats
            self.hits_w >>= 1
            self.hits_w2 >>= 1
            self.hits_main >>= 1
            self.prom_m2 >>= 1
            self.dem_m2 >>= 1
            self.last_tune_time = now
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Lexicographic coldness with TinyLFU + decayed recency:
        - Sample from M1 and M2 LRU tails; M2 gets +1 bias for protection.
        - Prefer evicting from M1 when new is hotter than M1 candidate.
        - Otherwise evict from W1; only touch M2 if new is much hotter than M2 candidate.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Cool down scan bias slightly on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        # Candidates
        cand_w1 = self._lru(self.W1)
        cand_m1 = self._sample_lru_min_freq(self.M1, now, bias=0)
        # Only consider M2 if M1 is empty; protects main when window has options
        cand_m2 = self._sample_lru_min_freq(self.M2, now, bias=1) if not self.M1 else None

        f_new = self.sketch.estimate(new_obj.key)
        f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
        f_m2 = self.sketch.estimate(cand_m2) if cand_m2 is not None else -1

        bias = 3 if self.scan_cooldown > 0 else 1

        # Replace a cold probationary main entry if new is clearly hotter
        if cand_m1 is not None and f_new >= (f_m1 + bias):
            return cand_m1

        # Otherwise, evict from window probationary (W1) first
        if cand_w1 is not None:
            return cand_w1

        # If window probationary empty, consider replacing a cold protected main
        if cand_m2 is not None and f_new >= (f_m2 + bias + 1):
            return cand_m2

        # Fallbacks
        if self.M1:
            return self._lru(self.M1)
        if self.M2:
            return self._lru(self.M2)
        if self.W2:
            return self._lru(self.W2)
        # Last resort: any key present
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Lexicographic coldness with TinyLFU + decayed recency:
        - Sample from W1, M1 and M2 LRU tails; M2 gets +1 bias for protection.
        - Prefer evicting from M1 when new is clearly hotter than M1 candidate.
        - If new is extremely hot, allow replacing a cold M2 candidate.
        - Otherwise evict from W1 to preserve main segments.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Cool down scan bias slightly on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        # Candidates using frequency-aware sampling (with recency tiebreak)
        cand_w1 = self._sample_lru_min_freq(self.W1, now, bias=0)
        cand_m1 = self._sample_lru_min_freq(self.M1, now, bias=0)
        cand_m2 = self._sample_lru_min_freq(self.M2, now, bias=1)

        f_new = self.sketch.estimate(new_obj.key)
        f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
        f_m2 = self.sketch.estimate(cand_m2) if cand_m2 is not None else -1

        bias = 3 if self.scan_cooldown > 0 else 1

        # Replace a cold probationary main entry if new is clearly hotter
        if cand_m1 is not None and f_new >= (f_m1 + bias):
            return cand_m1

        # If window probationary empty, consider replacing a cold protected main
        if cand_m2 is not None and f_new >= (f_m2 + bias + 1):
            return cand_m2

        # Otherwise, evict from window probationary (W1) first
        if cand_w1 is not None:
            return cand_w1

        # Fallbacks
        if self.M1:
            return self._lru(self.M1)
        if self.M2:
            return self._lru(self.M2)
        if self.W2:
            return self._lru(self.W2)
        # Last resort: any key present
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing with split window and main SLRU:
        - W1 hit: promote to W2 (protected).
        - W2 hit: refresh W2.
        - M1 hit: promote to M2 (protected).
        - M2 hit: refresh M2.
        - Desync hit: treat as warm, place in M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Any hit resets miss streak and cools down scan bias
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, w2_tgt, _, prot_tgt = self._targets()

        if key in self.W1:
            self.hits_w += 1
            # Promote to window protected
            self.W1.pop(key, None)
            self._touch(self.W2, key, now)
            self.hits_w2 += 1
            # Keep W2 within target using frequency-aware demotion back to W1
            while len(self.W2) > w2_tgt:
                demote = self._sample_lru_min_freq(self.W2, now, bias=0)
                if demote is None:
                    break
                self.W2.pop(demote, None)
                self._touch(self.W1, demote, now)
            self._maybe_tune(now)
            return

        if key in self.W2:
            self.hits_w += 1
            self.hits_w2 += 1
            self._touch(self.W2, key, now)
            # If W2 grew past target (could happen due to prior changes), demote cold to W1
            while len(self.W2) > w2_tgt:
                demote = self._sample_lru_min_freq(self.W2, now, bias=0)
                if demote is None:
                    break
                self.W2.pop(demote, None)
                self._touch(self.W1, demote, now)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to main protected
            self.M1.pop(key, None)
            self._touch(self.M2, key, now)
            self.prom_m2 += 1
            # Keep M2 within target by demoting low-freq from M2 to M1
            while len(self.M2) > prot_tgt:
                demote = self._sample_lru_min_freq(self.M2, now, bias=1)
                if demote is None:
                    break
                self.M2.pop(demote, None)
                self._touch(self.M1, demote, now)
                self.dem_m2 += 1
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key, now)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm and place into M2
        self.hits_main += 1
        self._touch(self.M2, key, now)
        while len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2, now, bias=1)
            if demote is None:
                break
            self.M2.pop(demote, None)
            self._touch(self.M1, demote, now)
            self.dem_m2 += 1
        self._maybe_tune(now)
=======
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing with split window and main SLRU:
        - W1 hit: promote to W2 (protected) unless in scan cooldown and not hot.
        - W2 hit: refresh W2.
        - M1 hit: promote to M2 (protected) unless in scan cooldown and not hot.
        - M2 hit: refresh M2.
        - Desync hit: treat as warm, place in M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update EMA of misses (hit -> 0)
        self.ema_miss = (1.0 - self.ema_alpha) * self.ema_miss

        # Any hit resets miss streak and cools down scan bias faster
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown = max(0, self.scan_cooldown - 2)

        w_tgt, w2_tgt, _, prot_tgt = self._targets()
        f_est = self.sketch.estimate(key)

        if key in self.W1:
            self.hits_w += 1
            if self.scan_cooldown > 0 and f_est < 2:
                # Avoid polluting W2 during scans if not hot
                self._touch(self.W1, key, now)
            else:
                # Promote to window protected
                self.W1.pop(key, None)
                self._touch(self.W2, key, now)
                self.hits_w2 += 1
            # Keep W2 within target using frequency-aware demotion back to W1
            while len(self.W2) > w2_tgt:
                demote = self._sample_lru_min_freq(self.W2, now, bias=0)
                if demote is None:
                    break
                self.W2.pop(demote, None)
                self._touch(self.W1, demote, now)
            self._maybe_tune(now)
            return

        if key in self.W2:
            self.hits_w += 1
            self.hits_w2 += 1
            self._touch(self.W2, key, now)
            # If W2 grew past target (could happen due to prior changes), demote cold to W1
            while len(self.W2) > w2_tgt:
                demote = self._sample_lru_min_freq(self.W2, now, bias=0)
                if demote is None:
                    break
                self.W2.pop(demote, None)
                self._touch(self.W1, demote, now)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            if self.scan_cooldown > 0 and f_est < 2:
                # Avoid promoting weak items into M2 during scans
                self._touch(self.M1, key, now)
            else:
                # Promote to main protected
                self.M1.pop(key, None)
                self._touch(self.M2, key, now)
                self.prom_m2 += 1
            # Keep M2 within target by demoting low-freq from M2 to M1
            while len(self.M2) > prot_tgt:
                demote = self._sample_lru_min_freq(self.M2, now, bias=1)
                if demote is None:
                    break
                self.M2.pop(demote, None)
                self._touch(self.M1, demote, now)
                self.dem_m2 += 1
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key, now)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm and place into M2
        self.hits_main += 1
        self._touch(self.M2, key, now)
        while len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2, now, bias=1)
            if demote is None:
                break
            self.M2.pop(demote, None)
            self._touch(self.M1, demote, now)
            self.dem_m2 += 1
        self._maybe_tune(now)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Insert new key into W1 (window probationary).
        - If window exceeds target, consider moving W1's LRU to M1 via TinyLFU-gated admission.
        - Maintain W2 within its target (demote W2 cold back to W1 if needed).
        - Maintain M2 within its target (demote low-freq M2 to M1).
        - Update scan detector.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update scan detector for consecutive misses
        self.miss_streak += 1
        if self.miss_streak > (self.capacity or 1):
            self.scan_cooldown = max(self.scan_cooldown, self.capacity or 1)
        else:
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere (idempotent)
        self.W1.pop(key, None)
        self.W2.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into W1 (probationary)
        self._touch(self.W1, key, now)

        # Rebalance window size vs target
        w_tgt, w2_tgt, _, prot_tgt = self._targets()
        # If window exceeds target, consider moving W1's LRU to M1 using TinyLFU comparison
        if (len(self.W1) + len(self.W2)) > w_tgt:
            w1_lru = self._lru(self.W1)
            if w1_lru is not None and w1_lru != key:
                cand_m1 = self._sample_lru_min_freq(self.M1, now, bias=0)
                f_w1 = self.sketch.estimate(w1_lru)
                f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
                bias = 3 if self.scan_cooldown > 0 else 1
                if f_w1 >= (f_m1 + bias):
                    # Admit into probationary main
                    self.W1.pop(w1_lru, None)
                    self._touch(self.M1, w1_lru, now)
                else:
                    # Keep in window; refresh to avoid immediate churn
                    self._touch(self.W1, w1_lru, now)
            else:
                # If W1 empty (rare), demote a cold W2 back to W1
                demote_w2 = self._sample_lru_min_freq(self.W2, now, bias=0)
                if demote_w2 is not None:
                    self.W2.pop(demote_w2, None)
                    self._touch(self.W1, demote_w2, now)

        # Keep W2 within its target size by demoting its cold entries to W1
        while len(self.W2) > w2_tgt:
            demote_w2 = self._sample_lru_min_freq(self.W2, now, bias=0)
            if demote_w2 is None:
                break
            self.W2.pop(demote_w2, None)
            self._touch(self.W1, demote_w2, now)

        # Keep M2 within target (freq-aware demotion with M2 bias)
        while len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2, now, bias=1)
            if demote is None:
                break
            self.M2.pop(demote, None)
            self._touch(self.M1, demote, now)
            self.dem_m2 += 1

        # Periodically tune parameters
        self._maybe_tune(now)
=======
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Increment TinyLFU.
        - Early decide admission target (W1/M1/M2) using competitive TinyLFU vs tails.
        - If window exceeds target, consider moving W1's LRU to M1 via TinyLFU-gated admission.
        - Maintain W2 within its target (demote W2 cold back to W1 if needed).
        - Maintain M2 within its target (demote low-freq M2 to M1).
        - Update scan detector and EMA.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update EMA of misses (miss -> 1)
        self.ema_miss = (1.0 - self.ema_alpha) * self.ema_miss + self.ema_alpha

        # Update scan detector for consecutive misses
        self.miss_streak += 1
        cap = (self.capacity or 1)
        if self.miss_streak > cap:
            self.scan_cooldown = max(self.scan_cooldown, cap // 2)
        elif self.ema_miss > 0.8 and self.miss_streak > (cap // 4):
            # EMA-based scan/phase guard
            self.scan_cooldown = max(self.scan_cooldown, cap // 2)
        else:
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere (idempotent)
        self.W1.pop(key, None)
        self.W2.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Early admission decision using TinyLFU vs candidates
        f_new = self.sketch.estimate(key)
        cand_m1 = self._sample_lru_min_freq(self.M1, now, bias=0)
        cand_m2 = self._sample_lru_min_freq(self.M2, now, bias=1)
        f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
        f_m2 = self.sketch.estimate(cand_m2) if cand_m2 is not None else -1
        bias = 3 if self.scan_cooldown > 0 else 1

        placed = False
        if self.scan_cooldown > 0:
            # Avoid polluting M2 during scans; allow M1 if new shows some heat
            if f_new >= 4:
                self._touch(self.M1, key, now)
                placed = True
        else:
            if cand_m2 is not None and f_new >= (f_m2 + bias + 1):
                self._touch(self.M2, key, now)
                placed = True
            elif cand_m1 is not None and f_new >= (f_m1 + bias):
                self._touch(self.M1, key, now)
                placed = True

        if not placed:
            # Default probationary admission
            self._touch(self.W1, key, now)

        # Rebalance window size vs target
        w_tgt, w2_tgt, _, prot_tgt = self._targets()
        # If window exceeds target, consider moving W1's LRU to M1 using TinyLFU comparison
        if (len(self.W1) + len(self.W2)) > w_tgt:
            w1_lru = self._lru(self.W1)
            if w1_lru is not None and w1_lru != key:
                cand_m1 = self._sample_lru_min_freq(self.M1, now, bias=0)
                f_w1 = self.sketch.estimate(w1_lru)
                f_m1 = self.sketch.estimate(cand_m1) if cand_m1 is not None else -1
                bias = 3 if self.scan_cooldown > 0 else 1
                if f_w1 >= (f_m1 + bias):
                    # Admit into probationary main
                    self.W1.pop(w1_lru, None)
                    self._touch(self.M1, w1_lru, now)
                else:
                    # Keep in window; refresh to avoid immediate churn
                    self._touch(self.W1, w1_lru, now)
            else:
                # If W1 empty (rare), demote a cold W2 back to W1
                demote_w2 = self._sample_lru_min_freq(self.W2, now, bias=0)
                if demote_w2 is not None:
                    self.W2.pop(demote_w2, None)
                    self._touch(self.W1, demote_w2, now)

        # Keep W2 within its target size by demoting its cold entries to W1
        while len(self.W2) > w2_tgt:
            demote_w2 = self._sample_lru_min_freq(self.W2, now, bias=0)
            if demote_w2 is None:
                break
            self.W2.pop(demote_w2, None)
            self._touch(self.W1, demote_w2, now)

        # Keep M2 within target (freq-aware demotion with M2 bias)
        while len(self.M2) > prot_tgt:
            demote = self._sample_lru_min_freq(self.M2, now, bias=1)
            if demote is None:
                break
            self.M2.pop(demote, None)
            self._touch(self.M1, demote, now)
            self.dem_m2 += 1

        # Periodically tune parameters
        self._maybe_tune(now)
>>>>>>> REPLACE
</DIFF>