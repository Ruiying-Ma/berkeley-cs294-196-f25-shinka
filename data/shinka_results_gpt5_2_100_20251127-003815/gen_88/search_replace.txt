<NAME>
dual_segment_sampling_with_scan_guard
</NAME>

<DESCRIPTION>
I replace the single-segment-biased victim selection with a dual-segment, lexicographically-scored sampling across both M1 and M2, giving M2 a bias (+1 normally, +2 during scan cooldown) so it is harder to replace than M1. This aligns the eviction decision with TinyLFU’s notion of hotness and the LRFU-decayed recency, improving protection for truly hot items while allowing new hot arrivals to replace colder main entries when justified.

I also implement a lightweight scan/phase guard using an exponential moving average (EMA) of misses. When the miss EMA exceeds a threshold, a temporary cooldown is activated that:
- increases the bias against evicting from protected M2,
- raises early promotion thresholds from the window (W) and slows promotions from M1 to M2.

Furthermore, I improve the sampling in each segment by scanning a larger tail of the LRU (4×k) and picking the coldest lexicographically by (TinyLFU estimate, decayed score), and I adapt the sampling size based on the relative usefulness of main vs. window hits.

These changes collectively reduce scan pollution, improve stability under mixed workloads, and ensure that the main set retains genuinely hot items while being receptive to hot newcomers.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "score", "last_time", "decay_base", "decay_half_life"
    )
=======
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "score", "last_time", "decay_base", "decay_half_life",
        "ema_miss", "cooldown_until", "miss_alpha"
    )
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.last_tune_time = 0
        self.tune_period = 0
        # LRFU decayed score state
        self.score = {}     # key -> float decayed score
        self.last_time = {} # key -> last access_count
        self.decay_half_life = 16
        self.decay_base = 2 ** (-1.0 / self.decay_half_life)
=======
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.last_tune_time = 0
        self.tune_period = 0
        # LRFU decayed score state
        self.score = {}     # key -> float decayed score
        self.last_time = {} # key -> last access_count
        self.decay_half_life = 16
        self.decay_base = 2 ** (-1.0 / self.decay_half_life)
        # Scan/phase guard via EMA of misses
        self.ema_miss = 0.0
        self.cooldown_until = 0
        self.miss_alpha = 0.05
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def _sample_cold_candidate(self, od: OrderedDict, now: int):
        """
        Return (key, tiny_est, decayed) for the coldest among the k LRU keys,
        using lexicographic min on (tiny_est, decayed_score).
        """
        if not od:
            return None, None, None
        k = min(self._sample_k, len(od))
        it = iter(od.keys())  # from LRU to MRU
        best_k, best_est, best_dec = None, None, None
        for _ in range(k):
            key = next(it)
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            if (best_est is None
                or est < best_est
                or (est == best_est and dec < best_dec)):
                best_k, best_est, best_dec = key, est, dec
        return best_k, best_est, best_dec
=======
    def _sample_cold_candidate(self, od: OrderedDict, now: int):
        """
        Return (key, tiny_est, decayed) for the coldest among a deeper LRU tail,
        using lexicographic min on (tiny_est, decayed_score).
        Tail length = 4 * k to better approximate the true cold region.
        """
        if not od:
            return None, None, None
        base_k = max(1, self._sample_k)
        tail = min(len(od), base_k * 4)
        it = iter(od.keys())  # from LRU to MRU
        best_k, best_est, best_dec = None, None, None
        for _ in range(tail):
            key = next(it)
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            if (best_est is None
                or est < best_est
                or (est == best_est and dec < best_dec)):
                best_k, best_est, best_dec = key, est, dec
        return best_k, best_est, best_dec
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def _maybe_tune(self, now: int):
        # Periodically adapt window size based on relative hits.
        if self.tune_period <= 0:
            return
        if (now - self.last_tune_time) >= self.tune_period:
            # If window is relatively more useful, grow it; otherwise shrink.
            if self.hits_w > self.hits_main * 1.1:
                self.win_frac = min(0.5, self.win_frac + 0.05)
            elif self.hits_main > self.hits_w * 1.1:
                self.win_frac = max(0.05, self.win_frac - 0.05)
            # Decay counters and update tune timestamp
            self.hits_w >>= 1
            self.hits_main >>= 1
            self.last_tune_time = now
=======
    def _maybe_tune(self, now: int):
        # Periodically adapt window size and sampling depth based on relative hits.
        if self.tune_period <= 0:
            return
        if (now - self.last_tune_time) >= self.tune_period:
            # If window is relatively more useful, grow it; otherwise shrink.
            if self.hits_w > self.hits_main * 1.1:
                self.win_frac = min(0.5, self.win_frac + 0.05)
            elif self.hits_main > self.hits_w * 1.1:
                self.win_frac = max(0.05, self.win_frac - 0.05)

            # Adapt sampling depth: larger when main is stable/hot-dominant.
            total = self.hits_w + self.hits_main
            if total > 0:
                main_share = self.hits_main / max(1, total)
                if main_share >= 0.7:
                    self._sample_k = min(12, max(self._sample_k, 10))
                elif main_share <= 0.4:
                    self._sample_k = max(4, min(self._sample_k, 6))
                else:
                    self._sample_k = max(6, min(10, self._sample_k))

            # Decay counters and update tune timestamp
            self.hits_w >>= 1
            self.hits_main >>= 1
            self.last_tune_time = now
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Hybrid eviction:
        - TinyLFU admission: compare f(new) to a sampled cold candidate from M1.
          * If f(new) > f(cand_M1) + bias: evict cand_M1 (admit new).
          * Else: evict W's LRU (reject new from main this round).
        - If M1 is empty, optionally compare against a cold candidate from M2
          when protected is oversized or W is empty.
        - Demotions/victim choices within segments rely on decayed scores.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Candidates
        cand_w = self._lru(self.W)
        cand_m1, f_m1, d_m1 = self._sample_cold_candidate(self.M1, now)
        cand_m2, f_m2, d_m2 = (None, None, None)
        if cand_m1 is None:
            cand_m2, f_m2, d_m2 = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)

        # Prefer replacing a cold M1 entry if new is hotter (with slight bias)
        if cand_m1 is not None and f_new > (f_m1 or 0) + 1:
            return cand_m1

        # Otherwise evict from the window to preserve main
        if cand_w is not None:
            return cand_w

        # If no window/M1 option, consider replacing a cold protected entry
        if cand_m2 is not None and f_new > (f_m2 or 0) + 2:
            return cand_m2

        # Fallbacks: evict coldest in M1 else M2 by decayed score
        if self.M1:
            k, _, _ = self._sample_cold_candidate(self.M1, now)
            if k is not None:
                return k
            return self._lru(self.M1)
        if self.M2:
            k, _, _ = self._sample_cold_candidate(self.M2, now)
            if k is not None:
                return k
            return self._lru(self.M2)

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Dual-segment, lexicographic candidate selection with scan guard:
        - Sample cold candidates from both M1 and M2 (tail_len = 4k).
        - Score candidates by (TinyLFU estimate + bias_M2, decayed score).
        - If f(new) beats the coldest main candidate: evict that candidate.
          Otherwise evict W's LRU to keep main stable.
        - During cooldown (scan), increase bias_M2 to further protect M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Candidates
        cand_w = self._lru(self.W)
        k1, f1, d1 = self._sample_cold_candidate(self.M1, now)
        k2, f2, d2 = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)
        cooldown = now < self.cooldown_until

        # Build the coldest main candidate with a bias that protects M2
        best_k = None
        best_pair = None  # (est_with_bias, decayed)
        if k1 is not None:
            pair1 = ((f1 or 0), d1 if d1 is not None else float("inf"))
            best_k, best_pair = k1, pair1
        if k2 is not None:
            bias = 2 if cooldown else 1
            pair2 = (((f2 or 0) + bias), d2 if d2 is not None else float("inf"))
            if best_pair is None or pair2 < best_pair:
                best_k, best_pair = k2, pair2

        # If we have a main candidate and new is hotter, replace it
        if best_k is not None:
            if f_new > best_pair[0] or (f_new == best_pair[0] and 0.0 > best_pair[1]):
                return best_k
            # Otherwise reject into W by evicting W's LRU if possible
            if cand_w is not None:
                return cand_w
            # If no window candidate, evict the coldest main candidate
            return best_k

        # No main candidates (unlikely): evict from window or fallback
        if cand_w is not None:
            return cand_w

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU and LRFU-decayed score.
        - W hit: refresh or early promote if sufficiently hot.
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key

        # Update TinyLFU and LRFU score
        self.sketch.increment(key, 1)
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strong frequency to avoid window churn
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            if est >= 3 or dec >= 1.5:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                # Keep protected region within target using decayed-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote, _, _ = self._sample_cold_candidate(self.M2, now)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            # Rebalance protected size if needed (decayed-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote, _, _ = self._sample_cold_candidate(self.M2, now)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
        self._maybe_tune(now)
=======
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing with scan guard:
        - Increment TinyLFU and LRFU-decayed score.
        - Update miss EMA (hit contributes 0).
        - W hit: refresh or early promote if sufficiently hot (stricter under cooldown).
        - M1 hit: promote to M2 (can be gated under cooldown by minimal frequency).
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm; under cooldown prefer M1 unless clearly hot.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key

        # Update TinyLFU and LRFU score
        self.sketch.increment(key, 1)
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        # Update EMA (hit -> 0) and determine cooldown
        self.ema_miss = (1.0 - self.miss_alpha) * self.ema_miss
        cooldown = now < self.cooldown_until

        if key in self.W:
            self.hits_w += 1
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            # Early promotion thresholds: stricter during cooldown to avoid scan pollution
            if (not cooldown and (est >= 3 or dec >= 1.5)) or (cooldown and (est >= 4 and dec >= 2.0)):
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                # Keep protected region within target using decayed-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote, _, _ = self._sample_cold_candidate(self.M2, now)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            est = self.sketch.estimate(key)
            # Under cooldown, require minimal frequency before promoting to M2
            if cooldown and est < 2:
                self._touch(self.M1, key)
            else:
                self.M1.pop(key, None)
                self._touch(self.M2, key)
                # Rebalance protected size if needed (decayed-aware demotion)
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote, _, _ = self._sample_cold_candidate(self.M2, now)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm, but be conservative during cooldown
        self.hits_main += 1
        est = self.sketch.estimate(key)
        if cooldown and est < 3:
            self._touch(self.M1, key)
        else:
            self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Initialize LRFU metadata modestly (to reduce scan pollution).
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - If W exceeds target, move W's LRU to main probationary (M1).
        - Keep protected region within target by demoting a decayed-cold entry if needed.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Initialize decayed metadata
        self.last_time[key] = now
        self.score[key] = 0.5

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, move W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                self.W.pop(w_lru, None)
                # Move into M1 probationary
                self._touch(self.M1, w_lru)

        # Keep protected region within target (decayed-aware demotion)
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)

        # Periodically tune window size
        self._maybe_tune(now)
=======
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing with scan guard:
        - Initialize LRFU metadata modestly (to reduce scan pollution).
        - Increment TinyLFU and update miss EMA (miss contributes 1).
        - Insert new key into window W (MRU).
        - If W exceeds target, move W's LRU to main probationary (M1).
        - Keep protected region within target by demoting a decayed-cold entry if needed.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Update EMA (miss -> 1) and activate cooldown if scans detected
        self.ema_miss = (1.0 - self.miss_alpha) * self.ema_miss + self.miss_alpha * 1.0
        if self.ema_miss > 0.85:
            # Set/extend cooldown for a short horizon to protect M2 during scans
            self.cooldown_until = max(self.cooldown_until, now + self.capacity * 2)

        # Initialize decayed metadata
        self.last_time[key] = now
        self.score[key] = 0.5

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, move W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                self.W.pop(w_lru, None)
                # Move into M1 probationary
                self._touch(self.M1, w_lru)

        # Keep protected region within target (decayed-aware demotion)
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)

        # Periodically tune window size
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>