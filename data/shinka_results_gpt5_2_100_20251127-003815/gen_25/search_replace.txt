<NAME>
scan_aware_admission_and_bias
</NAME>

<DESCRIPTION>
The current hybrid W-TinyLFU + LRFU-decayed SLRU performs reasonably well, but it suffers on scan-heavy or low-reuse traces where cold items pollute the main segments and premature promotions occur. To mitigate this, I add a lightweight scan detector using a miss_streak counter and a scan_cooldown window. During cooldown:
- Increase TinyLFU admission bias so that new/cold items are less likely to replace main entries.
- Prefer evicting from the window W and slow down promotions from W to M2 to avoid overprotection of one-timers.
- Gate the Wâ†’M1 movement based on TinyLFU scores, reducing pollution in the probationary segment.

Additionally, early promotion from W to M2 is made stricter during scan cooldown. I also add dynamic biasing in choose_victim and decrement cooldown progressively.

These targeted changes leverage TinyLFU for admission and LRFU-decayed scores for in-segment selections, while adding minimal overhead. The result should reduce cache misses on scan-like workloads without regressing steady-state locality, improving the combined score.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "score", "last_time", "decay_base", "decay_half_life"
    )
=======
    __slots__ = (
        "W", "M1", "M2", "capacity",
        "win_frac", "prot_frac", "sketch", "_sample_k",
        "hits_w", "hits_main", "last_tune_time", "tune_period",
        "score", "last_time", "decay_base", "decay_half_life",
        "miss_streak", "scan_cooldown"
    )
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.last_tune_time = 0
        self.tune_period = 0
        # LRFU decayed score state
        self.score = {}     # key -> float decayed score
        self.last_time = {} # key -> last access_count
        self.decay_half_life = 16
        self.decay_base = 2 ** (-1.0 / self.decay_half_life)
=======
    def __init__(self):
        self.W = OrderedDict()
        self.M1 = OrderedDict()
        self.M2 = OrderedDict()
        self.capacity = None
        # Targets as fractions of capacity
        self.win_frac = 0.2   # 20% window
        self.prot_frac = 0.8  # 80% of main reserved for protected
        self.sketch = _CmSketch(width_power=12, d=3)
        self._sample_k = 6
        # Adaptive tuning state
        self.hits_w = 0
        self.hits_main = 0
        self.last_tune_time = 0
        self.tune_period = 0
        # LRFU decayed score state
        self.score = {}     # key -> float decayed score
        self.last_time = {} # key -> last access_count
        self.decay_half_life = 16
        self.decay_base = 2 ** (-1.0 / self.decay_half_life)
        # Scan detection state
        self.miss_streak = 0
        self.scan_cooldown = 0
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Hybrid eviction:
        - TinyLFU admission: compare f(new) to a sampled cold candidate from M1.
          * If f(new) > f(cand_M1) + bias: evict cand_M1 (admit new).
          * Else: evict W's LRU (reject new from main this round).
        - If M1 is empty, optionally compare against a cold candidate from M2
          when protected is oversized or W is empty.
        - Demotions/victim choices within segments rely on decayed scores.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Candidates
        cand_w = self._lru(self.W)
        cand_m1, f_m1, d_m1 = self._sample_cold_candidate(self.M1, now)
        cand_m2, f_m2, d_m2 = (None, None, None)
        if cand_m1 is None:
            cand_m2, f_m2, d_m2 = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)

        # Prefer replacing a cold M1 entry if new is hotter (with slight bias)
        if cand_m1 is not None and f_new > (f_m1 or 0) + 1:
            return cand_m1

        # Otherwise evict from the window to preserve main
        if cand_w is not None:
            return cand_w

        # If no window/M1 option, consider replacing a cold protected entry
        if cand_m2 is not None and f_new > (f_m2 or 0) + 2:
            return cand_m2

        # Fallbacks: evict coldest in M1 else M2 by decayed score
        if self.M1:
            k, _, _ = self._sample_cold_candidate(self.M1, now)
            if k is not None:
                return k
            return self._lru(self.M1)
        if self.M2:
            k, _, _ = self._sample_cold_candidate(self.M2, now)
            if k is not None:
                return k
            return self._lru(self.M2)

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
=======
    def choose_victim(self, cache_snapshot, new_obj) -> str:
        """
        Hybrid eviction with scan-aware bias:
        - TinyLFU admission: compare f(new) to a sampled cold candidate from M1.
          * If f(new) > f(cand_M1) + bias: evict cand_M1 (admit new).
          * Else: evict W's LRU (reject new from main this round).
        - If M1 is empty, compare against a cold candidate from M2 with stronger bias.
        - During scan cooldown, increase bias and prefer evicting from W.
        - Demotions/victim choices within segments rely on decayed scores.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        self._self_heal(cache_snapshot)

        now = cache_snapshot.access_count

        # Cool down scan bias gradually on each eviction decision
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        w_tgt, _, _ = self._targets()

        # If window is already at/over target, free space by evicting window LRU
        if len(self.W) >= w_tgt and self.W:
            return self._lru(self.W)

        # Candidates
        cand_w = self._lru(self.W)
        cand_m1, f_m1, _ = self._sample_cold_candidate(self.M1, now)
        cand_m2, f_m2, _ = (None, None, None)
        if cand_m1 is None:
            cand_m2, f_m2, _ = self._sample_cold_candidate(self.M2, now)

        f_new = self.sketch.estimate(new_obj.key)
        bias = 3 if self.scan_cooldown > 0 else 1

        # Prefer replacing a cold M1 entry if new is hotter (with bias)
        if cand_m1 is not None and f_new > (f_m1 or 0) + bias:
            return cand_m1

        # Otherwise evict from the window to preserve main
        if cand_w is not None:
            return cand_w

        # If no window/M1 option, consider replacing a cold protected entry (stronger bias)
        if cand_m2 is not None and f_new > (f_m2 or 0) + (bias + 1):
            return cand_m2

        # Fallbacks: evict coldest in M1 else M2 by decayed score
        if self.M1:
            k, _, _ = self._sample_cold_candidate(self.M1, now)
            if k is not None:
                return k
            return self._lru(self.M1)
        if self.M2:
            k, _, _ = self._sample_cold_candidate(self.M2, now)
            if k is not None:
                return k
            return self._lru(self.M2)

        # Last resort: pick any key from cache
        return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU and LRFU-decayed score.
        - W hit: refresh or early promote if sufficiently hot.
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key

        # Update TinyLFU and LRFU score
        self.sketch.increment(key, 1)
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strong frequency to avoid window churn
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            if est >= 3 or dec >= 1.5:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                # Keep protected region within target using decayed-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote, _, _ = self._sample_cold_candidate(self.M2, now)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            # Rebalance protected size if needed (decayed-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote, _, _ = self._sample_cold_candidate(self.M2, now)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
        self._maybe_tune(now)
=======
    def on_hit(self, cache_snapshot, obj):
        """
        Hit processing:
        - Increment TinyLFU and LRFU-decayed score.
        - W hit: refresh or early promote if sufficiently hot (stricter during scan).
        - M1 hit: promote to M2.
        - M2 hit: refresh in M2.
        - If untracked but hit (desync): treat as warm and place into M2.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key

        # Update TinyLFU and LRFU score
        self.sketch.increment(key, 1)
        s = self._decayed_score(key, now)
        self.score[key] = s + 1.0

        # Any hit breaks a miss streak and cools scan bias slightly
        self.miss_streak = 0
        if self.scan_cooldown > 0:
            self.scan_cooldown -= 1

        if key in self.W:
            self.hits_w += 1
            # Early promotion if strong frequency to avoid window churn
            est = self.sketch.estimate(key)
            dec = self._decayed_score(key, now)
            thr_est = 4 if self.scan_cooldown > 0 else 3
            thr_dec = 2.0 if self.scan_cooldown > 0 else 1.5
            if est >= thr_est or dec >= thr_dec:
                # Move from window to protected
                self.W.pop(key, None)
                self._touch(self.M2, key)
                # Keep protected region within target using decayed-aware demotion
                _, _, prot_tgt = self._targets()
                if len(self.M2) > prot_tgt:
                    demote, _, _ = self._sample_cold_candidate(self.M2, now)
                    if demote is not None:
                        self.M2.pop(demote, None)
                        self._touch(self.M1, demote)
            else:
                self._touch(self.W, key)
            self._maybe_tune(now)
            return

        if key in self.M1:
            self.hits_main += 1
            # Promote to protected
            self.M1.pop(key, None)
            self._touch(self.M2, key)
            # Rebalance protected size if needed (decayed-aware demotion)
            _, _, prot_tgt = self._targets()
            if len(self.M2) > prot_tgt:
                demote, _, _ = self._sample_cold_candidate(self.M2, now)
                if demote is not None:
                    self.M2.pop(demote, None)
                    self._touch(self.M1, demote)
            self._maybe_tune(now)
            return

        if key in self.M2:
            self.hits_main += 1
            self._touch(self.M2, key)
            self._maybe_tune(now)
            return

        # Desync: assume it's warm
        self.hits_main += 1
        self._touch(self.M2, key)
        _, _, prot_tgt = self._targets()
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Initialize LRFU metadata modestly (to reduce scan pollution).
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - If W exceeds target, move W's LRU to main probationary (M1).
        - Keep protected region within target by demoting a decayed-cold entry if needed.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Initialize decayed metadata
        self.last_time[key] = now
        self.score[key] = 0.5

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, move W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                self.W.pop(w_lru, None)
                # Move into M1 probationary
                self._touch(self.M1, w_lru)

        # Keep protected region within target (decayed-aware demotion)
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)

        # Periodically tune window size
        self._maybe_tune(now)
=======
    def on_insert(self, cache_snapshot, obj):
        """
        Insert (on miss) processing:
        - Initialize LRFU metadata modestly (to reduce scan pollution).
        - Increment TinyLFU.
        - Insert new key into window W (MRU).
        - If W exceeds target, TinyLFU-gated move of W's LRU to M1 (admission path).
        - Keep protected region within target by demoting a decayed-cold entry if needed.
        - Maintain scan detector state.
        """
        self._ensure_capacity(cache_snapshot.capacity)
        now = cache_snapshot.access_count
        key = obj.key
        self.sketch.increment(key, 1)

        # Initialize decayed metadata
        self.last_time[key] = now
        self.score[key] = 0.5

        # Update scan detector: count consecutive misses
        self.miss_streak += 1
        if self.miss_streak > (self.capacity or 1):
            # Enter/extend scan-biased cooldown
            self.scan_cooldown = max(self.scan_cooldown, self.capacity or 1)
        else:
            # Gradually cool down if not clearly scanning
            if self.scan_cooldown > 0:
                self.scan_cooldown -= 1

        # Ensure it's not tracked elsewhere
        self.W.pop(key, None)
        self.M1.pop(key, None)
        self.M2.pop(key, None)

        # Insert into window
        self._touch(self.W, key)

        # Rebalance: if W is beyond target, TinyLFU-gated move of W's LRU to M1 (admission path)
        w_tgt, _, prot_tgt = self._targets()
        if len(self.W) > w_tgt:
            w_lru = self._lru(self.W)
            if w_lru is not None and w_lru != key:
                cand_m1, f_m1, _ = self._sample_cold_candidate(self.M1, now)
                f_w = self.sketch.estimate(w_lru)
                bias = 3 if self.scan_cooldown > 0 else 1
                # Admit into M1 only if at least as hot as a cold M1 candidate (with bias)
                if f_w >= (f_m1 or 0) + bias:
                    self.W.pop(w_lru, None)
                    self._touch(self.M1, w_lru)
                else:
                    # Keep in window; refresh to MRU to avoid immediate churn
                    self._touch(self.W, w_lru)

        # Keep protected region within target (decayed-aware demotion)
        if len(self.M2) > prot_tgt:
            demote, _, _ = self._sample_cold_candidate(self.M2, now)
            if demote is not None:
                self.M2.pop(demote, None)
                self._touch(self.M1, demote)

        # Periodically tune window size
        self._maybe_tune(now)
>>>>>>> REPLACE

</DIFF>