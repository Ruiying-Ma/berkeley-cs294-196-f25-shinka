<NAME>
tune_wtinylfu_params
</NAME>

<DESCRIPTION>
1. Increase frequency cap from 15 to 60 to provide better resolution for distinguishing hot items.
2. In `evict`, increase the "cold" threshold for Main items from 5 to 10 to scale with the frequency cap (protecting Main items slightly less aggressively against Window growth).
3. In `evict`, change the duel tie-breaker to `fw >= fm` (prefer Window/Recent). This favors replacing stale Main items with new Window items of equal frequency, which helps with looping patterns and responsiveness to workload changes.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    '''
    W-TinyLFU Eviction Logic
    '''
    window = algo_state['window']
    probation = algo_state['probation']
    protected = algo_state['protected']
    freq = algo_state['freq']

    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.05)) # 5% Window

    # Candidates
    candidate_w = next(iter(window)) if window else None

    # Main Candidate: Probation LRU, else Protected LRU
    candidate_m = None
    if probation:
        candidate_m = next(iter(probation))
    elif protected:
        candidate_m = next(iter(protected))

    victim = None

    # Frequency scores
    fw = freq.get(candidate_w, 0) if candidate_w else 0
    fm = freq.get(candidate_m, 0) if candidate_m else 0

    # 1. If Window needs space (is below target), grow it by evicting Main
    # Condition: Only evict Main if it's not "hot" (freq <= 5).
    # If Main is hot, we skip this and duel, which Main likely wins, thus suppressing Window growth
    # to protect heavy hitters.
    if len(window) < w_cap and candidate_m and fm <= 5:
        victim = candidate_m
    elif not candidate_m:
        victim = candidate_w
    elif not candidate_w:
        victim = candidate_m
    else:
        # 2. Window is full or Main is Hot. Duel.
        # Tie-breaker: Prefer Main (Incumbent) -> Evict Window
        # This provides scan and loop resistance
        if fw > fm:
            victim = candidate_m
        else:
            victim = candidate_w

    return victim
=======
def evict(cache_snapshot, obj):
    '''
    W-TinyLFU Eviction Logic
    '''
    window = algo_state['window']
    probation = algo_state['probation']
    protected = algo_state['protected']
    freq = algo_state['freq']

    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.05)) # 5% Window

    # Candidates
    candidate_w = next(iter(window)) if window else None

    # Main Candidate: Probation LRU, else Protected LRU
    candidate_m = None
    if probation:
        candidate_m = next(iter(probation))
    elif protected:
        candidate_m = next(iter(protected))

    victim = None

    # Frequency scores
    fw = freq.get(candidate_w, 0) if candidate_w else 0
    fm = freq.get(candidate_m, 0) if candidate_m else 0

    # 1. If Window needs space (is below target), grow it by evicting Main
    # Condition: Only evict Main if it's not "hot" (freq <= 10).
    # If Main is hot, we skip this and duel, which Main likely wins, thus suppressing Window growth
    # to protect heavy hitters.
    if len(window) < w_cap and candidate_m and fm <= 10:
        victim = candidate_m
    elif not candidate_m:
        victim = candidate_w
    elif not candidate_w:
        victim = candidate_m
    else:
        # 2. Window is full or Main is Hot. Duel.
        # Tie-breaker: Prefer Window (Newer) -> Evict Main
        # This helps with loops and churning workloads where recent items are more valuable
        if fw >= fm:
            victim = candidate_m
        else:
            victim = candidate_w

    return victim
>>>>>>> REPLACE
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    _check_reset(cache_snapshot.access_count)
    key = obj.key
    window = algo_state['window']
    probation = algo_state['probation']
    protected = algo_state['protected']
    freq = algo_state['freq']
    dk = algo_state['doorkeeper']

    # Frequency with Doorkeeper and Cap
    if key in freq:
        freq[key] = min(freq[key] + 1, 15)
    elif key in dk:
        freq[key] = 1
        del dk[key]
=======
def update_after_hit(cache_snapshot, obj):
    _check_reset(cache_snapshot.access_count)
    key = obj.key
    window = algo_state['window']
    probation = algo_state['probation']
    protected = algo_state['protected']
    freq = algo_state['freq']
    dk = algo_state['doorkeeper']

    # Frequency with Doorkeeper and Cap
    if key in freq:
        freq[key] = min(freq[key] + 1, 60)
    elif key in dk:
        freq[key] = 1
        del dk[key]
>>>>>>> REPLACE
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    _check_reset(cache_snapshot.access_count)
    key = obj.key
    freq = algo_state['freq']
    dk = algo_state['doorkeeper']

    # Frequency with Doorkeeper and Cap
    if key in freq:
        freq[key] = min(freq[key] + 1, 15)
    elif key in dk:
        freq[key] = 1
        del dk[key]
=======
def update_after_insert(cache_snapshot, obj):
    _check_reset(cache_snapshot.access_count)
    key = obj.key
    freq = algo_state['freq']
    dk = algo_state['doorkeeper']

    # Frequency with Doorkeeper and Cap
    if key in freq:
        freq[key] = min(freq[key] + 1, 60)
    elif key in dk:
        freq[key] = 1
        del dk[key]
>>>>>>> REPLACE
</DIFF>