--- a/original.py
+++ b/original.py
@@ -1,171 +1,162 @@
 # EVOLVE-BLOCK-START
 """Cache eviction algorithm for optimizing hit rates across multiple workloads"""
 from collections import OrderedDict
 
-# W-TinyLFU inspired State
+# LIRS State
 algo_state = {
-    'window': OrderedDict(),    # Window Cache (SLRU or LRU)
-    'probation': OrderedDict(), # Main Cache - Probation (SLRU)
-    'protected': OrderedDict(), # Main Cache - Protected (SLRU)
-    'freq': {},                 # Frequency Counter
-    'freq_count': 0,            # Total increments for reset
+    'S': OrderedDict(),       # Stack S: Key -> Type ('LIR' or 'HIR')
+    'Q': OrderedDict(),       # Queue Q: Key -> None (Resident HIR)
+    'non_resident': set(),    # Set of keys in S but not in cache (Non-resident HIR)
+    'LIR_count': 0,           # Number of LIR entries
     'max_time': 0
 }
 
 def _check_reset(current_time):
     if current_time < algo_state['max_time']:
-        algo_state['window'].clear()
-        algo_state['probation'].clear()
-        algo_state['protected'].clear()
-        algo_state['freq'].clear()
-        algo_state['freq_count'] = 0
+        algo_state['S'].clear()
+        algo_state['Q'].clear()
+        algo_state['non_resident'].clear()
+        algo_state['LIR_count'] = 0
         algo_state['max_time'] = 0
     algo_state['max_time'] = current_time
 
+def _prune_stack():
+    S = algo_state['S']
+    nr = algo_state['non_resident']
+    # Remove HIRs from bottom of S
+    while S:
+        k, status = next(iter(S.items()))
+        if status == 'LIR':
+            break
+        # It's HIR.
+        if k in nr:
+            nr.remove(k)
+        S.popitem(last=False) # Remove from bottom
+
 def evict(cache_snapshot, obj):
     '''
-    W-TinyLFU Eviction Logic
+    LIRS Eviction:
+    Evict from Q (Resident HIR).
+    If Q empty, evict from LIR (demote first).
     '''
-    window = algo_state['window']
-    probation = algo_state['probation']
-    protected = algo_state['protected']
-    freq = algo_state['freq']
-
-    capacity = cache_snapshot.capacity
-    w_cap = max(1, int(capacity * 0.05)) # 5% Window
-
-    # Candidates
-    candidate_w = next(iter(window)) if window else None
-
-    # Main Candidate: Probation LRU, else Protected LRU
-    candidate_m = None
-    if probation:
-        candidate_m = next(iter(probation))
-    elif protected:
-        candidate_m = next(iter(protected))
+    Q = algo_state['Q']
+    S = algo_state['S']
 
     victim = None
-
-    # 1. If Window needs space (is below target), grow it by evicting Main
-    # (Unless Main is empty, then evict Window)
-    if len(window) < w_cap and candidate_m:
-        victim = candidate_m
-    elif not candidate_m:
-        victim = candidate_w
-    elif not candidate_w:
-        victim = candidate_m
+    if Q:
+        victim = next(iter(Q))
     else:
-        # 2. Window is full. Duel.
-        # Compare frequency
-        fw = freq.get(candidate_w, 0)
-        fm = freq.get(candidate_m, 0)
-
-        # Tie-breaker: Prefer Main (Incumbent) -> Evict Window
-        # This provides scan and loop resistance
-        if fw > fm:
-            victim = candidate_m
-        else:
-            victim = candidate_w
+        # Q is empty, evict bottom LIR
+        if S:
+            victim, _ = next(iter(S.items()))
 
     return victim
 
 def update_after_hit(cache_snapshot, obj):
     _check_reset(cache_snapshot.access_count)
     key = obj.key
-    window = algo_state['window']
-    probation = algo_state['probation']
-    protected = algo_state['protected']
-    freq = algo_state['freq']
+    S = algo_state['S']
+    Q = algo_state['Q']
 
-    # Frequency
-    freq[key] = freq.get(key, 0) + 1
-    algo_state['freq_count'] += 1
-    if algo_state['freq_count'] >= cache_snapshot.capacity * 10:
-        to_remove = []
-        for k in freq:
-            freq[k] //= 2
-            if freq[k] == 0: to_remove.append(k)
-        for k in to_remove: del freq[k]
-        algo_state['freq_count'] = 0
+    # Check if in Q (Resident HIR)
+    if key in Q:
+        # Resident HIR
+        if key in S:
+            # Hot HIR -> Promote to LIR
+            del Q[key]
+            S.move_to_end(key)
+            S[key] = 'LIR'
+            algo_state['LIR_count'] += 1
 
-    # Cache Maintenance
-    if key in window:
-        window.move_to_end(key)
-    elif key in protected:
-        protected.move_to_end(key)
-    elif key in probation:
-        # Promote
-        del probation[key]
-        protected[key] = None
-
-        # Enforce Protected Limit
-        w_cap = max(1, int(cache_snapshot.capacity * 0.05))
-        m_cap = cache_snapshot.capacity - w_cap
-        p_cap = int(m_cap * 0.8) # 80% of Main
-
-        while len(protected) > p_cap:
-            k, _ = protected.popitem(last=False)
-            probation[k] = None # Move to Probation MRU
-            probation.move_to_end(k)
+            # Enforce LIR capacity
+            target_lir = max(1, int(cache_snapshot.capacity * 0.99))
+            if algo_state['LIR_count'] > target_lir:
+                 _prune_stack()
+                 if S:
+                     k, status = next(iter(S.items()))
+                     if status == 'LIR':
+                         S[k] = 'HIR'
+                         Q[k] = None
+                         algo_state['LIR_count'] -= 1
+                         _prune_stack()
+        else:
+            # Cold HIR -> Update recency, stays HIR
+            S[key] = 'HIR'
+            Q.move_to_end(key)
+    else:
+        # LIR hit
+        if key in S:
+            S.move_to_end(key)
+            _prune_stack()
+        else:
+            # Should be in S if LIR. Edge case recovery.
+            S[key] = 'LIR'
+            S.move_to_end(key)
 
 def update_after_insert(cache_snapshot, obj):
     _check_reset(cache_snapshot.access_count)
     key = obj.key
-    freq = algo_state['freq']
+    S = algo_state['S']
+    Q = algo_state['Q']
+    nr = algo_state['non_resident']
 
-    # Frequency
-    freq[key] = freq.get(key, 0) + 1
-    algo_state['freq_count'] += 1
-    if algo_state['freq_count'] >= cache_snapshot.capacity * 10:
-        to_remove = []
-        for k in freq:
-            freq[k] //= 2
-            if freq[k] == 0: to_remove.append(k)
-        for k in to_remove: del freq[k]
-        algo_state['freq_count'] = 0
+    if key in S:
+        # Was Non-Resident HIR -> Promote to LIR
+        if key in nr: nr.remove(key)
 
-    # Insert to Window MRU
-    algo_state['window'][key] = None
+        S.move_to_end(key)
+        S[key] = 'LIR'
+        algo_state['LIR_count'] += 1
+
+        target_lir = max(1, int(cache_snapshot.capacity * 0.99))
+        if algo_state['LIR_count'] > target_lir:
+             _prune_stack()
+             if S:
+                 k, status = next(iter(S.items()))
+                 if status == 'LIR':
+                     S[k] = 'HIR'
+                     Q[k] = None
+                     algo_state['LIR_count'] -= 1
+                     _prune_stack()
+    else:
+        # New item -> Resident HIR
+        S[key] = 'HIR'
+        Q[key] = None # Insert at end (MRU) of Q
 
 def update_after_evict(cache_snapshot, obj, evicted_obj):
     v_key = evicted_obj.key
-    window = algo_state['window']
-    probation = algo_state['probation']
-    protected = algo_state['protected']
+    S = algo_state['S']
+    Q = algo_state['Q']
+    nr = algo_state['non_resident']
 
-    if v_key in window:
-        del window[v_key]
-    elif v_key in probation:
-        del probation[v_key]
-    elif v_key in protected:
-        del protected[v_key]
+    if v_key in Q:
+        del Q[v_key]
 
-    # Check for Window promotion
-    # If we evicted Main, and Window is now > Cap (it wasn't evicted), move Window LRU to Probation
-    w_cap = max(1, int(cache_snapshot.capacity * 0.05))
-    if len(window) > w_cap:
-        k, _ = window.popitem(last=False)
-        probation[k] = None # To Probation MRU
-        probation.move_to_end(k)
+    if v_key in S:
+        if S[v_key] == 'LIR':
+             algo_state['LIR_count'] -= 1
+        S[v_key] = 'HIR'
+        nr.add(v_key)
+        _prune_stack()
 
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate