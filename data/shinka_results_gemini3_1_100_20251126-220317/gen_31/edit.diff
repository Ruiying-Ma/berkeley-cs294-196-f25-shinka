--- a/original.py
+++ b/original.py
@@ -1,198 +1,197 @@
 # EVOLVE-BLOCK-START
 """Cache eviction algorithm for optimizing hit rates across multiple workloads"""
 from collections import OrderedDict
 
-# W-TinyLFU inspired State
+# Advanced W-TinyLFU with Doorkeeper and FIFO Window (S3-FIFO elements)
 algo_state = {
-    'window': OrderedDict(),    # Window Cache (SLRU or LRU)
+    'window': OrderedDict(),    # Window Cache (FIFO)
+    'window_hits': set(),       # Track hits in window
     'probation': OrderedDict(), # Main Cache - Probation (SLRU)
     'protected': OrderedDict(), # Main Cache - Protected (SLRU)
     'freq': {},                 # Frequency Counter
-    'doorkeeper': set(),        # Doorkeeper for one-hit wonders
-    'freq_count': 0,            # Total increments for reset
+    'doorkeeper': set(),        # Doorkeeper
+    'freq_count': 0,            # Aging counter
     'max_time': 0
 }
 
 def _check_reset(current_time):
     if current_time < algo_state['max_time']:
         algo_state['window'].clear()
+        algo_state['window_hits'].clear()
         algo_state['probation'].clear()
         algo_state['protected'].clear()
         algo_state['freq'].clear()
         algo_state['doorkeeper'].clear()
         algo_state['freq_count'] = 0
         algo_state['max_time'] = 0
     algo_state['max_time'] = current_time
 
 def evict(cache_snapshot, obj):
     '''
-    W-TinyLFU Eviction Logic with Doorkeeper Support
+    Eviction Logic:
+    - Window acts as a FIFO filter.
+    - If Window tail was hit -> Promote to Main.
+    - If Window tail was NOT hit -> Duel vs Main Victim (Probation/Protected).
+    - Uses Doorkeeper to filter one-hit wonders.
     '''
     window = algo_state['window']
+    window_hits = algo_state['window_hits']
     probation = algo_state['probation']
     protected = algo_state['protected']
     freq = algo_state['freq']
     doorkeeper = algo_state['doorkeeper']
 
     capacity = cache_snapshot.capacity
-    w_cap = max(1, int(capacity * 0.05)) # 5% Window
+    w_cap = max(1, int(capacity * 0.10)) # 10% Window
+
+    # Lazy Promotion from Window: Process hits at tail
+    while len(window) > w_cap:
+        cand_key = next(iter(window))
+        if cand_key in window_hits:
+            window.popitem(last=False)
+            window_hits.remove(cand_key)
+            probation[cand_key] = None # Promote to Probation MRU
+        else:
+            break
 
     # Candidates
-    candidate_w = next(iter(window)) if window else None
+    cand_w = next(iter(window)) if window else None
 
-    # Main Candidate: Probation LRU, else Protected LRU
-    candidate_m = None
+    cand_m = None
     if probation:
-        candidate_m = next(iter(probation))
+        cand_m = next(iter(probation))
     elif protected:
-        candidate_m = next(iter(protected))
+        cand_m = next(iter(protected))
 
-    victim = None
+    # 1. Prefer evicting from Main if Window is small (to allow Window to grow)
+    # But only if Main has items.
+    if len(window) < w_cap and cand_m:
+        return cand_m
+    elif not cand_w:
+        return cand_m
+    elif not cand_m:
+        return cand_w
 
-    # 1. If Window needs space (is below target), grow it by evicting Main
-    # (Unless Main is empty, then evict Window)
-    if len(window) < w_cap and candidate_m:
-        victim = candidate_m
-    elif not candidate_m:
-        victim = candidate_w
-    elif not candidate_w:
-        victim = candidate_m
+    # 2. Duel: Window (unhit tail) vs Main
+    def get_freq(k):
+        if k in freq: return freq[k]
+        if k in doorkeeper: return 1
+        return 0
+
+    fw = get_freq(cand_w)
+    fm = get_freq(cand_m)
+
+    # Bias towards Main (Incumbent)
+    if fw > fm:
+        # Window wins (High Freq). Promote to Main. Evict Main victim.
+        window.popitem(last=False)
+        window_hits.discard(cand_w)
+        probation[cand_w] = None
+        return cand_m
     else:
-        # 2. Window is full. Duel.
-        # Helper to get frequency
-        def get_freq(k):
-            if k in freq: return freq[k]
-            if k in doorkeeper: return 1
-            return 0
-
-        fw = get_freq(candidate_w)
-        fm = get_freq(candidate_m)
-
-        # Tie-breaker: Prefer Main (Incumbent) -> Evict Window
-        if fw > fm:
-            victim = candidate_m
-        else:
-            victim = candidate_w
-
-    return victim
+        # Window loses.
+        return cand_w
 
 def update_after_hit(cache_snapshot, obj):
     _check_reset(cache_snapshot.access_count)
     key = obj.key
-    window = algo_state['window']
-    probation = algo_state['probation']
-    protected = algo_state['protected']
-    freq = algo_state['freq']
-    doorkeeper = algo_state['doorkeeper']
+    state = algo_state
 
-    # Frequency Aging
-    algo_state['freq_count'] += 1
-    if algo_state['freq_count'] >= cache_snapshot.capacity * 5:
-        doorkeeper.clear()
-        to_remove = []
-        for k in freq:
-            freq[k] //= 2
-            if freq[k] == 0: to_remove.append(k)
-        for k in to_remove: del freq[k]
-        algo_state['freq_count'] = 0
+    # Frequency Aging (Accelerated: 1 * Capacity)
+    state['freq_count'] += 1
+    if state['freq_count'] >= cache_snapshot.capacity:
+        state['doorkeeper'].clear()
+        state['freq'] = {k: v // 2 for k, v in state['freq'].items() if v > 1}
+        state['freq_count'] = 0
 
     # Frequency Update
-    if key in freq:
-        freq[key] = min(freq[key] + 1, 15)
-    elif key in doorkeeper:
-        freq[key] = 2
-        doorkeeper.remove(key)
+    f = state['freq']
+    dk = state['doorkeeper']
+    if key in f:
+        f[key] = min(f[key] + 1, 15)
+    elif key in dk:
+        f[key] = 2
+        dk.remove(key)
     else:
-        doorkeeper.add(key)
+        dk.add(key)
 
     # Cache Maintenance
-    if key in window:
-        window.move_to_end(key)
-    elif key in protected:
-        protected.move_to_end(key)
-    elif key in probation:
-        # Promote
-        del probation[key]
-        protected[key] = None
+    if key in state['window']:
+        state['window_hits'].add(key)
+        # FIFO Window: DO NOT move to end
+    elif key in state['protected']:
+        state['protected'].move_to_end(key)
+    elif key in state['probation']:
+        # Promote to Protected
+        del state['probation'][key]
+        state['protected'][key] = None
 
-        # Enforce Protected Limit
-        w_cap = max(1, int(cache_snapshot.capacity * 0.05))
-        m_cap = cache_snapshot.capacity - w_cap
-        p_cap = int(m_cap * 0.8) # 80% of Main
+        # Enforce Protected Limit (80% of Main)
+        w_cap = max(1, int(cache_snapshot.capacity * 0.10))
+        m_cap = max(1, cache_snapshot.capacity - w_cap)
+        p_cap = int(m_cap * 0.8)
 
-        while len(protected) > p_cap:
-            k, _ = protected.popitem(last=False)
-            probation[k] = None # Move to Probation MRU
-            probation.move_to_end(k)
+        while len(state['protected']) > p_cap:
+            k, _ = state['protected'].popitem(last=False)
+            state['probation'][k] = None
+            state['probation'].move_to_end(k)
 
 def update_after_insert(cache_snapshot, obj):
     _check_reset(cache_snapshot.access_count)
     key = obj.key
-    freq = algo_state['freq']
-    doorkeeper = algo_state['doorkeeper']
+    state = algo_state
 
     # Frequency Aging
-    algo_state['freq_count'] += 1
-    if algo_state['freq_count'] >= cache_snapshot.capacity * 5:
-        doorkeeper.clear()
-        to_remove = []
-        for k in freq:
-            freq[k] //= 2
-            if freq[k] == 0: to_remove.append(k)
-        for k in to_remove: del freq[k]
-        algo_state['freq_count'] = 0
+    state['freq_count'] += 1
+    if state['freq_count'] >= cache_snapshot.capacity:
+        state['doorkeeper'].clear()
+        state['freq'] = {k: v // 2 for k, v in state['freq'].items() if v > 1}
+        state['freq_count'] = 0
 
     # Frequency Update
-    if key in freq:
-        freq[key] = min(freq[key] + 1, 15)
-    elif key in doorkeeper:
-        freq[key] = 2
-        doorkeeper.remove(key)
+    f = state['freq']
+    dk = state['doorkeeper']
+    if key in f:
+        f[key] = min(f[key] + 1, 15)
+    elif key in dk:
+        f[key] = 2
+        dk.remove(key)
     else:
-        doorkeeper.add(key)
+        dk.add(key)
 
-    # Insert to Window MRU
-    algo_state['window'][key] = None
+    # Insert to Window (FIFO)
+    state['window'][key] = None
 
 def update_after_evict(cache_snapshot, obj, evicted_obj):
     v_key = evicted_obj.key
-    window = algo_state['window']
-    probation = algo_state['probation']
-    protected = algo_state['protected']
+    state = algo_state
 
-    if v_key in window:
-        del window[v_key]
-    elif v_key in probation:
-        del probation[v_key]
-    elif v_key in protected:
-        del protected[v_key]
-
-    # Check for Window promotion
-    # If we evicted Main, and Window is now > Cap (it wasn't evicted), move Window LRU to Probation
-    w_cap = max(1, int(cache_snapshot.capacity * 0.05))
-    if len(window) > w_cap:
-        k, _ = window.popitem(last=False)
-        probation[k] = None # To Probation MRU
-        probation.move_to_end(k)
+    if v_key in state['window']:
+        del state['window'][v_key]
+        state['window_hits'].discard(v_key)
+    elif v_key in state['probation']:
+        del state['probation'][v_key]
+    elif v_key in state['protected']:
+        del state['protected'][v_key]
 
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate