<NAME>
s3_fifo_d
</NAME>

<DESCRIPTION>
Replacing ARC with S3-FIFO-D (Simple S3-FIFO with Ghost cache). S3-FIFO is generally more robust and scan-resistant than ARC, addressing the zero hit rates on scan traces (14-19) by using a small FIFO queue ("Small") for new items. Only items that receive a hit while in "Small" (or are rescued via the Ghost list) are promoted to the "Main" queue. This prevents one-hit wonders from polluting the main cache segment. The implementation maintains Small/Main queues and a Ghost list, managing promotions and evictions lazily within the `evict` loop.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# ARC Globals
m_t1 = dict() # Recency (L1)
m_t2 = dict() # Frequency (L2)
m_b1 = dict() # Ghost Recency
m_b2 = dict() # Ghost Frequency
p = 0         # Adaptive parameter

def evict(cache_snapshot, obj):
    '''
    ARC Eviction Logic:
    - Adapt p based on hits in ghost lists (B1, B2).
    - Decide whether to evict from T1 or T2 based on p and T1 size.
    '''
    global p

    capacity = cache_snapshot.capacity

    # Adaptation: If the incoming object (miss) is in a ghost list
    if obj.key in m_b1:
        delta = 1
        if len(m_b1) < len(m_b2):
             delta = len(m_b2) / len(m_b1)
        p = min(capacity, p + delta)
    elif obj.key in m_b2:
        delta = 1
        if len(m_b2) < len(m_b1):
             delta = len(m_b1) / len(m_b2)
        p = max(0, p - delta)

    # Decision: Select victim
    evict_t1 = False
    if len(m_t1) > 0:
        if len(m_t1) > p:
            evict_t1 = True
        elif obj.key in m_b2 and len(m_t1) == int(p):
            evict_t1 = True
        elif len(m_t2) == 0:
            evict_t1 = True

    if evict_t1:
        return next(iter(m_t1))
    else:
        return next(iter(m_t2))

def update_after_hit(cache_snapshot, obj):
    '''
    On Cache Hit:
    - If obj in T1, move to T2 (MRU).
    - If obj in T2, move to MRU of T2.
    '''
    global m_t1, m_t2

    if obj.key in m_t1:
        del m_t1[obj.key]
        m_t2[obj.key] = None
    elif obj.key in m_t2:
        del m_t2[obj.key]
        m_t2[obj.key] = None

def update_after_insert(cache_snapshot, obj):
    '''
    On Cache Insert (Miss):
    - Place obj in T1 or T2.
    '''
    global m_t1, m_t2, m_b1, m_b2, p

    # Reset state at start of new trace (access_count starts at 1 usually for first miss)
    if cache_snapshot.access_count <= 1:
        m_t1.clear()
        m_t2.clear()
        m_b1.clear()
        m_b2.clear()
        p = 0

    # Check if it was a ghost
    is_ghost = False
    if obj.key in m_b1:
        del m_b1[obj.key]
        is_ghost = True
    if obj.key in m_b2:
        del m_b2[obj.key]
        is_ghost = True

    if is_ghost:
        # History hit -> promote to frequency list
        m_t2[obj.key] = None
    else:
        # New item -> probation list
        m_t1[obj.key] = None

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    After Eviction:
    - Update ghost lists.
    '''
    global m_t1, m_t2, m_b1, m_b2

    if evicted_obj.key in m_t1:
        del m_t1[evicted_obj.key]
        m_b1[evicted_obj.key] = None
    elif evicted_obj.key in m_t2:
        del m_t2[evicted_obj.key]
        m_b2[evicted_obj.key] = None

    # Constrain ghost list sizes to capacity
    capacity = cache_snapshot.capacity
    while len(m_b1) > capacity:
        m_b1.pop(next(iter(m_b1)))
    while len(m_b2) > capacity:
        m_b2.pop(next(iter(m_b2)))
=======
# S3-FIFO-D Globals
m_small = dict()
m_main = dict()
m_ghost = dict()
m_hits = dict()

def evict(cache_snapshot, obj):
    '''
    S3-FIFO-D Eviction Logic:
    - New items enter Small.
    - Eviction prioritizes dropping from Small (if > 10% cap) or Main.
    - Items in Small with hits promote to Main.
    - Items in Main with hits get second chance (reinserted).
    '''
    global m_small, m_main, m_hits

    capacity = cache_snapshot.capacity
    # Small queue size target: 10% of capacity
    s_capacity = max(1, int(capacity * 0.1))

    while True:
        # If Small is larger than target, or Main is empty, we evict from Small
        if len(m_small) > s_capacity or len(m_main) == 0:
            if not m_small:
                # Should not happen if cache is full and Main is empty
                # If Main has items, pick from Main
                if m_main:
                    return next(iter(m_main))
                return next(iter(cache_snapshot.cache))

            candidate = next(iter(m_small))
            if m_hits.get(candidate, 0) > 0:
                # Hit in Small -> Promote to Main
                m_hits[candidate] = 0
                del m_small[candidate]
                m_main[candidate] = None
            else:
                # No hit -> Evict from Small
                return candidate
        else:
            # Evict from Main
            if not m_main:
                # Fallback to Small
                return next(iter(m_small))

            candidate = next(iter(m_main))
            if m_hits.get(candidate, 0) > 0:
                # Hit in Main -> Reinsert at tail (Second Chance)
                m_hits[candidate] = 0
                del m_main[candidate]
                m_main[candidate] = None
            else:
                # No hit -> Evict from Main
                return candidate

def update_after_hit(cache_snapshot, obj):
    '''
    On Cache Hit:
    - Increment hit counter (saturated at 3).
    '''
    global m_hits
    m_hits[obj.key] = min(m_hits.get(obj.key, 0) + 1, 3)

def update_after_insert(cache_snapshot, obj):
    '''
    On Cache Insert (Miss):
    - Reset state if new trace.
    - Insert into Small or Main (if in Ghost).
    '''
    global m_small, m_main, m_hits, m_ghost

    if cache_snapshot.access_count <= 1:
        m_small.clear()
        m_main.clear()
        m_hits.clear()
        m_ghost.clear()

    # S3-FIFO-D: If in ghost, insert to Main (rescue). Else Small.
    if obj.key in m_ghost:
        del m_ghost[obj.key]
        m_main[obj.key] = None
    else:
        m_small[obj.key] = None

    m_hits[obj.key] = 0

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    After Eviction:
    - Manage Ghost list for items evicted from Small.
    - Cleanup data structures.
    '''
    global m_small, m_main, m_hits, m_ghost

    key = evicted_obj.key

    if key in m_small:
        # Evicted from Small without promotion -> Add to Ghost
        del m_small[key]
        m_ghost[key] = None
    elif key in m_main:
        del m_main[key]

    if key in m_hits:
        del m_hits[key]

    # Limit Ghost size to Cache Capacity
    while len(m_ghost) > cache_snapshot.capacity:
        m_ghost.pop(next(iter(m_ghost)))
>>>>>>> REPLACE

</DIFF>