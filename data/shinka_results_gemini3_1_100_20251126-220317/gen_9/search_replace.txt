<NAME>
slru_eviction
</NAME>

<DESCRIPTION>
Implement Segmented LRU (SLRU) eviction policy. SLRU splits the cache into a "probation" segment (20%) and a "protected" segment (80%). New items enter probation. On hit, items in probation move to protected. If protected is full, the LRU item from protected is demoted to probation. Eviction happens from the LRU of probation first, effectively filtering out scan patterns (items accessed only once).
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
m_key_timestamp = dict()

def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    candid_obj_key = None
    min_ts = min(m_key_timestamp.values())
    candid_obj_keys = list(key for key in cache_snapshot.cache if m_key_timestamp[key] == min_ts)
    candid_obj_key = candid_obj_keys[0]
    return candid_obj_key

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global m_key_timestamp
    assert obj.key in m_key_timestamp
    m_key_timestamp[obj.key] = cache_snapshot.access_count

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global m_key_timestamp
    assert obj.key not in m_key_timestamp
    m_key_timestamp[obj.key] = cache_snapshot.access_count

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global m_key_timestamp
    assert obj.key not in m_key_timestamp
    assert evicted_obj.key in m_key_timestamp
    m_key_timestamp.pop(evicted_obj.key)
=======
m_access_time = dict()
m_protected = set()

def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    # SLRU: Evict LRU from Probation (not in m_protected) first.
    # m_access_time keys are ordered by insertion (LRU first).
    for key in m_access_time:
        if key not in m_protected:
            return key
    # If no probation items, evict LRU from Protected
    return next(iter(m_access_time))

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global m_access_time, m_protected

    # Update LRU order: remove and re-insert
    if obj.key in m_access_time:
        del m_access_time[obj.key]
    m_access_time[obj.key] = cache_snapshot.access_count

    # SLRU Logic: Promote to protected
    if obj.key not in m_protected:
        m_protected.add(obj.key)

        # Enforce Protected Segment capacity (80%)
        protected_limit = int(cache_snapshot.capacity * 0.8)
        if len(m_protected) > protected_limit:
            # Demote LRU of Protected to Probation
            # Find the first key in m_access_time (LRU) that is in m_protected
            for key in m_access_time:
                if key in m_protected:
                    m_protected.remove(key)
                    break

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global m_access_time
    # New items start in Probation (not in m_protected)
    m_access_time[obj.key] = cache_snapshot.access_count

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global m_access_time, m_protected
    if evicted_obj.key in m_access_time:
        del m_access_time[evicted_obj.key]
    m_protected.discard(evicted_obj.key)
>>>>>>> REPLACE
</DIFF>