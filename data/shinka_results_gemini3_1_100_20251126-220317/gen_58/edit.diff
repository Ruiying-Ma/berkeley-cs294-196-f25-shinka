--- a/original.py
+++ b/original.py
@@ -1,156 +1,190 @@
 # EVOLVE-BLOCK-START
-"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""
-
+"""
+W-TinyLFU with Doorkeeper, Adaptive Aging, and Biased Eviction.
+Maintains a small Window and an SLRU Main Cache.
+Uses a Doorkeeper to filter one-hit wonders.
+"""
 from collections import deque, OrderedDict
 
-# W-TinyLFU style state
+# Global State
 algo_state = {
-    'window': deque(),        # Queue of (key, size)
-    'window_size': 0,         # Current size of window
-    'probation': OrderedDict(), # key -> size
-    'protected': OrderedDict(), # key -> size
+    'window': OrderedDict(),    # key -> size (LRU is first)
+    'window_size': 0,           # Current total size of window
+    'probation': OrderedDict(), # key -> size (LRU is first)
+    'protected': OrderedDict(), # key -> size (LRU is first)
     'protected_size': 0,
-    'freq': {},               # key -> count
-    'access_count': 0
+    'freq': {},                 # key -> count
+    'doorkeeper': set(),        # Set of keys seen approximately once
+    'aging_counter': 0,
+    'max_time': 0               # For detecting trace reset
 }
 
+def _reset_state(current_time):
+    if current_time < algo_state['max_time']:
+        algo_state['window'].clear()
+        algo_state['window_size'] = 0
+        algo_state['probation'].clear()
+        algo_state['protected'].clear()
+        algo_state['protected_size'] = 0
+        algo_state['freq'].clear()
+        algo_state['doorkeeper'].clear()
+        algo_state['aging_counter'] = 0
+        algo_state['max_time'] = 0
+    algo_state['max_time'] = current_time
+
+def _update_freq(key, capacity):
+    state = algo_state
+
+    # Aging
+    state['aging_counter'] += 1
+    if state['aging_counter'] >= capacity * 5:
+        state['aging_counter'] = 0
+        # Halve frequencies
+        rem = []
+        for k, v in state['freq'].items():
+            nv = v // 2
+            if nv == 0: rem.append(k)
+            else: state['freq'][k] = nv
+        for k in rem: del state['freq'][k]
+
+    # Doorkeeper Management
+    if len(state['doorkeeper']) > capacity * 2:
+        state['doorkeeper'].clear()
+
+    # Update
+    if key in state['freq']:
+        state['freq'][key] = min(state['freq'][key] + 1, 15)
+    elif key in state['doorkeeper']:
+        state['doorkeeper'].remove(key)
+        state['freq'][key] = 2
+    else:
+        state['doorkeeper'].add(key)
+
+def _get_freq(key):
+    if key in algo_state['freq']:
+        return algo_state['freq'][key]
+    if key in algo_state['doorkeeper']:
+        return 1
+    return 0
+
 def evict(cache_snapshot, obj):
-    '''
-    W-TinyLFU Eviction:
-    - Maintains a small Window (1%) and a Main SLRU (Probation + Protected).
-    - If Window is not full, evict from Main (to allow Window to grow).
-    - If Window is full, duel the Window victim vs Main victim using frequency.
-    '''
-    window = algo_state['window']
-    probation = algo_state['probation']
-    protected = algo_state['protected']
-    freq = algo_state['freq']
-
+    _reset_state(cache_snapshot.access_count)
+    state = algo_state
     capacity = cache_snapshot.capacity
     w_cap = max(1, int(capacity * 0.01))
 
-    # 1. If Window has space, prefer evicting from Main (Probation -> Protected)
-    if algo_state['window_size'] < w_cap:
-        if probation:
-            return next(iter(probation))
-        if protected:
-            return next(iter(protected))
-        if window:
-            return window[0][0]
+    # Candidates
+    cand_w_key = next(iter(state['window'])) if state['window'] else None
 
-    # 2. Window is full. Find candidates.
-    if not window:
-        # Fallback if window empty (rare)
-        if probation: return next(iter(probation))
-        if protected: return next(iter(protected))
-        return None
+    cand_m_key = None
+    if state['probation']:
+        cand_m_key = next(iter(state['probation']))
+    elif state['protected']:
+        cand_m_key = next(iter(state['protected']))
 
-    cand_w_key = window[0][0]
+    # Fail-safe
+    if cand_w_key is None and cand_m_key is None: return None
+    if cand_w_key is None: return cand_m_key
+    if cand_m_key is None: return cand_w_key
 
-    if probation:
-        cand_m_key = next(iter(probation))
-    elif protected:
-        cand_m_key = next(iter(protected))
-    else:
-        return cand_w_key
+    fw = _get_freq(cand_w_key)
+    fm = _get_freq(cand_m_key)
 
-    # Duel: Keep the one with higher frequency
-    freq_w = freq.get(cand_w_key, 0)
-    freq_m = freq.get(cand_m_key, 0)
+    # 1. Window Growing Logic
+    if state['window_size'] < w_cap:
+        # If Main victim is valuable (fm > fw), sacrifice Window instead.
+        if fm > fw:
+            return cand_w_key
+        return cand_m_key
 
-    if freq_w > freq_m:
+    # 2. Window Full - Duel
+    # Bias towards Main (Probation/Protected) to avoid churn.
+    if fw > fm + 1:
         return cand_m_key
     else:
         return cand_w_key
 
 def update_after_hit(cache_snapshot, obj):
-    '''
-    Update frequency and manage SLRU promotion.
-    '''
+    _reset_state(cache_snapshot.access_count)
+    state = algo_state
     key = obj.key
-    algo_state['access_count'] += 1
+    capacity = cache_snapshot.capacity
 
-    # Frequency Update & Aging
-    f = algo_state['freq']
-    f[key] = f.get(key, 0) + 1
-    if algo_state['access_count'] > cache_snapshot.capacity * 10:
-        algo_state['freq'] = {k: v // 2 for k, v in f.items() if v > 1}
-        algo_state['access_count'] = 0
+    _update_freq(key, capacity)
 
-    # SLRU Management
-    if key in algo_state['protected']:
-        algo_state['protected'].move_to_end(key)
-    elif key in algo_state['probation']:
-        # Promote from Probation to Protected
-        val = algo_state['probation'].pop(key)
-        algo_state['protected'][key] = val
-        algo_state['protected_size'] += val
+    # Position Update
+    if key in state['window']:
+        state['window'].move_to_end(key)
+    elif key in state['protected']:
+        state['protected'].move_to_end(key)
+    elif key in state['probation']:
+        # Promote Probation -> Protected
+        val = state['probation'].pop(key)
+        state['protected'][key] = val
+        state['protected_size'] += val
 
-        # Enforce Protected Limit (80% of capacity)
-        limit = int(cache_snapshot.capacity * 0.8)
-        while algo_state['protected_size'] > limit and algo_state['protected']:
-            k, v = algo_state['protected'].popitem(last=False)
-            algo_state['protected_size'] -= v
-            algo_state['probation'][k] = v
+        # Enforce Protected Limit (80% of Main)
+        limit = int(capacity * 0.8)
+        while state['protected_size'] > limit and state['protected']:
+            k, v = state['protected'].popitem(last=False)
+            state['protected_size'] -= v
+            state['probation'][k] = v
+            state['probation'].move_to_end(k)
 
 def update_after_insert(cache_snapshot, obj):
-    '''
-    Insert new object into Window and handle overflow to Probation.
-    '''
+    _reset_state(cache_snapshot.access_count)
+    state = algo_state
     key = obj.key
     size = obj.size
-    algo_state['access_count'] += 1
+    capacity = cache_snapshot.capacity
 
-    # Frequency Update
-    f = algo_state['freq']
-    f[key] = f.get(key, 0) + 1
+    _update_freq(key, capacity)
 
-    # Insert into Window
-    algo_state['window'].append((key, size))
-    algo_state['window_size'] += size
+    # Insert to Window
+    state['window'][key] = size
+    state['window_size'] += size
 
     # Check Window Overflow -> Move to Probation
-    w_cap = max(1, int(cache_snapshot.capacity * 0.01))
-    while algo_state['window_size'] > w_cap and algo_state['window']:
-        k, s = algo_state['window'].popleft()
-        algo_state['window_size'] -= s
-        algo_state['probation'][k] = s
+    w_cap = max(1, int(capacity * 0.01))
+    while state['window_size'] > w_cap and state['window']:
+        k, s = state['window'].popitem(last=False)
+        state['window_size'] -= s
+
+        state['probation'][k] = s
+        state['probation'].move_to_end(k)
 
 def update_after_evict(cache_snapshot, obj, evicted_obj):
-    '''
-    Remove evicted object from internal structures.
-    '''
+    state = algo_state
     key = evicted_obj.key
     size = evicted_obj.size
 
-    # Check and remove from locations
-    if algo_state['window'] and algo_state['window'][0][0] == key:
-        algo_state['window'].popleft()
-        algo_state['window_size'] -= size
-    elif key in algo_state['probation']:
-        del algo_state['probation'][key]
-    elif key in algo_state['protected']:
-        val = algo_state['protected'].pop(key)
-        algo_state['protected_size'] -= val
+    if key in state['window']:
+        del state['window'][key]
+        state['window_size'] -= size
+    elif key in state['probation']:
+        del state['probation'][key]
+    elif key in state['protected']:
+        val = state['protected'].pop(key)
+        state['protected_size'] -= val
 
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate