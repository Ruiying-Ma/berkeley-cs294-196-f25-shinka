{
  "unprocessed_programs": [],
  "meta_summary": "**Program Name: Basic Dictionary-Based Least Recently Used (LRU)**\n- **Implementation**: The algorithm tracks the most recent access time (access count) for each object in a global dictionary and evicts the object with the lowest timestamp value.\n- **Performance**: It achieves a combined score of 0.21, performing strongly on traces with high temporal locality but poorly on scan-heavy or looping patterns.\n- **Feedback**: While the logic correctly implements the standard LRU policy, the O(N) linear scan for the minimum timestamp is inefficient, and the lack of frequency tracking limits hit rates on non-recency-based workloads.\n**Program Identifier:** Generation 0 - Patch Name initial_program - Correct Program: True\n\n**Program Name: LFU-DA with Dynamic Aging and LRU Tie-Breaking**\n- **Implementation**: The algorithm implements Least Frequently Used with Dynamic Aging (LFU-DA) by calculating priorities as frequency plus a global aging factor (the priority of the last evicted item), using a linear scan to identify the eviction victim.\n- **Performance**: It achieved a combined score of 0.22, demonstrating strong performance on frequency-stable workloads (up to 0.88 hit rate) but failing completely on scan-heavy traces (0.00 hit rate).\n- **Feedback**: While the dynamic aging factor effectively prevents cache pollution common in standard LFU, the algorithm lacks specific mechanisms to handle scan patterns and the $O(N)$ eviction search is computationally inefficient.\n**Program Identifier:** Generation 1 - Patch Name lfuda_eviction - Correct Program: True\n\n**Program Name: S3-FIFO with Static S-Queue Allocation and Lazy Promotion**\n- **Implementation**: Utilizes two queues (S for new, M for frequent) with a 10% static allocation for S, employing lazy promotion where accessed eviction candidates are moved to M.\n- **Performance**: Achieves a combined score of 0.23, showing strong locality handling (hit rates >0.88) but poor performance on specific scan patterns (hit rates ~0.00).\n- **Feedback**: The implementation correctly separates one-hit wonders, but the fixed 10% S-queue size lacks adaptability for varying workload phases, causing significant drops in hit rate for certain traces.\n**Program Identifier:** Generation 2 - Patch Name s3fifo_v1 - Correct Program: True\n\n**Program Name: Segmented LRU with Fixed Protected Capacity**\n- **Implementation**: This Segmented LRU (SLRU) implementation uses two `OrderedDict` segments, `probationary` and `protected`, promoting items to `protected` on hits with a fixed cap of 80% capacity. Overflow from `protected` demotes items back to `probationary`, and eviction strictly targets the LRU of the `probationary` segment first.\n- **Performance**: It achieved a combined score of 0.23, with high efficiency on select patterns (up to 0.88) but near-zero hit rates on numerous other traces.\n- **Feedback**: The rigid 80% protected limit provides scan resistance but likely starves the probationary segment during high churn, suggesting an adaptive partition size would improve consistency across diverse workloads.\n**Program Identifier:** Generation 3 - Patch Name slru_algorithm - Correct Program: True\n\n**Program Name: LeCaR with Randomized Policy Selection**\n- **Implementation**: Maintains a probability weight to dynamically switch between LRU and LFU eviction, updating the weight via multiplicative updates when re-accessing previously evicted keys tracked in history buffers.\n- **Performance**: The algorithm achieves a low overall score of 0.21, with hit rates varying drastically from near 0% on many traces to 87% on specific stable workloads.\n- **Feedback**: The probabilistic switching mechanism combined with a fixed learning rate appears too unstable for dynamic workloads, often failing to converge on an optimal policy quickly enough.\n**Program Identifier:** Generation 4 - Patch Name lecar_adaptive_eviction - Correct Program: True\n\n**Program Name: LFU-DA with Ghost Frequency History**\n- **Implementation**: The algorithm implements Least Frequently Used with Dynamic Aging (LFU-DA), setting priority as frequency plus an aging factor $L$ (updated to the evicted item's priority), and maintains a \"ghost\" history to restore frequencies for recently evicted items.\n- **Performance**: It achieved a combined score of 0.23, demonstrating high hit rates on frequency-skewed traces (up to 0.88) but failing near-completely on scan or loop patterns (near 0.0).\n- **Feedback**: While dynamic aging helps adapt to shifting frequency distributions, the algorithm lacks specific scan resistance, causing new items to be evicted immediately against established high-frequency items in scan-heavy workloads.\n**Program Identifier:** Generation 5 - Patch Name lfu_da_ghost - Correct Program: True\n\n**Program Name: Adaptive Replacement Cache (ARC) with Ghost Lists**\n- **Implementation**: Maintains four separate LRU dictionaries (T1/T2 for resident data, B1/B2 for eviction history) and dynamically shifts a partition parameter `p` to balance recency and frequency based on ghost list hits.\n- **Performance**: Achieved a combined score of 0.24, demonstrating high effectiveness on repeating patterns (hit rates >0.8) but varying performance on high-churn or scan-heavy traces.\n- **Feedback**: The implementation correctly applies ARC's sophisticated adaptability logic, successfully optimizing for both recency and frequency, though the overhead of maintaining complex state may impact efficiency on highly volatile workloads.\n**Program Identifier:** Generation 6 - Patch Name implement_arc - Correct Program: True\n\n**Program Name: Adaptive Replacement Cache (ARC) with Trace Reset**\n- **Implementation**: Implements the ARC algorithm using four LRU lists (T1, T2, B1, B2) to dynamically balance recency and frequency by adjusting a partition parameter `p` based on ghost list hits, including a check to reset state for new traces.\n- **Performance**: The algorithm achieves a combined score of 0.24, performing robustly on mixed workloads (e.g., traces 1-10) but showing lower hit rates on pure scans.\n- **Feedback**: The implementation correctly separates eviction decisions from state updates to fit the framework, and the self-tuning capability effectively captures both recent and frequent access patterns without manual tuning.\n**Program Identifier:** Generation 7 - Patch Name implement_arc_algorithm - Correct Program: True\n\n**Program Name: S3-FIFO Eviction with Ghost Cache and Dual Queues**\n- **Implementation**: Maintains a small nursery queue (10%) and a main queue (90%) with a ghost cache to rescue frequently evicted items, using a 1-bit clock scheme for promotion and reinsertion.\n- **Performance**: Combined score of 0.23, showing strong results on high-locality workloads (up to 88% hit rate) but near-zero performance on several specific traces.\n- **Feedback**: The use of ghost caches and the S/M split provides effective scan resistance and frequency tracking, though the static 10% nursery size may lack flexibility for varying working set structures.\n**Program Identifier:** Generation 8 - Patch Name s3fifo - Correct Program: True\n\n**Program Name: Segmented LRU with Fixed 80% Protected Capacity**\n- **Implementation**: Utilizes an ordered dictionary for global LRU tracking and a set to maintain a protected segment (fixed at 80% of cache) where items are promoted upon hits and the segment's LRU is demoted when full.\n- **Performance**: Achieves a combined score of 0.23, performing well on stable frequency traces (up to 0.88 hit rate) but poorly on high-churn or scan-heavy workloads.\n- **Feedback**: The static partitioning effectively isolates the working set for specific traces but lacks the adaptability required to handle diverse access patterns found in the broader dataset.\n**Program Identifier:** Generation 9 - Patch Name slru_eviction - Correct Program: True\n\n**Program Name: Adaptive Replacement Cache (ARC)**\n- **Implementation**: Maintains four LRU lists (T1/T2 for resident data, B1/B2 for eviction history) and dynamically adjusts a target partition size `p` based on hits in the ghost lists to balance recency and frequency.\n- **Performance**: The algorithm achieves a combined score of 0.25, with exceptional performance on high-locality traces (up to 0.89 hit rate) but inconsistent results on scanning workloads.\n- **Feedback**: The implementation successfully leverages ghost lists to adapt to changing workload patterns, offering a robust trade-off between LRU and LFU strategies without manual tuning.\n**Program Identifier:** Generation 10 - Patch Name arc_eviction - Correct Program: True\n\n**Program Name: Adaptive Replacement Cache (ARC) Implementation**\n- **Implementation**: Implements ARC using four dictionaries (T1/T2 for resident, B1/B2 for ghosts) to dynamically tune a partition parameter `p` that balances recency versus frequency based on eviction history.\n- **Performance**: Achieved a combined score of 0.24, demonstrating strong adaptability on mixed workloads (up to 0.89 hit rate) while struggling with specific high-churn traces.\n- **Feedback**: The implementation correctly captures the self-tuning nature of ARC to maximize hit rates, though the extensive state management and adaptation lag result in poor performance on datasets with rapidly shifting or massive working sets.\n**Program Identifier:** Generation 11 - Patch Name implement_arc_algorithm - Correct Program: True\n\n**Program Name: ARC with S3-FIFO Nursery Hybrid**\n- **Implementation**: This algorithm places a small FIFO nursery queue in front of an Adaptive Replacement Cache (ARC), promoting accessed nursery items to ARC's recency list while using ghost lists to dynamically tune the balance between recency and frequency segments.\n- **Performance**: The algorithm achieved a combined score of 0.23, showing high variability with excellent hit rates on specific traces (e.g., 0.88) but near-zero performance on several others.\n- **Feedback**: While the nursery effectively filters one-hit wonders, its integration likely disrupts ARC's ghost list learning mechanism for certain access patterns, preventing the algorithm from correctly adapting `p` and leading to instability across diverse workloads.\n**Program Identifier:** Generation 12 - Patch Name s3_fifo_arc_hybrid - Correct Program: True\n\n**Program Name: S3-FIFO-D with Ghost Queue and Partitioned FIFO**\n- **Implementation**: Implements a segmented FIFO strategy with a small probation queue (10% capacity) and a main queue, using a ghost cache to rescue evicted items and a second-chance mechanism for recurring hits in the main segment.\n- **Performance**: The algorithm achieved a combined score of 0.25, excelling on stable workloads (e.g., trace 28 with 0.89) but performing poorly on scan-heavy traces (e.g., trace 14 with 0.00).\n- **Feedback**: The fixed 10% probation size appears too rigid for workloads with high churn, suggesting that adaptive queue sizing or a more robust frequency filter is needed to handle diverse access patterns effectively.\n**Program Identifier:** Generation 13 - Patch Name s3_fifo_d - Correct Program: True\n\n**Program Name: LIRS Cache Eviction with Static HIR Buffer**\n- **Implementation**: Implements the Low Inter-reference Recency Set (LIRS) algorithm using `OrderedDicts` for the history stack and resident queue, with a fixed 5% capacity reservation for HIR blocks.\n- **Performance**: Achieves a composite score of 0.22, showing high effectiveness on stable, looping patterns (up to 88% hit rate) but near-zero performance on volatile traces.\n- **Feedback**: While the LIRS logic effectively isolates the working set from scans, the static configuration and rigid promotion rules struggle to adapt to traces with rapidly shifting locality or random access patterns.\n**Program Identifier:** Generation 14 - Patch Name lirs_optimized - Correct Program: True\n\n**Program Name: Static W-TinyLFU with Segmented LRU**\n- **Implementation**: Implements a W-TinyLFU architecture with a fixed 5% admission window and a Segmented LRU main cache, using frequency-based duels to decide whether to admit new items or retain existing ones.\n- **Performance**: Achieved a combined score of 0.25, demonstrating strong performance on frequency-biased workloads but failing significantly on scan-heavy traces.\n- **Feedback**: The static window size limits the algorithm's ability to adapt to changing workload patterns; implementing dynamic window sizing (as in Adaptive W-TinyLFU) could improve robustness across diverse traces.\n**Program Identifier:** Generation 15 - Patch Name w_tinylfu_slru - Correct Program: True\n\n**Program Name: Randomized Adaptive Replacement Cache (ARC)**\n- **Implementation**: Maintains ARC's dual lists (recency/frequency) and adaptive parameter `p` using ghost entries, but utilizes random eviction within the selected list instead of LRU.\n- **Performance**: Achieved a combined score of 0.25 with highly variable hit rates, excelling on some workloads (0.89) but failing completely on others (0.00).\n- **Feedback**: Replacing LRU with random eviction undermines ARC's recency tracking, significantly reducing effectiveness on standard locality traces despite the correctly implemented adaptive balancing logic.\n**Program Identifier:** Generation 16 - Patch Name arc_random_eviction - Correct Program: True\n\n**Program Name: S3-FIFO with Static Partitioning and Ghost Queue**\n- **Implementation**: This algorithm maintains three queues (Small, Main, Ghost) with a static 10% Small partition, promoting items to Main upon re-access or Ghost hits to filter one-time scans.\n- **Performance**: It achieved a combined score of 0.25, showing high efficiency on some workloads (up to 89% hit rate) but performing poorly on others.\n- **Feedback**: While the S3-FIFO logic successfully identifies frequent items in standard distributions, the static queue sizing limits adaptability, causing significant misses in changing workload patterns.\n**Program Identifier:** Generation 17 - Patch Name s3_fifo_refined - Correct Program: True\n\n**Program Name: Nursery-ARC (NARC) Hybrid Cache Algorithm**\n- **Implementation**: This approach couples a 15% FIFO \"Nursery\" buffer to filter one-hit wonders with an Adaptive Replacement Cache (ARC) for the remaining capacity, utilizing lazy promotion to move reused items from the Nursery to the main ARC instance.\n- **Performance**: The algorithm achieves a combined score of 0.23, demonstrating exceptional hit rates on frequency-heavy traces (up to 88%) but significant inconsistency on other workloads.\n- **Feedback**: While the nursery successfully prevents scan pollution, the decision to exclude nursery victims from ARC's ghost lists likely hinders the adaptive parameter `p` from correctly responding to shifts in global recency demands.\n**Program Identifier:** Generation 18 - Patch Name nursery_arc - Correct Program: True\n\n**Program Name: LIRS Algorithm with 99% LIR Capacity Allocation**\n- **Implementation**: Implements the LIRS policy using a stack and queue to manage Low and High Inter-reference Recency blocks, tracking non-resident HIRs to detect looping patterns. It allocates 99% of the cache capacity to LIR blocks, effectively minimizing the resident HIR queue.\n- **Performance**: Achieved a score of 0.24 with high hit rates on looping traces (e.g., 0.89 on trace 28) but near-zero performance on many others.\n- **Feedback**: The aggressive 99% LIR target leaves insufficient space for the HIR queue, likely causing thrashing on workloads relying on recent short-term locality.\n**Program Identifier:** Generation 19 - Patch Name lirs_implementation - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and Segmented LRU**\n- **Implementation**: This approach implements W-TinyLFU using a tiny 1% Window LRU and a Main SLRU (Probation/Protected), managing admission via a Doorkeeper frequency filter and periodic aging.\n- **Performance**: It achieves a combined score of 0.21, showing strong results on high-repetition traces but failing significantly on scan-heavy or rapid-turnover workloads.\n- **Feedback**: The static, very small window size effectively filters noise but makes the cache overly resistant to admitting new items, leading to poor adaptability on traces lacking long-term frequency stability.\n**Program Identifier:** Generation 20 - Patch Name w_tinylfu_implementation - Correct Program: True\n\n**Program Name: S3-FIFO Eviction with Small, Main, and Ghost Queues**\n- **Implementation**: Maintains Small (10%) and Main (90%) FIFO queues with a Ghost cache for history; accessed items in Small are promoted to Main during eviction, while Main items get a second chance.\n- **Performance**: The algorithm achieved a composite score of 0.25, showing high efficiency on stable workloads (up to 0.89 hit rate) but struggling significantly on dynamic or scan-heavy traces.\n- **Feedback**: The fixed 10/90 split provides basic scan resistance, but the poor performance on many traces suggests that a static resizing policy or the specific ghost queue management may be too rigid for diverse access patterns.\n**Program Identifier:** Generation 21 - Patch Name s3fifo_algorithm - Correct Program: True\n\n**Program Name:** Adaptive TinyLFU with SLRU and Doorkeeper Mechanism\n- **Implementation:** This complex eviction policy integrates a window cache and segmented SLRU main cache, employing a Doorkeeper-assisted frequency counter for admission duels and dynamically sizing the window based on ghost cache hits.\n- **Performance:** The algorithm achieved a combined score of 0.22, excelling on specific patterns (up to 0.88 hit rate) but performing poorly (near zero) on numerous other traces.\n- **Feedback:** The approach effectively protects frequent items in stable workloads but struggles with rapid adaptations or scans, suggesting the admission or aging parameters may be over-tuned for stability over responsiveness.\n**Program Identifier:** Generation 22 - Patch Name adaptive_tinylfu_doorkeeper - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU Main Cache**\n- **Implementation**: Uses a 5% FIFO admission window and a Segmented LRU (Probation/Protected) main cache, arbitrating eviction via frequency comparisons with a doorkeeper and periodic aging.\n- **Performance**: Achieved a combined score of 0.19, excelling on specific high-locality traces (up to 0.76 hit rate) but struggling significantly with sparse or scan-heavy workloads.\n- **Feedback**: The W-TinyLFU structure effectively prevents pollution via frequency-based admission, but the static 5% window and SLRU splits likely limit adaptability across the diverse trace characteristics.\n**Program Identifier:** Generation 23 - Patch Name w_tinylfu_implementation - Correct Program: True\n\n**Program Name: W-TinyLFU with Segmented LRU and Frequency Sketch**\n- **Implementation**: Manages cache via Window, Probation, and Protected segments using `OrderedDict`s, employing a frequency sketch with a Doorkeeper to govern admission between Window and Probation victims.\n- **Performance**: Yielded a score of 0.19, excelling in repeated-access patterns (max 0.76 hit rate) but failing significantly on unique-access or scan-heavy traces.\n- **Feedback**: The strict 1% window and frequency-based admission effectively filter noise in stable workloads but struggle to adapt to rapid shifts or working sets larger than the protected segment.\n**Program Identifier:** Generation 24 - Patch Name wtinylfu_pp - Correct Program: True\n\n**Program Name: Adaptive S3-FIFO with Ghost Lists**\n- **Implementation**: Merges S3-FIFO's structure (Small/Main queues with hit-bit promotion) with ARC's adaptive sizing logic, using ghost lists to dynamically tune the Small queue capacity based on eviction history.\n- **Performance**: Achieved a combined score of 0.25, with high variability ranging from ~0.89 on optimal traces to near zero on others.\n- **Feedback**: The hybrid adaptation logic struggles to converge on diverse workloads, likely because the FIFO-based eviction combined with ARC-style parameter tuning creates instability in queue sizing compared to static S3-FIFO or LRU-based ARC.\n**Program Identifier:** Generation 25 - Patch Name adaptive_s3_fifo - Correct Program: True\n\n**Program Name: W-TinyLFU Eviction with SLRU and Frequency Admission**\n- **Implementation:** This algorithm employs a W-TinyLFU architecture featuring a 1% FIFO admission window and a Segmented LRU (Probation/Protected) main cache, using frequency counts to duel potential victims during eviction.\n- **Performance:** It achieved a combined score of 0.26, performing exceptionally well on frequency-biased workloads (up to 0.89 hit rate) while failing on several others with near-zero hit rates.\n- **Feedback:** The frequency-based admission policy successfully filters low-value items in stable workloads, but the small static window size and aggressive filtering likely caused the poor performance on traces requiring faster adaptation or larger scan resistance.\n**Program Identifier:** Generation 26 - Patch Name w_tinylfu_impl - Correct Program: True\n\n**Program Name: W-TinyLFU with Global State**\n- **Implementation**: Implements W-TinyLFU using global dictionaries for storage segments (Window, Probation, Protected) and a frequency counter for admission duels, with a 1%/99% split.\n- **Performance**: Score 0.0 (Failed validation tests).\n- **Feedback**: The solution failed validation, likely due to improper state isolation using global variables causing data leakage between trace runs, or boundary errors in the admission duel logic.\n**Program Identifier:** Generation 27 - Patch Name w_tinylfu_eviction - Correct Program: False\n\n**Program Name: Adaptive S3-FIFO with ARC-based Queue Sizing**\n- **Implementation**: This approach combines S3-FIFO's tri-queue structure (Small, Main, Ghost) with ARC's adaptive sizing logic, dynamically adjusting the Small queue's capacity target based on ghost queue hits.\n- **Performance**: The program achieved a combined score of 0.25, with highly variable results ranging from excellent (0.89) to completely ineffective (0.00).\n- **Feedback**: The hybrid adaptation logic struggles to stabilize the FIFO queues on certain workloads, likely because ARC's resizing strategy (designed for LRU) conflicts with S3-FIFO's frequency-based promotion rules, leading to thrashing.\n**Program Identifier:** Generation 28 - Patch Name adapt_s3fifo - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU and Doorkeeper Frequency Aging**\n- **Implementation**: Implements W-TinyLFU using a 5% Window LRU and 95% Main SLRU (80% Protected), employing a Doorkeeper filter and frequency dictionary with periodic aging to arbitrate admission duels.\n- **Performance**: Achieved a combined score of 0.21, demonstrating excellent filtering on specific static traces (up to 87% hit rate) but failing completely (near 0%) on many others.\n- **Feedback**: While the admission policy effectively isolates high-frequency items in ideal scenarios, the specific aging parameters or Doorkeeper implementation likely cause aggressive forgetting on sparse or dynamic workloads, leading to extreme performance volatility.\n**Program Identifier:** Generation 29 - Patch Name wtinylfu - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU Main Cache**\n- **Implementation**: Combines a 5% Window LRU and a 95% Segmented LRU (Probation/Protected) main cache, using a Doorkeeper-filtered frequency counter to arbitrate eviction between the admission window and the main segment.\n- **Performance**: Achieved a combined score of 0.25, with strong hits on specific frequency-heavy traces but near-zero results on many others.\n- **Feedback**: The static window sizing and specific frequency comparison logic struggle with scan-heavy or shifting workloads, suggesting the need for dynamic region resizing (like Adaptive TinyLFU) to improve robustness.\n**Program Identifier:** Generation 30 - Patch Name wtinylfu_doorkeeper_aging - Correct Program: True\n\n**Program Name: Hybrid W-TinyLFU with FIFO Window and Doorkeeper**\n- **Implementation**: This algorithm integrates a 10% FIFO window with a segmented SLRU main cache, using frequency-based dueling and a Doorkeeper to manage admission and eviction. It features lazy promotion where window items are only moved to the main cache if hit before eviction.\n- **Performance**: It achieves a score of 0.22, excelling in high-frequency scenarios (up to 0.88 hit rate) but failing on scan-heavy or sparse traces (near 0 hit rate).\n- **Feedback**: The combination of S3-FIFO promotion mechanics and TinyLFU frequency tracking provides strong filtering, but the static window sizing and specific aging parameters limit adaptability across diverse workloads.\n**Program Identifier:** Generation 31 - Patch Name s3fifo_tiny_lfu_hybrid - Correct Program: True\n\n**Program Name: WALRUS: Window-LFU with Aging and Ghost Frequencies**\n- **Implementation**: Combines a small FIFO window (10%) for scan resistance with an approximate LFU main segment using random sampling, while tracking ghost frequencies and applying periodic aging (halving counts) to adapt to shifting popularity.\n- **Performance**: Achieves a combined score of 0.24, excelling on frequency-heavy traces (e.g., 0.86 on trace 28) but performing poorly on some specific patterns (e.g., 0.00 on trace 14).\n- **Feedback**: The duel between the FIFO tail and Main segment samples effectively filters one-hit wonders, but the static window size and randomized eviction may lack the precision required for workloads needing strict recency or exact LFU enforcement.\n**Program Identifier:** Generation 32 - Patch Name walrus - Correct Program: True\n\n**Program Name: W-TinyLFU with Segmented LRU and Frequency Admission**\n- **Implementation**: Implements W-TinyLFU using a 1% Window LRU and a Main SLRU (20% Probation, 80% Protected), resolving evictions by comparing access frequencies (with aging) between Window and Probation candidates.\n- **Performance**: Achieves a combined score of 0.21, performing exceptionally well on specific static traces (up to 0.86) but struggling significantly with dynamic or low-locality workloads.\n- **Feedback**: The 1% window size provides strong scan resistance but appears too restrictive for many traces; the frequency-based admission filter likely rejects too many new items in shifting workloads, suggesting a larger window or more lenient admission might improve robustness.\n**Program Identifier:** Generation 33 - Patch Name wtinylfu_slru - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU Segmentation**\n- **Implementation**: Utilizes a 1% LRU window and a Segmented LRU (Probation/Protected) main cache, using a Doorkeeper frequency filter and periodic aging to manage admission via victim dueling.\n- **Performance**: Achieved a score of 0.23, demonstrating excellent filtering on specific workloads (hit rates up to 0.88) but failing significantly on others (near 0).\n- **Feedback**: The small fixed window and strict frequency-based admission effectively prevent cache pollution but hinder adaptation to shifting working sets, resulting in high variance across different access patterns.\n**Program Identifier:** Generation 34 - Patch Name wtinylfu_doorkeeper_aging - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU Structure**\n- **Implementation**: This approach maintains a 1% LRU admission window feeding into a Segmented LRU (SLRU) main cache, employing a Doorkeeper and frequency counters to resolve eviction conflicts between window and main cache candidates.\n- **Performance**: The algorithm yielded a combined score of 0.26, showing high hit rates on static locality traces but failing significantly on several dynamic or scanning workloads.\n- **Feedback**: The rigid 1% window size effectively filters one-time accesses but appears too restrictive for certain patterns, preventing the main cache from populating effectively when admission criteria are not met quickly.\n**Program Identifier:** Generation 35 - Patch Name wtinylfu_doorkeeper_sized - Correct Program: True\n\n**Program Name: Walrus: Window-LFU with Aging and Ghost Frequencies**\n- **Implementation**: Splits cache into a FIFO window and a sampled LFU main segment, using a frequency duel to decide whether to promote window items or evict from main. It tracks global ghost frequencies, applies periodic frequency halving (aging) every `capacity` accesses, and caps frequency counts at 15.\n- **Performance**: Achieved a combined score of 0.24, with high variance ranging from 86% hit rates to complete failure (0.00%) on specific traces.\n- **Feedback**: The periodic aging matches the cache capacity, which likely deletes ghost frequencies too quickly for loops slightly larger than the cache, causing the 0.00 scores. Additionally, the low frequency cap (15) limits the ability to distinguish between highly popular items in skewed workloads.\n**Program Identifier:** Generation 36 - Patch Name walrus_strict_cap - Correct Program: True\n\n**Program Name: Frequency-Enhanced S3-FIFO with Multi-Level Aging**\n- **Implementation**: The algorithm modifies S3-FIFO by replacing binary eviction bits with a 3-bit frequency counter, using a probation queue (Small) and a protected queue (Main) where items are aged by decrementing frequency rather than immediate eviction.\n- **Performance**: It achieved a combined score of 0.24, excelling on frequency-stable workloads (e.g., trace 28 with 0.89) but failing completely on scan-heavy traces (e.g., trace 14 with 0.00).\n- **Feedback**: While the granular frequency counters improve retention for consistently hot items (\"stickiness\"), the slow aging process prevents rapid adaptation to new working sets, causing significant regressions in dynamic or scan-heavy scenarios.\n**Program Identifier:** Generation 37 - Patch Name s3fifo_f - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU Main Cache**\n- **Implementation**: Implements W-TinyLFU using a 5% admission window and an SLRU main cache (80% protected), employing a Doorkeeper and periodic frequency aging for admission arbitration.\n- **Performance**: Achieves a combined score of 0.26, demonstrating strong effectiveness on high-frequency traces (e.g., 0.88 on trace 28) but lower hit rates on sparse workloads.\n- **Feedback**: The combination of TinyLFU admission and SLRU provides robust scan resistance and frequency retention, though the fixed window size limits adaptation to purely recency-driven phases.\n**Program Identifier:** Generation 38 - Patch Name w_tinylfu_doorkeeper_aging - Correct Program: True\n\n**Program Name: W-TinyLFU with Segmented LRU and Doorkeeper**\n- **Implementation**: Combines a 1% FIFO admission window with a Segmented LRU (Probation/Protected) main cache, employing a Doorkeeper and frequency counters with periodic aging for admission control.\n- **Performance**: Achieved a combined score of 0.26, demonstrating strong hit rates on frequency-biased workloads but failing completely on trace 14 (0.0% hit rate).\n- **Feedback**: The aggressive frequency-based filtering works well for stable working sets, but the rigid 1% window size and SLRU management proved brittle, leading to instability on specific access patterns.\n**Program Identifier:** Generation 39 - Patch Name intro_doorkeeper_aging - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU Main Cache and Doorkeeper**\n- **Implementation**: Features a 5% Window LRU and an SLRU main cache (Probation/Protected), using a frequency-based TinyLFU admission policy with a Doorkeeper filter and periodic aging to arbitrate evictions.\n- **Performance**: Achieves a combined score of 0.26, demonstrating strong performance on high-locality workloads (hit rates >0.80) but poor results on sparse or looping patterns.\n- **Feedback**: The combination of Window LRU and SLRU effectively filters one-time access scans, but the static configuration and frequency aging logic struggle to adapt to traces with rapidly shifting or large working sets.\n**Program Identifier:** Generation 40 - Patch Name persistent_dk_and_conditional_growth - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and Strict SLRU Promotion**\n- **Implementation**: Implements a W-TinyLFU architecture with a fixed 1% admission window, frequency-based \"dueling\" eviction, and an SLRU main segment that requires a frequency count > 2 for promotion to the protected region.\n- **Performance**: The algorithm achieves a combined score of 0.25, showing strength in high-repetition traces (e.g., trace 28) but struggling significantly with scanning or low-reuse patterns (e.g., trace 14).\n- **Feedback**: The strict promotion criteria and static tiny window size likely prevent cold items from establishing residence in changing workloads, leading to poor hit rates on traces requiring faster adaptation or larger scan buffers.\n**Program Identifier:** Generation 41 - Patch Name refined_wtinylfu - Correct Program: True\n\n**Program Name: Adaptive W-TinyLFU with Ghost Lists and SLRU**\n- **Implementation**: Combines a W-TinyLFU admission policy with a Segmented LRU (SLRU) main cache, dynamically adjusting the window size based on hits in ghost lists to balance recency and frequency.\n- **Performance**: Achieved a composite score of 0.26, performing exceptionally well on high-frequency traces (up to 88% hit rate) but struggling significantly on trace 14 (0%).\n- **Feedback**: The adaptive window sizing and Doorkeeper mechanism effectively handle varying workloads and scan resistance, though the failure on trace 14 suggests the admission policy or adaptation logic may be overly restrictive or unstable in specific scenarios.\n**Program Identifier:** Generation 42 - Patch Name adaptive_tinylfu - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and Segmented LRU**\n- **Implementation**: Implements W-TinyLFU logic with a 1% Window LRU, a Segmented LRU (Probation/Protected) Main cache, and frequency-based admission using a Doorkeeper.\n- **Performance**: 0.0 overall score; the program failed validation tests.\n- **Feedback**: The eviction strategy contains a critical bug where it returns `None` during the admission duel if the Main cache is empty, causing runtime crashes.\n**Program Identifier:** Generation 43 - Patch Name wtinylfu_approx - Correct Program: False\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU Main Cache**\n- **Implementation**: Uses a 1% LRU window and a 99% SLRU main cache (20% probation/80% protected), employing a Doorkeeper-filtered frequency sketch to duel eviction candidates between the window and main segments.\n- **Performance**: Achieved a combined score of 0.27, performing well on static/Zipfian workloads (up to 0.89 hit rate) but poorly on dynamic or scan-heavy traces.\n- **Feedback**: The rigorous admission policy and SLRU structure effectively filter rare items, but the 1% window size appears too restrictive for workloads relying on immediate recency, leading to near-zero hit rates in several cases.\n**Program Identifier:** Generation 44 - Patch Name tinylfu_opt - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU Main Cache**\n- **Implementation**: This W-TinyLFU variant maintains a 1% LRU window and an SLRU main cache, using a Doorkeeper set for frequency estimation and a specific threshold (>2 accesses) for promotion to the protected segment.\n- **Performance**: The algorithm achieves a combined score of 0.23, performing exceptionally well on frequency-heavy traces (up to 88% hit rate) but poorly on recency-based or scanning workloads.\n- **Feedback**: The static 1% window is likely too restrictive for many access patterns, and the strict admission policy causes significant misses on traces with shifting working sets or low reuse.\n**Program Identifier:** Generation 45 - Patch Name tuned_wtinylfu_params - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU Segmentation**\n- **Implementation**: The algorithm partitions cache into a 5% Window LRU and a segmented Main SLRU (Probation/Protected), using a Doorkeeper filter and frequency-based dueling with periodic aging to govern admission.\n- **Performance**: Achieved a combined score of 0.25, performing exceptionally well on frequency-heavy traces (up to 0.89 hit rate) but failing significantly on scan-heavy workloads (near 0.00).\n- **Feedback**: While the admission policy effectively isolates hot items in stable distributions, the aggressive protection of high-frequency items likely prevents the cache from adapting to new working sets or scans, causing the Window to churn without promoting new content.\n**Program Identifier:** Generation 46 - Patch Name optimize_promotion_and_frequency - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU and Doorkeeper Frequency Filter**\n- **Implementation**: Utilizes a small admission window (2%) and a segmented SLRU (Probation/Protected) for the main cache, employing a frequency-based \"duel\" between window and main victims to determine eviction.\n- **Performance**: Achieved a combined score of 0.26, with strong results on repetitive patterns (e.g., 0.88 on trace 28) but near-zero hit rates on several scan-heavy traces.\n- **Feedback**: The very small window size effectively filters one-time access patterns but likely discards valid items too early in high-churn workloads; adjusting the window ratio or aging mechanism could improve versatility.\n**Program Identifier:** Generation 47 - Patch Name increase_window_and_freq_cap - Correct Program: True\n\n**Program Name: W-TinyLFU Lite with Window-SLRU Segmentation**\n- **Implementation**: Features a 1% LRU Window and a Main SLRU (Probation/Protected) structure, where eviction candidates from the Window duel Probation items based on accumulated frequencies to determine admission.\n- **Performance**: Achieved a combined score of 0.21, demonstrating high variance with excellent hit rates on specific traces (up to 0.87) but near-zero performance on others.\n- **Feedback**: The aggressive 1% window configuration effectively prioritizes high-frequency items in stable workloads but likely discards new items too quickly in dynamic or scan-heavy scenarios, leading to poor adaptability.\n**Program Identifier:** Generation 48 - Patch Name wtinylfu_lite - Correct Program: True\n\n**Program Name: W-TinyLFU Cache with Doorkeeper and Frequency Aging**\n- **Implementation**: Implements a segmented cache (Window, Probation, Protected) with TinyLFU-style admission, using a Doorkeeper for new items and periodic frequency halving to adapt to shifts.\n- **Performance**: Achieved a score of 0.24, showing high hit rates on looping traces (e.g., 0.88 on trace 28) but near-zero on several others.\n- **Feedback**: The frequency-based admission effectively filters pollution in stable workloads, but the small fixed window (5%) may be insufficient for capturing transient locality or scans.\n**Program Identifier:** Generation 49 - Patch Name tune_wtinylfu_params - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper, Aging, and Biased Protection**\n- **Implementation**: Uses a 1% admission window and SLRU main cache, featuring a size-limited Doorkeeper, frequency aging every 5x capacity, and an admission duel heavily biased towards retaining main cache items.\n- **Performance**: The algorithm achieved a combined score of 0.27, excelling on stable workloads but performing poorly on dynamic traces.\n- **Feedback**: The strong bias favoring main cache retention (requiring window frequency > main frequency + 1) likely prevents the cache from adapting quickly to new working sets, creating resistance to workload changes.\n**Program Identifier:** Generation 50 - Patch Name wtinylfu_biased_dk_refined - Correct Program: True\n\n**Program Name: Biased W-TinyLFU with Size-Based Doorkeeper**\n- **Implementation**: Implements W-TinyLFU with a 1% admission window and SLRU main cache, employing a biased eviction duel (`window_freq > main_freq + 1`) to favor retaining existing items and a Doorkeeper reset triggered by capacity thresholds.\n- **Performance**: Achieved a combined score of 0.27, performing strongly on repetitive workloads (e.g., 0.89 on trace 28) but poorly on scan-heavy traces (e.g., 0.00 on trace 14).\n- **Feedback**: The biased duel effectively stabilizes the cache against churn by requiring significant frequency evidence for admission, but the small window size leaves the algorithm vulnerable to rapid access pattern changes.\n**Program Identifier:** Generation 51 - Patch Name wtinylfu_biased - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU**\n- **Implementation**: This policy integrates a 1% Window LRU with a Segmented LRU (Probation/Protected) Main cache, employing a Doorkeeper mechanism to filter rare items before tracking their frequency for TinyLFU-based admission duels.\n- **Performance**: The algorithm achieved a combined score of 0.26, performing exceptionally well on high-locality traces (up to 88%) but suffering near-zero hit rates on several specific workloads.\n- **Feedback**: While the Doorkeeper and SLRU structure effectively manage established hot items, the extremely small window size combined with the specific admission filtering likely caused the poor performance on traces requiring faster adaptation or larger capture buffers.\n**Program Identifier:** Generation 52 - Patch Name optimize_tinylfu_parameters_and_logic - Correct Program: True\n\n**Program Name: W-TinyLFU with Static Window and Frequency Sketch**\n- **Implementation**: Implements W-TinyLFU using a 1% Window LRU and segmented Main LRU (Probation/Protected) governed by a TinyLFU admission policy with a frequency dictionary and Doorkeeper set.\n- **Performance**: Achieved a combined score of 0.21, performing well on high-locality workloads but suffering near-zero hit rates on scan-heavy traces.\n- **Feedback**: The static 1% window size is likely too small for recency-heavy workloads, and the lack of adaptive sizing prevents the cache from adjusting to varying traffic patterns effectively.\n**Program Identifier:** Generation 53 - Patch Name wtinylfu_opt - Correct Program: True\n\n**Program Name: Adaptive S3-FIFO with ARC-style Ghosts**\n- **Implementation**: Implements a two-queue system (Small/Main) where the Small queue's size dynamically adjusts based on ghost list hits, mimicking ARC's adaptive logic. Uses hit counts for second-chance promotion from Small to Main and retention within Main.\n- **Performance**: Combined score of 0.24; performs well on select traces but poorly on many others (e.g., < 5% hit rate).\n- **Feedback**: The adaptation logic appears unstable, leading to cache thrashing on specific workloads; while the ghost-based resizing is clever, it often fails to retain the working set effectively compared to simpler static policies.\n**Program Identifier:** Generation 54 - Patch Name adaptive_s3_fifo - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU Main Cache and Doorkeeper**\n- **Implementation**: Implements a Window-TinyLFU architecture using a 5% admission window, a Segmented LRU (SLRU) main cache, and a Doorkeeper-based frequency counter with periodic aging.\n- **Performance**: Achieved a combined score of 0.26, performing well on high-frequency traces (0.76-0.88) but poorly on scan-heavy or looping workloads (0.00-0.02).\n- **Feedback**: The combination of SLRU and frequency-based admission effectively protects hot items in static distributions, but the static window size or admission duel appears too rigid for scans or shifting working sets where new items fail to displace incumbents.\n**Program Identifier:** Generation 55 - Patch Name improved_tinylfu_eviction - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and Adaptive Frequency Aging**\n- **Implementation**: Combines a small admission Window with an SLRU main cache, using a Doorkeeper to filter rare items and halving frequencies every 5x capacity. Eviction relies on a duel between Window and Main victims, biased to favor the Main cache unless the new item has a strictly higher frequency.\n- **Performance**: Achieved a combined score of 0.25, excelling on stable traces (e.g., 0.88 hit rate) but performing poorly on high-churn or scanning workloads.\n- **Feedback**: The biased eviction and slow aging (5x capacity) effectively protect against pollution in static environments but make the cache too rigid to adapt to shifting working sets or distinct phases.\n**Program Identifier:** Generation 56 - Patch Name optimize_parameters_and_duel - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and Biased Window Duel**\n- **Implementation**: This W-TinyLFU adaptation employs a 1% admission window, segmented SLRU main cache, and a size-resetting Doorkeeper, determining eviction via a duel that strongly biases against window admission.\n- **Performance**: The algorithm achieved a combined hit rate of 0.27, performing well on static frequency distributions but poorly on traces with rapid churn or scans.\n- **Feedback**: The strong bias against admitting items from the small window effectively protects the cache from pollution but hinders adaptation to shifting workloads, resulting in near-zero hit rates on specific dynamic traces.\n**Program Identifier:** Generation 57 - Patch Name wtinylfu_optimized - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and Aggressive Admission Policy**\n- **Implementation**: Combines a 1% LRU window and an SLRU main cache, using a Doorkeeper-filtered frequency counter with periodic aging. The eviction policy heavily biases against new items, requiring the window candidate's frequency to strictly exceed the main candidate's by a margin (`fw > fm + 1`) to survive.\n- **Performance**: The algorithm achieves a combined score of 0.27, showing strong locality capture on some traces but failing completely (near 0% hit rate) on others.\n- **Feedback**: The strict admission criteria and tiny window size likely prevent the cache from adapting to shifts in the working set, as new items are evicted before they can accumulate enough frequency to displace existing entries.\n**Program Identifier:** Generation 58 - Patch Name w_tinylfu_doorkeeper_optimized - Correct Program: True\n\n**Program Name: Optimized W-TinyLFU with Doorkeeper and SLRU**\n- **Implementation**: Combines a small 1% Window LRU and 99% SLRU Main cache with Doorkeeper frequency tracking, employing a biased eviction duel that aggressively protects Main items with any history (`freq > 0`) over growing the Window.\n- **Performance**: Achieved a combined score of 0.26, showing high hit rates on stable distributions but near-zero performance on several dynamic or scan-heavy traces.\n- **Feedback**: The \"Spare Main\" logic is likely too conservative, causing new items in the Window to be evicted immediately if the Main victim has any frequency count; this prevents the Window from effectively filtering new content and adapting to workload changes.\n**Program Identifier:** Generation 59 - Patch Name optimized_wtinylfu_slru - Correct Program: True\n\n**Program Name: Adaptive W-TinyLFU with ARC-style Ghost Sizing**\n- **Implementation**: Combines W-TinyLFU's frequency-based admission and SLRU main cache with ARC's ghost entry mechanism to dynamically adjust the window-to-main ratio based on recent eviction patterns.\n- **Performance**: Score: 0.0 (Failed validation due to runtime error).\n- **Feedback**: The algorithm crashes because the `capacity` variable is accessed but not defined in the `update_after_evict` function; ensuring correct variable scope from the `cache_snapshot` is necessary for functionality.\n**Program Identifier:** Generation 60 - Patch Name adaptive_tiny_lfu - Correct Program: False\n\n**Program Name: W-TinyLFU with Doorkeeper, SLRU, and Biased Eviction**\n- **Implementation**: The algorithm maintains a small Window LRU and a Segmented LRU Main cache, managing admission via a Doorkeeper and frequency counters with a bias towards retaining Main items. It employs periodic frequency aging and Doorkeeper resets based on cache capacity to limit metadata growth.\n- **Performance**: With a combined score of 0.27, the cache excels at static frequency retention but fails significantly on dynamic or looping traces (e.g., trace 14).\n- **Feedback**: The implementation prioritizes stability through biased eviction, but the conservative aging strategy leads to cache pollution by obsolete high-frequency items, hurting performance during workload shifts.\n**Program Identifier:** Generation 61 - Patch Name tune_aging_and_doorkeeper - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU**\n- **Implementation**: Implements Window-TinyLFU with a 1% LRU window and a 99% SLRU main cache, utilizing a Doorkeeper-filtered frequency map to duel eviction candidates between the window and main cache.\n- **Performance**: The algorithm achieved a combined score of 0.27, excelling on specific repetitive traces (up to 0.88 hit rate) but performing poorly (near 0) on many others.\n- **Feedback**: The extremely small admission window (1%) likely filters out valid content too aggressively in dynamic workloads, suggesting a larger window or adaptive sizing is needed to handle diverse access patterns.\n**Program Identifier:** Generation 62 - Patch Name optimize_tinylfu_params_and_logic - Correct Program: True\n\n**Program Name: W-TinyLFU with Segmented SLRU and Doorkeeper Filter**\n- **Implementation**: Implements a 5% LRU admission window and a segmented SLRU main cache (Probation/Protected), guarded by a frequency filter using a Doorkeeper and periodic aging.\n- **Performance**: Achieves a combined score of 0.26, excelling on high-locality traces (e.g., Trace 28) but failing near-completely on specific patterns like Trace 14.\n- **Feedback**: The strict incumbent bias (`fw > fm + 1`) during eviction effectively filters pollution but likely prevents the cache from adapting quickly enough to shifting working sets in scanning workloads.\n**Program Identifier:** Generation 63 - Patch Name wtinylfu_hysteresis_dk_lru - Correct Program: True\n\n**Program Name: Optimized W-TinyLFU with SLRU Main Cache**\n- **Implementation**: Combines a small 1% admission window with a Segmented LRU (SLRU) main cache, utilizing a frequency sketch with a Doorkeeper mechanism and a low maximum frequency cap for fast adaptation.\n- **Performance**: Achieves a combined score of 0.27, showing excellent results on stationary workloads (up to 89%) but poor handling of certain dynamic traces (0% on trace 14).\n- **Feedback**: The implementation's strict incumbency bias effectively protects hot items in the SLRU, though the very small window size limits its ability to handle patterns relying heavily on recent insertion history.\n**Program Identifier:** Generation 64 - Patch Name wtinylfu_optimized - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU and Adaptive Incumbency Bias**\n- **Implementation**: Utilizes a 1% window and 99% SLRU main segment, employing a frequency sketch with a \"doorkeeper\" and an eviction duel where window candidates must exceed the main candidate's frequency plus a dynamic bias (boosted if recently demoted) to enter.\n- **Performance**: Achieves a combined score of 0.27, excelling on static frequency-heavy workloads (e.g., 0.89 hit rate) but failing significantly on dynamic traces (several near 0%).\n- **Feedback**: The small window combined with a high barrier to entry (strong incumbency bias) makes the cache highly resistant to pollution but too rigid, failing to admit new items in changing workloads.\n**Program Identifier:** Generation 65 - Patch Name wtinylfu_bias - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and Tuned SLRU**\n- **Implementation**: Implements a W-TinyLFU structure with a 1% admission window and an SLRU main cache, utilizing a Doorkeeper mechanism and frequency-based duels with adaptive aging for eviction decisions.\n- **Performance**: The approach yields a combined score of 0.27, performing well on frequency-heavy workloads but failing completely (0.0 hit rate) on trace 14.\n- **Feedback**: The extremely small window size and strict admission filtering provide strong scan resistance but likely cause the zero hit rates by rejecting new working sets too aggressively.\n**Program Identifier:** Generation 66 - Patch Name wtinylfu_opt_hybrid - Correct Program: True\n\n**Program Name: W-TinyLFU with Biased Eviction and 1% Window**\n- **Implementation**: Combines an SLRU main cache with a fixed 1% admission window and a Doorkeeper-based frequency filter, employing a biased eviction duel that strictly favors retaining main cache items unless window candidates have significantly higher frequency.\n- **Performance**: Achieved a combined score of 0.27, performing well on static heavy-hitter workloads (up to 89% hit rate) but poorly on dynamic or scan-heavy traces.\n- **Feedback**: The tiny window size and high barrier to entry (biased eviction) make the cache too conservative, failing to adapt quickly to shifting working sets while successfully filtering one-time access noise.\n**Program Identifier:** Generation 67 - Patch Name optimize_wtinylfu_window_and_aging - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU and Doorkeeper Aging**\n- **Implementation**: This algorithm employs a Window-TinyLFU architecture with a 5% admission window and a Segmented LRU (Probation/Protected) main cache, utilizing a Doorkeeper and frequency counters with periodic halving to manage admission.\n- **Performance**: The approach yields a combined score of 0.26, performing well on static frequency patterns (up to 0.88 hit rate) but struggling significantly with large scans and high-churn traces.\n- **Feedback**: While the Doorkeeper mechanism correctly filters one-hit wonders, the fixed window size and strict admission bias (`fw > fm + 1`) likely hinder adaptation to dynamic workloads or loops where looser admission or faster adaptability is required.\n**Program Identifier:** Generation 68 - Patch Name init_doorkeeper_ordered_dict - Correct Program: True\n\n**Program Name: Optimized W-TinyLFU with SLRU and Biased Admission**\n- **Implementation**: Combines a 1% LRU window and an 80% protected SLRU main cache with frequency tracking via a doorkeeper and periodic aging.\n- **Performance**: Achieves a score of 0.27 with strong results on repeated access patterns (up to 0.89 hit rate) but low hit rates on scan-heavy traces.\n- **Feedback**: The tiny window and biased admission logic successfully filter one-hit wonders, but the static 1% window size might be too aggressive for workloads requiring higher recency retention.\n**Program Identifier:** Generation 69 - Patch Name slower_aging - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper, SLRU, and Frequency Aging**\n- **Implementation**: Combines a 1% LRU admission window with a segmented LRU (SLRU) main cache, using a Doorkeeper-filtered frequency map and periodic aging to arbitrate eviction duels.\n- **Performance**: Achieved a combined score of 0.23, excelling on highly skewed workloads (up to 88% hit rate) but failing near-completely on scan-heavy traces.\n- **Feedback**: The static 1% window size is efficient for filtering rare items in stable distributions but proves too rigid for workloads requiring larger admission buffers to capture shifting locality.\n**Program Identifier:** Generation 70 - Patch Name wtinylfu_slru_refined - Correct Program: True\n\n**Program Name: Segment-Aware W-TinyLFU with High-Res Frequency and Tuned Aging**\n- **Implementation**: Combines a 1% Window with an SLRU Main cache, utilizing a segmented eviction policy that strictly protects \"Protected\" items (`freq_window > freq_main + 1`) while enabling fair duels for \"Probation\" items. It tracks popularity using 31-point frequency counters with slow 10x capacity aging.\n- **Performance**: Achieves a score of 0.25, showing high hit rates on static workloads (up to 0.88) but near-zero performance on many dynamic traces.\n- **Feedback**: The defensive eviction logic strongly favors established items, but combined with a tiny window and slow aging, it prevents the cache from adapting to new patterns, causing severe failures on shifting working sets.\n**Program Identifier:** Generation 71 - Patch Name segment_aware_wtinylfu - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU**\n- **Implementation**: Implements a W-TinyLFU architecture with a small 1% admission window and a segmented SLRU main cache, utilizing a Doorkeeper mechanism and frequency counting with periodic aging to manage cache admission.\n- **Performance**: Achieved a combined score of 0.26, demonstrating strength in high-locality scenarios but struggling significantly with scan-heavy or shifting workloads (e.g., 0.00% on trace 14).\n- **Feedback**: The static 1% window size appears too small to capture transient locality effectively in some traces, and the strict admission bias may be preventing new working sets from populating the main cache.\n**Program Identifier:** Generation 72 - Patch Name wtinylfu_slru_crossover - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU**\n- **Implementation**: Combines a 1% LRU window with a 99% SLRU main cache (20% probation, 80% protected), using a Doorkeeper mechanism and frequency map to adjudicate eviction duels between window and main candidates.\n- **Performance**: Achieved a combined score of 0.24, showing strong results on specific stable workloads (e.g., traces 27-28) but failing significantly on many others (near zero on traces 13-19).\n- **Feedback**: The extremely small admission window (1%) likely causes high churn for new items in dynamic workloads, and the admission duel appears too restrictive, preventing the cache from adapting to shifting popularity patterns.\n**Program Identifier:** Generation 73 - Patch Name segment_aware_duel_and_fast_promotion - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU and Segmented Duel Bias**\n- **Implementation**: Combines a 1% LRU admission window with an SLRU main cache, utilizing a frequency-based eviction duel that applies a specific bias (+2) to defend items in the Protected segment alongside periodic aging.\n- **Performance**: Achieved a combined score of 0.26, demonstrating high hit rates on stable frequency-heavy traces but failing significantly on dynamic or scan-heavy workloads.\n- **Feedback**: The small window size and strong protection bias likely prevent the cache from adapting to new hot items in changing workloads; relaxing the admission criteria or implementing dynamic resizing could improve robustness across diverse traces.\n**Program Identifier:** Generation 74 - Patch Name wtinylfu_adaptive_bias - Correct Program: True\n\n**Program Name: W-TinyLFU with Segmented Duel and Adaptive Aging**\n- **Implementation**: This W-TinyLFU variant employs a 1% admission window and an SLRU main cache, using a doorkeeper-enhanced frequency sketch with an aging mechanism that halves counts every 5x capacity.\n- **Performance**: Achieved a combined score of 0.25, demonstrating strong results on static frequency patterns (e.g., 0.89 on trace 28) but struggling significantly with high-churn workloads (e.g., <0.03 on trace 14).\n- **Feedback**: The implementation's bias towards keeping protected items and its small window size offer stability for established hot data but hinder the algorithm's ability to adapt quickly to shifting access patterns.\n**Program Identifier:** Generation 75 - Patch Name refined_wtinylfu_adaptive - Correct Program: True\n\n**Program Name: Biased W-TinyLFU with SLRU and Doorkeeper**\n- **Implementation**: Combines a 1% FIFO window with an SLRU main cache, utilizing a frequency-based eviction duel with specific bias for incumbent and recently demoted items.\n- **Performance**: Achieved a combined score of 0.27, performing well on high-locality traces but failing significantly on several specific scan-like patterns.\n- **Feedback**: The heavy bias towards the main cache protects popular items well, but the small static window and strict admission likely hinder performance on shifting workloads.\n**Program Identifier:** Generation 76 - Patch Name wtinylfu_demotion_bias - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU and Segment-Aware Frequency Dueling**\n- **Implementation**: This algorithm employs a 1% LRU Window and an SLRU main cache (Probation/Protected), utilizing a Doorkeeper-based frequency sketch with periodic aging for admission control. The eviction policy features a segment-aware duel that protects high-frequency items by requiring strictly higher frequency from the Window victim to displace Protected items.\n- **Performance**: The solution achieved a combined score of 0.24, demonstrating strong results on frequency-biased traces but suffering from near-zero hit rates on several scan-heavy or sparse workloads.\n- **Feedback**: While the segment-aware dueling logic effectively preserves popular data, the 1% window size appears too restrictive for traces requiring rapid adaptation, suggesting a need for a dynamic window size or less aggressive filtering.\n**Program Identifier:** Generation 77 - Patch Name wtinylfu_segment_aware - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU Main Cache and Frequency Sketch**\n- **Implementation**: Utilizes a 1% Window LRU and an SLRU main cache (Probation/Protected), employing a frequency sketch with a doorkeeper and periodic aging to manage eviction via admission duels.\n- **Performance**: Achieved a combined score of 0.21, exhibiting high variance with strong results on static patterns (0.87) but near-zero hit rates on dynamic traces.\n- **Feedback**: The fixed 1% window size is likely too restrictive for workloads with shifting working sets, preventing new items from establishing residency, while the aggressive admission policy leads to starvation in several scenarios.\n**Program Identifier:** Generation 78 - Patch Name wtinylfu_opt - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU and Periodic Doorkeeper**\n- **Implementation:** Maintains a 1% LRU window and an SLRU main cache, utilizing frequency density duels for admission and a Doorkeeper that resets periodically to mitigate scan impact.\n- **Performance:** Achieves a combined score of 0.26, performing well on static locality traces (up to 89%) but failing near-completely on several dynamic patterns.\n- **Feedback:** The fixed 1% window size is too aggressive for traces with moderate reuse distances, and the strict admission policy likely prevents necessary cache population in sparse or looping workloads.\n**Program Identifier:** Generation 79 - Patch Name density_tinylfu_tuned - Correct Program: True\n\n**Program Name: Optimized W-TinyLFU with SLRU and Doorkeeper**\n- **Implementation**: Combines a small Window (1%) with a Segmented LRU (Probation/Protected) for the main cache, using a TinyLFU admission policy that duels eviction candidates based on frequencies tracked by a Doorkeeper set and aging counters.\n- **Performance**: Achieves a combined score of 0.23, with high hit rates on repetitive traces but near-zero performance on scanning workloads.\n- **Feedback**: The strict frequency-based admission and strong bias towards keeping 'Protected' items maximize hit rates for static distributions, but significantly hinder the cache's ability to adapt to scanning patterns or rapid working set changes.\n**Program Identifier:** Generation 80 - Patch Name wtinylfu_slru_opt - Correct Program: True\n\n**Program Name: Optimized W-TinyLFU with Doorkeeper and SLRU**\n- **Implementation**: Implements Window-TinyLFU with a 1% window and 99% SLRU main cache, featuring a Doorkeeper for admission filtering and frequency-based dueling. It adds specific optimizations like sketch-accelerated promotion and \"second chance\" credits for demoted protected items.\n- **Performance**: Achieved a combined score of 0.23, with strong results on static working sets (up to 88%) but poor performance on scan-heavy traces.\n- **Feedback**: The very small window (1%) combined with aggressive admission filtering likely caused the poor performance on scans and looping patterns, as new items were evicted before proving their worth against the established main cache.\n**Program Identifier:** Generation 81 - Patch Name wtinylfu_opt_v2 - Correct Program: True\n\n**Program Name: W-TinyLFU with Two-Hit Promotion and Demotion Bias**\n- **Implementation**: This W-TinyLFU variant uses a 1% window and segmented main cache, requiring two hits to promote from Probation while granting strong frequency bias (5) to demoted items during eviction duels.\n- **Performance**: It achieves a combined score of 0.26, performing well on stable working sets (up to 89% hit rate) but poorly on dynamic or scan-heavy workloads.\n- **Feedback**: The aggressive incumbency protection and strict promotion criteria effectively filter noise but likely hinder the cache's ability to adapt quickly to shifting access patterns.\n**Program Identifier:** Generation 82 - Patch Name adaptive_w_tiny_lfu_plus - Correct Program: True\n\n**Program Name: Segment-Aware W-TinyLFU with Adaptive Aging and Bias**\n- **Implementation**: Uses a 1% admission window feeding an SLRU (Probation/Protected) structure, where eviction decisions rely on frequency comparisons biased to favor Protected items against new admissions.\n- **Performance**: Combined score of 0.24, performing well on stable distributions (up to 0.88 hit rate) but failing significantly on traces with high churn or scanning patterns.\n- **Feedback**: The restrictive 1% window and specific protection bias (+1) appear to hinder adaptability in dynamic workloads, causing useful new items to be rejected too early in high-turnover scenarios.\n**Program Identifier:** Generation 83 - Patch Name segment_aware_wtinylfu - Correct Program: True\n\n**Program Name: W-TinyLFU with Ghost Shield for Demoted Items**\n- **Implementation**: Implements W-TinyLFU with a segmented main cache (Probation/Protected) and a frequency-based eviction duel that applies a \"Ghost Shield\" bias to protect items recently demoted from the protected segment.\n- **Performance**: Achieved a combined score of 0.26, demonstrating strong performance on high-locality traces (up to 0.89) but failing significantly on scan-heavy workloads (near 0.00).\n- **Feedback**: The heavy bias towards protecting demoted incumbents helps in stable workloads but likely prevents the cache from adapting quickly enough to new content in high-churn or scanning scenarios.\n**Program Identifier:** Generation 84 - Patch Name wtinylfu_ghost_shield - Correct Program: True\n\n**Program Name: W-TinyLFU with Segmented SLRU and Doorkeeper**\n- **Implementation**: Utilizes a 5% Window LRU and a segmented Main SLRU (Probation/Protected) governed by a frequency-based admission policy with a Doorkeeper filter and periodic aging.\n- **Performance**: Achieves a composite score of 0.24, demonstrating strong performance on high-locality traces (up to 0.88) but poor handling of scan-heavy workloads (often <0.05).\n- **Feedback**: The implementation of TinyLFU admission effectively prevents cache pollution, but the small fixed window size limits its ability to adapt to workloads requiring larger immediate buffers or cyclic access patterns.\n**Program Identifier:** Generation 85 - Patch Name segment_aware_duel_and_dk_reset - Correct Program: True\n\n**Program Name: W-TinyLFU with Segmented SLRU and Doorkeeper Admission**\n- **Implementation**: Combines a 1% LRU window with an SLRU main cache (Probation/Protected), managing eviction via a frequency-based duel utilizing a Doorkeeper and aging counters.\n- **Performance**: Achieved a score of 0.24, with high hit rates on stable distributions but near-zero performance on high-churn or scan-heavy workloads.\n- **Feedback**: The static 1% window size proved too small for diverse workloads, and the admission policy likely prevented adapting to shifting working sets in dynamic traces.\n**Program Identifier:** Generation 86 - Patch Name wtinylfu_optimized - Correct Program: True\n\n**Program Name: Adaptive W-TinyLFU with SLRU and Frequency Sketch**\n- **Implementation**: Combines a small 1% recency window with a Segmented LRU (SLRU) main cache, utilizing a frequency sketch with a doorkeeper and periodic aging to manage admission between segments.\n- **Performance**: Achieved a combined score of 0.24, excelling on frequency-heavy traces (reaching 0.88 hit rate) but performing poorly on scan-based workloads (often near 0.0).\n- **Feedback**: The 1% window size is overly aggressive, causing the cache to fail on scan patterns where items are evicted before accumulating the frequency required to pass the admission filter into the main cache.\n**Program Identifier:** Generation 87 - Patch Name wtinylfu_adaptive - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and SLRU Fast Promotion**\n- **Implementation**: This approach combines a tiny 1% LRU window with an SLRU main cache, utilizing a Doorkeeper to filter one-hit wonders and a fast promotion mechanism to move high-frequency items directly to the protected segment.\n- **Performance**: Achieved a combined score of 0.26, excelling on stable patterns (e.g., 0.89 on trace 28) but failing completely on specific dynamic traces (0.00 on trace 14).\n- **Feedback**: The eviction policy's tie-breaking favors incumbent items over new window candidates; this rigidity, coupled with the very small window, prevents the cache from adapting to new working sets in looping or scanning workloads.\n**Program Identifier:** Generation 88 - Patch Name segment_aware_eviction_fast_prom - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and Adaptive SLRU**\n- **Implementation**: Features a 1% LRU window feeding an SLRU main cache, utilizing a Doorkeeper and frequency counters with periodic aging to filter admissions.\n- **Performance**: Achieved a combined score of 0.24, with high effectiveness on stable locality traces but poor results on dynamic or scan-heavy workloads.\n- **Feedback**: The tiny window size and strict admission policy hinder adaptation to shifting working sets, causing near-zero hit rates on several traces.\n**Program Identifier:** Generation 89 - Patch Name segment_aware_duel_and_dk_tuning - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and Aggressive 1% Window**\n- **Implementation**: Implements W-TinyLFU with a static 1% window, 80/20 SLRU main cache, and Doorkeeper-filtered frequency counters with periodic aging.\n- **Performance**: Combined score of 0.26, showing strong results on frequency-skewed traces but near-zero hit rates on scan-heavy workloads.\n- **Feedback**: The 1% window is too small to capture working sets in scan or loop patterns (traces 13-19); increasing or adapting the window size would improve versatility.\n**Program Identifier:** Generation 90 - Patch Name wtinylfu_optimized - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and Static Window SLRU**\n- **Implementation**: This W-TinyLFU variant uses a static 5% LRU window and a segmented SLRU main cache, deciding eviction via a \"duel\" between candidates based on frequency counts tracked with a Doorkeeper and periodic halving.\n- **Performance**: The algorithm achieves a combined score of 0.23, showing strong results on frequency-biased traces but near-zero hit rates on several others.\n- **Feedback**: The use of a Doorkeeper and frequency constraints effectively filters low-value items in skewed distributions, but the static window size likely limits performance on recency-heavy or scanning workloads.\n**Program Identifier:** Generation 91 - Patch Name improved_evict_and_doorkeeper - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU and Demotion Bias**\n- **Implementation**: Utilizes a 1% admission window and an 80% protected SLRU main cache, employing a frequency sketch with a doorkeeper and a frequency bias (+4) for items demoted from protected status during eviction duels.\n- **Performance**: The algorithm achieves a combined score of 0.25, with strong performance on stable traces (up to 0.89) but near-zero hit rates on high-churn workloads.\n- **Feedback**: While the demotion bias and large protected segment effectively retain established hot items, the tiny fixed window size significantly hampers the ability to ingest new content in dynamic or scanning access patterns.\n**Program Identifier:** Generation 92 - Patch Name wtinylfu_bias_fix_aging - Correct Program: True\n\n**Program Name: W-TinyLFU with Doorkeeper and Segmented LRU**\n- **Implementation**: Uses a 1% admission window feeding into a Segmented LRU main cache (80% protected), guarded by a frequency sketch with a Doorkeeper and biased dueling for admission.\n- **Performance**: Achieved a combined hit rate score of 0.27, excelling on static locality traces but struggling with certain dynamic or scan-heavy patterns.\n- **Feedback**: The combination of SLRU and frequency-based filtering provides robust protection for hot items, though the small fixed window size may hinder rapid adaptation to new working sets.\n**Program Identifier:** Generation 93 - Patch Name size_aware_wtinylfu - Correct Program: True\n\n**Program Name: W-TinyLFU with Segmented Bias and Accelerated Promotion**\n- **Implementation**: Uses a 1% LRU window and SLRU main cache with frequency-based admission, adding bias to protected items and allowing high-frequency items to bypass probation.\n- **Performance**: Achieved a score of 0.27, showing strong results on stable traces (0.89 hit rate) but failing completely on others (0.00 hit rate).\n- **Feedback**: The small window and static bias favor established items too heavily, causing inability to adapt to new patterns or handle scans effectively in diverse workloads.\n**Program Identifier:** Generation 94 - Patch Name wtinylfu_seg_bias_accel - Correct Program: True\n\n**Program Name: Optimized W-TinyLFU with Segment-Aware SLRU and Doorkeeper**\n- **Implementation**: Combines a 1% Window LRU and an SLRU main cache (80% protected) with frequency-based admission using a doorkeeper and biased eviction logic to favor protected items.\n- **Performance**: Achieved a combined score of 0.24, demonstrating strong performance on stable workloads (up to 88%) but struggling significantly on dynamic or scan-heavy traces.\n- **Feedback**: While the small window and aggressive protection logic effectively maintain established working sets, they hinder the cache's ability to quickly admit new items during shifts in access patterns.\n**Program Identifier:** Generation 95 - Patch Name update_docstring - Correct Program: True\n\n**Program Name: Window-TinyLFU with Doorkeeper and Segmented LRU**\n- **Implementation**: Implements a 5% Window and 95% SLRU (Probation/Protected) cache, using a Doorkeeper mechanism and frequency-based duels to determine whether to evict window or main cache victims.\n- **Performance**: Achieved a combined score of 0.24, with strong hit rates on stable frequency traces (up to 0.88) but near-zero performance on several dynamic or scan-heavy traces.\n- **Feedback**: The admission policy effectively prioritizes high-frequency items, but the rigid window size and aggressive filtering likely cause the significant drops in performance on traces requiring faster adaptation or larger scan resistance.\n**Program Identifier:** Generation 96 - Patch Name tuned_wtinylfu_slru_v2 - Correct Program: True\n\n**Program Name: W-TinyLFU with Adaptive Bias and 1% Window**\n- **Implementation**: Combines a small 1% admission window with an SLRU main segment, using a frequency sketch with \"doorkeeper\" filtering and adaptive eviction bias that protects established items over new candidates.\n- **Performance**: Achieved a combined score of 0.26, performing well on static patterns but struggling significantly on dynamic traces (e.g., <3% on traces 13-19).\n- **Feedback**: The adaptive bias helps retain high-frequency items, but the strict 1% window and strong protection mechanism may be too rigid for workloads where the active set changes frequently.\n**Program Identifier:** Generation 97 - Patch Name wtinylfu_adaptive_bias - Correct Program: True\n\n**Program Name: W-TinyLFU with Sketch-Accelerated Promotion**\n- **Implementation**: Combines a tiny 1% Window and SLRU with frequency-based admission, featuring \"sketch-accelerated\" promotion where high-frequency window items skip probation and segment-specific tie-breaking during eviction duels.\n- **Performance**: Achieved a score of 0.24, showing strong results on specific high-locality traces (e.g., trace 28) but failing significantly on scan-heavy or dynamic workloads.\n- **Feedback**: The 1% window is likely too restrictive for capturing recency bursts or shifting working sets, and the static frequency threshold for promotion limits adaptability across diverse access patterns.\n**Program Identifier:** Generation 98 - Patch Name wtinylfu_specialized_slru - Correct Program: True\n\n**Program Name: W-TinyLFU with SLRU Segmentation and Frequency Aging**\n- **Implementation**: Combines a small 1% Window LRU with a Main SLRU (Probation/Protected) cache, utilizing a Doorkeeper and frequency counters with aging to arbitrate eviction via a \"dueling\" admission policy.\n- **Performance**: Achieves a combined score of 0.23, demonstrating strong results on frequency-heavy traces (up to 0.88) but struggling significantly with scanning or loop patterns (<0.05).\n- **Feedback**: The small, static window size limits effectiveness on recency-dominated workloads, suggesting a need for adaptive sizing or a larger initial window to handle changing access patterns better.\n**Program Identifier:** Generation 99 - Patch Name improved_wtinylfu_slru - Correct Program: True",
  "meta_scratch_pad": "Based on the analysis of the individual program summaries (Generations 90-99) and the Current Best Program, here are the actionable optimization insights.\n\n## Successful Algorithmic Patterns\n- **Adaptive Window Sizing via Victim Inspection**: The **Current Best Program** (Score 0.27) implements a logic where the Window is prevented from filling to its reserved capacity if the Main cache candidate is valuable (`if fm > 0: return cand_w_key`). This effectively lends the Window's capacity to the Main cache when Main items are \"warm,\" optimizing storage utilization dynamically rather than rigidly enforcing the 1% reservation as seen in **Generation 90**.\n- **Threshold-Gated Accelerated Promotion**: The **Current Best Program** successfully employs \"Sketch-Accelerated Promotion\" by using a strict high-frequency threshold (`freq >= 5`) to bypass the Probation segment. Unlike **Generation 88** which failed with faster promotion, this high threshold filters out noise while capturing truly hot items, contributing to the 0.27 score.\n- **Graceful Segment Demotion**: A consistent pattern in top performers (**Current Best**, **Generation 93**) is handling Protected segment overflow by demoting items to the MRU of the Probation segment. This grants established items a \"second chance\" to compete via frequency checks, proving superior to immediate eviction policies.\n\n## Ineffective Approaches\n- **Static Window Expansion (5%)**: **Generation 91** and **Generation 96** increased the Window size to 5% to address scan-heavy workloads (Traces 13-19). This resulted in a significant score drop to 0.23-0.24 compared to the 1% baseline (0.26-0.27). The reduction in Main cache capacity (SLRU) disproportionately lowered hit rates on high-locality traces (e.g., Trace 28) compared to the marginal gains on scans.\n- **Rigid Protection without Fast Paths**: **Generation 95** (Score 0.24) used aggressive protection logic without the \"fast path\" promotion for high-frequency items. Evaluation suggests that without the ability for bursty, high-frequency items to bypass the Probation queue (`freq >= 5` logic in Best Program), the cache reacts too slowly to shifting working sets.\n\n## Implementation Insights\n- **Conditional Window Growth**: The **Current Best Program** uses an explicit check `if algo_state['window_size'] < w_cap` combined with `if fm > 0` to decide eviction. This specific implementation turns the Window into a dynamic buffer that only claims space if the Main cache victim is cold (freq 0), maximizing the effective size of the SLRU for hot workloads.\n- **High-Pass Frequency Filter**: The specific conditional `if freq >= 5:` inside `update_after_insert` in the **Current Best Program** acts as a high-pass filter. Tuned against a max frequency of 15, this integer threshold effectively distinguishes \"sustainably hot\" items from transient noise, a nuance missing in the pure frequency comparison implementations of **Generation 98**.\n- **Probation Hit Tracking vs. State Reset**: The **Current Best Program** moves demoted Protected items to Probation *without* preserving their Protected status bits, treating them as Probationary items. This implementation simplifies the state machine while retaining the object's presence, ensuring fairness in subsequent duels.\n\n## Performance Analysis\n- **The 1% Window Optima**: There is a strong correlation between the strict 1% window size and top-tier scores (0.26-0.27). Programs deviating to 5% (**Generation 91, 96**) consistently drop to the 0.23-0.24 range. This proves that for this dataset, maximizing the Protected SLRU capacity (99% of space) is the primary driver of the high aggregate score.\n- **Trace 28 Dominance**: The **Current Best Program** achieves ~0.89 on Trace 28 (Zipfian). Modifications in other generations (e.g., **Generation 96**) that lowered this specific hit rate to 0.88 in exchange for better scan resistance resulted in lower global scores. This confirms that the current scoring metric heavily favors maximizing performance on static locality over mitigating scan penalties.\n- **Convergence at 0.27**: Multiple optimized approaches (**Generation 93, 94**, and **Current Best**) converge at a score of 0.27. This indicates a performance plateau where further gains likely require handling the \"zero-hit\" scan traces (14, 15, 16) without sacrificing any capacity on the stable traces, a trade-off that standard W-TinyLFU structures struggle to bypass.",
  "meta_recommendations": "Based on the analysis of the Global Insights and the specific mechanisms of the Current Best Program (Generation 69), here are 5 actionable recommendations for future program mutations.\n\n1.  **Frequency-Comparative Adaptive Window**\n    Refine the successful `if fm > 0` check in the window growth phase to a relative comparison: `if fm >= fw`. Currently, the algorithm prevents Window growth if the Main victim has *any* frequency. Updating this to `if fm >= fw` ensures that the Window only yields its reserved capacity if the Main cache victim is strictly as valuable or more valuable than the Window's eviction candidate, preventing the displacement of moderately warm Main items by equally cold Window items.\n\n2.  **Sampled LFU Eviction for Probation**\n    Modify the eviction selection within the `probation` segment. Instead of strictly evicting the absolute LRU (`next(iter(probation))`), inspect the last 2-3 items in the probation queue and evict the one with the lowest frequency. This small \"Lookahead LFU\" logic protects items that have accumulated some frequency but have physically drifted to the tail due to recent insertions, granting them a slightly longer survival window to secure a promotion hit.\n\n3.  **Eviction-Driven Aging Strategy**\n    Change the aging trigger from `access_count` (total operations) to a counter based on **evictions** or **insertions**. The current access-based aging decays frequency counts rapidly during high-hit-rate stable phases (Trace 28), where history should actually be preserved. Tying aging to cache turnover ensures that frequency history decays only when the working set is actively changing, improving stability on static traces.\n\n4.  **Protected-Aware Accelerated Promotion**\n    Enhance the `freq >= 5` acceleration logic by checking the state of the Protected segment. Only allow immediate promotion if `freq >= 5` **AND** (`protected_size < protected_limit` OR `freq > freq_of_protected_LRU`). This ensures that items bypassing the Probation buffer are not just historically frequent, but are specifically competitive against the current incumbents in the Protected segment, preventing aggressive evictions of valid protected items.\n\n5.  **Synchronized Doorkeeper Reset**\n    Decouple the Doorkeeper reset from the arbitrary `2 * capacity` size limit and synchronize it with the frequency aging interval. When `_update_freq` halves the frequencies, clear the Doorkeeper simultaneously. This aligns the \"newcomer filter\" (Doorkeeper) with the \"long-term memory\" (Frequency Sketch), ensuring that after a decay event, the filter resets to capture the new phase of the workload without carrying over stale rejection bits.",
  "meta_recommendations_history": [
    "Based on the performance analysis of the ARC implementation (current best) and the global insights, here are 5 actionable recommendations for future program mutations. These recommendations aim to bridge the gap between ARC's adaptability and the need for scan resistance (handling Traces 14-19), while further refining the successful frequency-recency separation.\n\n1.  **Implement an S3-FIFO Style Nursery:**\n    Prepend a small, static FIFO queue (e.g., 10% of capacity) before the adaptive ARC structure. New items enter this \"nursery\" first; they are only promoted to the main ARC lists (T1/T2) if they are accessed again while in the nursery. If they exit the nursery without a hit, they are evicted directly. This filters out \"one-hit wonders\" (scans) before they can pollute the adaptive T1/T2 segments or flush valuable ghost entries, directly addressing the near-zero hit rates on scan traces.\n\n2.  **Integrate a Frequency-Based Admission Filter (TinyLFU-lite):**\n    Augment the eviction logic with a lightweight frequency sketch (e.g., a simple Python dictionary that tracks frequency of recent keys, resetting periodically to keep size low). When the cache is full, compare the estimated frequency of the incoming item against the eviction victim (from T1 or T2). Only admit the new item if its frequency is higher; otherwise, drop it. This prevents low-utility items from displacing accumulated high-frequency content during high churn.\n\n3.  **Refine Ghost Feedback with Frequency Weights:**\n    Modify the adaptive update of the parameter `p` to be proportional to the importance of the ghost hit, rather than a fixed increment. Store a \"frequency at eviction\" counter in the ghost lists (`B1`, `B2`). When a hit occurs in a ghost list, adjust `p` by a magnitude derived from that item's past frequency (e.g., `delta = 1 + log(frequency)`). This allows the algorithm to correct its partition size more aggressively when high-value frequency items are being evicted too soon.\n\n4.  **Adopt LIRS-Style Strict Promotion:**\n    Tighten the criteria for moving items from the recency list (T1) to the frequency list (T2). Instead of promoting an item to T2 on its very first hit in T1 (standard ARC), require a second hit or a specific \"inter-reference recency\" threshold (similar to LIRS). This ensures that T2 is reserved for items with established high-frequency patterns, preventing \"warm\" items from diluting the core frequency segment.\n\n5.  **Expand Ghost List Capacity for Long Loops:**\n    The current implementation limits ghost lists (`B1`, `B2`) to the cache capacity `c`. Increase the ghost list capacity (e.g., to `2 * c`) or implement a time-based expiration for ghosts. This allows the algorithm to detect and adapt to looping patterns that are slightly larger than the cache size (which currently result in misses and ghost entry loss), enabling the adaptive logic to \"remember\" these patterns and resize `p` accordingly.",
    "Based on the analysis of the current best program (W-TinyLFU) and the global insights regarding scan resistance and adaptive partitioning, here are 5 actionable recommendations for future program mutations:\n\n1.  **Implement Dynamic Window Sizing (Adaptive TinyLFU)**\n    The current implementation uses a static 5% window size (`w_cap`). Introduce ghost lists (history of evicted keys) for both the Window and Main segments to dynamically adjust this ratio, similar to the ARC algorithm. If a hit occurs in the \"Window Ghost\" list, increment the window size; if in the \"Main Ghost\" list, decrement it. This allows the algorithm to automatically scale the admission buffer for workloads that require a larger nursery while retaining the frequency-based dueling logic.\n\n2.  **Enforce Strict FIFO Eviction for the Window (S3-FIFO Strategy)**\n    To address the near-zero hit rates on scan traces (Traces 14-19), modify the `window` segment to operate as a strict FIFO queue rather than an LRU. New items enter the FIFO window; if they are accessed again while in the window, they are promoted to the Main cache; if they exit the window without re-access, they are evicted immediately without triggering the frequency duel. This provides a hard filter against one-pass scans that otherwise pollute the frequency counters.\n\n3.  **Integrate a \"Doorkeeper\" Bloom Filter**\n    Refine the frequency counting mechanism by adding a small Bloom filter (or a reset-able hash set) as a \"Doorkeeper.\" Only increment the main frequency counter if the item is already present in the Doorkeeper. This prevents \"one-hit wonders\" from accumulating frequency counts and winning eviction duels against established content, thereby protecting the working set more effectively.\n\n4.  **Adopt Smooth Frequency Decay**\n    Replace the current bulk reset mechanism (halving all frequencies every 10x capacity accesses) with a smoother exponential decay or periodic aging (e.g., multiply all frequencies by 0.95 every 1x capacity accesses). This prevents \"sawtooth\" precision loss where history is suddenly wiped, ensuring that the `evict` function always has a temporally relevant frequency comparison between candidates.\n\n5.  **Strengthen Promotion Criteria to Protected Segment**\n    Modify the transition from `probation` to `protected` to require more than a single hit (e.g., require a frequency threshold relative to the average, or a second hit within the probation period). The current code promotes immediately upon the first hit in `probation`. Increasing this barrier ensures that the highly protected segment (80% of main cache) is reserved strictly for items with demonstrated stable recurrence, reducing thrashing in the protected tier.",
    "Based on the global insights and the analysis of the current best program (Gen 26), here are 5 actionable recommendations for future program mutations.\n\n1.  **Implement a \"Doorkeeper\" Filter**\n    The current implementation increments the main frequency counter for every inserted item, allowing one-pass scans to accumulate a frequency of 1 and potentially win duels. Introduce a `set` based Doorkeeper: when an item is first seen, add it to the `set` but do not increment the main frequency. Only increment the main `freq` dictionary if the key is already in the Doorkeeper. This ensures that one-off items effectively have a frequency of 0, guaranteeing they lose the eviction duel against the working set.\n\n2.  **Enforce Strict \"Hit-Required\" Admission (S3-FIFO Hybrid)**\n    Modify the Window logic to act as a strict filter rather than just a buffer. Instead of moving all window overflow items to `probation`, only promote items that have received a hit while residing in the `window`. If an item exits the window without being accessed again, evict it immediately without triggering the frequency duel. This provides a hard topological barrier against scans (Trace 14) that frequency counters alone might miss.\n\n3.  **Accelerate Frequency Aging**\n    The current aging strategy (halving frequencies every `10 * capacity` accesses) is likely too slow for the rapid phase changes observed in the traces. Increase the aging frequency to `2 * capacity` or `1 * capacity`. This will clear out \"historical\" heavy hitters faster, preventing cache pollution where obsolete items with high accumulated counts block new working sets from entering.\n\n4.  **Raise the Bar for \"Protected\" Promotion**\n    Currently, a single hit in the `probation` segment promotes an item to `protected` (which holds 80% of the cache). Implement a stricter threshold, requiring 2 or more hits in `probation` before promotion. This ensures that the large `protected` sanctuary is reserved strictly for items with demonstrated stability, keeping the `probation` segment fluid for handling transient loops.\n\n5.  **Cap Maximum Frequency Counts**\n    Introduce a saturation limit for frequency counters (e.g., `min(freq, 15)`). Without a cap, long-standing items can accumulate massive counts that make them immune to eviction even after they stop being accessed (until significant aging occurs). A low cap keeps the counters responsive, allowing new \"hot\" items to quickly challenge and displace old stable items that have become cold.",
    "Based on the analysis of the current best program (W-TinyLFU variant) and the global insights, here are 5 actionable recommendations for the next program mutation:\n\n1.  **Implement a \"Doorkeeper\" Mechanism**\n    To address the poor performance on scan traces (Trace 14, 0.00 hit rate), introduce a `set` to track newly observed keys. When an item is accessed, if it is not in the `set`, add it but do not increment the main `freq` dictionary (effectively keeping its frequency at 0 for the duel). Only increment `freq` if the key is already in the `set`. This ensures one-off items lose the eviction duel (`freq 0` vs `freq > 0`) against the working set, preventing cache pollution.\n\n2.  **Condition Preemptive Eviction on Frequency**\n    The current logic (`if window_size < w_cap: evict from Main`) unconditionally prioritizes keeping the window open, which can flush valuable Main items during a scan. Modify this to check the Main victim's status. If the candidate for eviction from Main has a high frequency (or is in the `protected` segment), **skip** the preemptive eviction and allow the window to fill. This forces a proper frequency duel when the window overflows, ensuring hot Main items are not sacrificed for cold Window arrivals.\n\n3.  **Accelerate Frequency Aging to 5x Capacity**\n    The current aging interval (`10 * capacity`) is successful but likely too slow for rapid phase changes (Traces 13, 17), while the failed `1 * capacity` was too aggressive. Change the aging trigger to `access_count > capacity * 5`. This intermediate value will clear obsolete historical frequency data faster than the current implementation without destroying the retention of active loops.\n\n4.  **Raise Admission Threshold for \"Protected\" Segment**\n    Currently, a single hit in `probation` promotes an item to `protected` (80% of cache). Increase this requirement: promote to `protected` only if an item has received **2 or more hits** while in `probation`. This stricter filter ensures that the large protected sanctuary is reserved for items with proven stability, keeping the `probation` segment more fluid for testing new content.\n\n5.  **Implement a Soft Frequency Cap**\n    To prevent \"historical inertia\" where old heavy hitters remain immune to eviction long after they become cold, introduce a cap on the frequency counters (e.g., `min(freq, 60)`). A cap of ~60 is high enough to distinguish popular items but low enough to allow the `5x` aging mechanism to degrade their counts effectively when they stop being accessed.",
    "Based on the analysis of the current best program (Generation 44) and the global insights, here are 5 actionable recommendations for future program mutations:\n\n1.  **Relax SLRU Promotion Criteria**\n    Modify the `update_after_hit` function to promote items from the `probation` segment to the `protected` segment immediately upon their **first hit** in `probation`, rather than requiring a second hit (tracked via `probation_hits`). The current two-hit requirement creates excessive friction, preventing the `protected` segment\u2014which holds 80% of the capacity\u2014from filling quickly with the working set on high-locality traces.\n\n2.  **Condition Preemptive Main Eviction**\n    Refine the eviction logic that unconditionally prioritizes Window growth (`if len(window) < window_size: evict from Main`). Add a check: if the candidate victim from the Main cache (Probation LRU) has a frequency count greater than 0, **spare it and evict from the Window instead**. This change prevents the cache from flushing valuable, established items to make room for potentially useless scan items during the \"Make room for Window\" phase.\n\n3.  **Implement Size-Based Doorkeeper Reset**\n    Decouple the Doorkeeper clearing from the frequency aging interval. Instead of clearing the `doorkeeper` set every `5 * capacity` accesses, clear it only when its size exceeds a fixed threshold (e.g., `2 * capacity`). This allows the Doorkeeper to retain \"seen-once\" history for a longer duration, improving the filter's ability to identify and reject one-off items from slow scans without the periodic amnesia caused by the aging timer.\n\n4.  **Introduce an Eviction Duel Bias**\n    Modify the TinyLFU duel comparison to include a bias factor favoring the Main cache residents. Change the eviction condition from `if freq_w > freq_m` to `if freq_w > freq_m + 1`. This adds \"inertia\" to the Main cache, ensuring that established items are not replaced by new arrivals that merely have an equal or marginally higher frequency, thereby reducing churn in the stable working set.\n\n5.  **Lower Frequency Saturation Cap**\n    Reduce the `max_freq` cap from 60 to **15**. With the current aging schedule (halving every `5 * capacity`), a cap of 60 retains history for too long (~30x capacity accesses), causing \"ghosts\" of past heavy hitters to pollute the cache. A lower cap allows the cache to adapt more rapidly to phase changes while still distinguishing between one-off items (freq 0/1) and the working set (freq > 1).",
    "Based on the global insights and the analysis of the current best program, here are 5 actionable recommendations for future mutations:\n\n1.  **Implement Incumbency-Biased Eviction Duel**\n    Modify the TinyLFU duel in the `evict` function to strictly favor the Main cache victim. Change the replacement condition from `freq_w > freq_m` to `freq_w > freq_m + 1`. This introduces a \"hysteresis\" or margin that prevents new, marginally popular items from displacing established residents, directly correlating with the Score 0.27 ceiling observed in generations 50, 51, and 58.\n\n2.  **Decouple Doorkeeper Reset from Aging**\n    Change the Doorkeeper clearing logic. Instead of clearing `self.doorkeeper` every time `self.age()` is called (every 5x capacity), clear it only when `len(self.doorkeeper)` exceeds a size threshold (e.g., `2 * capacity`). This prevents \"amnesia\" where the filter forgets recently seen one-off items just because the aging timer triggered, thereby improving scan resistance.\n\n3.  **Lower Frequency Saturation Cap**\n    Reduce `self.max_freq` from 60 to **15**. With the current halving strategy, a cap of 60 retains \"ghost\" history for too long (~30-60x capacity accesses). A lower cap ensures that the frequency sketch adapts faster to phase changes while still sufficiently distinguishing between one-hit wonders (freq 1) and the working set (freq > 1).\n\n4.  **Grant \"Second Chance\" Credit on Demotion**\n    Modify `update_after_hit` to preserve the status of items demoted from `protected`. When an item overflows from `protected` to `probation`, immediately set `state.probation_hits[victim] = True`. This treats the demoted item as a \"trusted\" candidate that only requires one hit to return to the protected segment, rather than forcing it to earn two hits like a completely new arrival.\n\n5.  **Extend Frequency Aging Interval**\n    Increase the `aging_interval` from `capacity * 5` to `capacity * 10`. The performance analysis indicates that \"rigidity is a feature\" and high scores come from locking onto static working sets. Slowing down the decay rate reduces churn and reinforces the cache's ability to hold onto high-value items during longer loop periods.",
    "Based on the global insights and the analysis of the current best program (Generation 69), here are 5 actionable recommendations for future mutations:\n\n1.  **Grant \"Second Chance\" Status on Demotion**\n    Modify the `update_after_hit` logic to set `state.probation_hits[victim] = True` immediately when an item is demoted from the `protected` segment to `probation`. This acknowledges the item's previous high status and allows it to return to the protected segment with a single subsequent hit, reducing churn for the working set boundary compared to treating it as a raw newcomer.\n\n2.  **Decouple Doorkeeper Reset from Frequency Aging**\n    Change the `doorkeeper` clearing mechanism to trigger based on a size threshold (e.g., when `len(state.doorkeeper) > 2 * capacity`) rather than clearing it inside the periodic `age()` function. This prevents the filter from suffering \"amnesia\" on recently seen scan items just because the frequency aging timer fired, thereby improving scan resistance.\n\n3.  **Lower Frequency Saturation Cap**\n    Reduce `self.max_freq` from 60 to **15**. The current cap of 60 retains history for too long, causing the cache to hold onto \"ghost\" heavy hitters that are no longer relevant; a lower cap ensures the frequency sketch adapts faster to phase changes while still effectively distinguishing between one-hit wonders and established items.\n\n4.  **Implement Segment-Aware Eviction Duel**\n    Refine the `evict` function to use different tie-breaking logic based on the victim's segment. Use `freq_window >= freq_main` (ties evict Main/Probation) if the victim is in the **Probation** segment, but strictly `freq_window > freq_main` (ties keep Main/Protected) if the victim is in the **Protected** segment. This encourages faster turnover in the probation buffer while strictly stabilizing the core protected segment.\n\n5.  **Frequency-Accelerated Promotion**\n    Update `update_after_hit` to allow immediate promotion from `probation` to `protected` if `state.get_freq(key)` exceeds a \"hot\" threshold (e.g., 5), even if `probation_hits` is not satisfied. This utilizes the persistent frequency sketch to fast-track historically heavy hitters that have re-entered the cache, bypassing the standard two-hit probation requirement.",
    "Based on the analysis of the current best program (Generation 69) and the global insights from Generations 70-79, here are 5 actionable recommendations for future mutations.\n\n1.  **Grant \"Second Chance\" Status on Demotion**\n    Modify the `update_after_hit` logic to set `state.probation_hits[victim] = True` immediately when an item is demoted from `protected` to `probation` due to overflow. Currently, demoted items are treated as raw newcomers; granting them \"second chance\" status allows these proven items to return to the protected segment with a single subsequent hit, reducing churn at the working set boundary.\n\n2.  **Lower Frequency Saturation Cap**\n    Reduce `self.max_freq` from 60 to **15**. The current cap creates too much inertia, causing \"ghost\" heavy hitters to persist long after they have stopped being relevant. A lower saturation point, combined with the existing 5x aging interval, will significantly improve the cache's ability to adapt to phase changes (dynamic workloads) while still filtering out one-hit wonders.\n\n3.  **Implement Segment-Aware Eviction Duel**\n    Refine the `evict` function to use different tie-breaking logic based on the victim's segment. Use `freq_window >= freq_main` (ties evict Main) if the victim is in the **Probation** segment, but maintain strictly `freq_window > freq_main` (ties keep Main) if the victim is in the **Protected** segment. This encourages faster turnover in the probation buffer for new content while strictly stabilizing the core protected segment against replacement.\n\n4.  **Size-Based Doorkeeper Reset**\n    Decouple the doorkeeper clearing mechanism from the frequency aging timer. Remove `state.doorkeeper.clear()` from the `age` function and instead implement a check in `record_access`: if `len(state.doorkeeper) > 2 * capacity`, clear the set. This prevents the admission filter from suffering \"amnesia\" on scans just because the aging timer fired, offering more consistent scan resistance.\n\n5.  **Sketch-Accelerated Promotion**\n    Update `update_after_hit` to allow immediate promotion from `probation` to `protected` if `state.get_freq(key)` exceeds a threshold (e.g., 5), even if the `probation_hits` condition is not met. This utilizes the persistent frequency sketch to fast-track historically heavy hitters that are re-entering the cache, allowing them to bypass the standard \"two-hit\" probationary requirement.",
    "Based on the analysis of the global insights and the current best program (Generation 69), here are 5 actionable recommendations for future mutations.\n\n1.  **Grant \"Second Chance\" Status on Demotion**\n    Modify the `update_after_hit` logic to set `state.probation_hits[victim] = True` immediately when an item is demoted from `protected` to `probation` due to overflow. Currently, demoted items are treated as raw newcomers requiring two hits to return; granting them \"second chance\" status allows these proven items to return to the protected segment with a single subsequent hit, reducing churn at the working set boundary.\n\n2.  **Lower Frequency Saturation Cap**\n    Reduce `self.max_freq` from 60 to **15** or **20**. The current cap creates too much inertia, causing \"ghost\" heavy hitters to persist long after they have stopped being relevant. A lower saturation point, combined with the existing 5x aging interval, will significantly improve the cache's ability to adapt to phase changes (dynamic workloads) while still maintaining the \"Implicit Incumbent Favoritism\" pattern.\n\n3.  **Implement Segment-Dependent Eviction Logic**\n    Refine the `evict` function to use different tie-breaking logic based on the victim's segment. Use `freq_window >= freq_main` (ties evict Main) if the victim is in the **Probation** segment, but maintain strictly `freq_window > freq_main` (ties keep Main) if the victim is in the **Protected** segment. This encourages faster turnover in the probation buffer for new content while strictly stabilizing the core protected segment against replacement.\n\n4.  **Sketch-Accelerated Promotion**\n    Update `update_after_hit` to allow immediate promotion from `probation` to `protected` if `state.get_freq(key)` exceeds a significant threshold (e.g., 5 or 10), even if the `probation_hits` condition is not met. This utilizes the persistent frequency sketch to fast-track historically heavy hitters that are re-entering the cache, allowing them to bypass the standard \"two-hit\" probationary requirement intended for unknown items.\n\n5.  **Size-Based Doorkeeper Reset**\n    Decouple the doorkeeper clearing mechanism from the frequency aging timer. Add a check in `record_access`: if `len(state.doorkeeper) > 2 * capacity`, clear the set immediately. This prevents the admission filter from becoming \"clogged\" with one-hit wonders during long periods between aging intervals, ensuring it remains an effective filter against scanning workloads.",
    "Based on the analysis of the Global Insights and the specific mechanisms of the Current Best Program (Generation 69), here are 5 actionable recommendations for future program mutations.\n\n1.  **Frequency-Comparative Adaptive Window**\n    Refine the successful `if fm > 0` check in the window growth phase to a relative comparison: `if fm >= fw`. Currently, the algorithm prevents Window growth if the Main victim has *any* frequency. Updating this to `if fm >= fw` ensures that the Window only yields its reserved capacity if the Main cache victim is strictly as valuable or more valuable than the Window's eviction candidate, preventing the displacement of moderately warm Main items by equally cold Window items.\n\n2.  **Sampled LFU Eviction for Probation**\n    Modify the eviction selection within the `probation` segment. Instead of strictly evicting the absolute LRU (`next(iter(probation))`), inspect the last 2-3 items in the probation queue and evict the one with the lowest frequency. This small \"Lookahead LFU\" logic protects items that have accumulated some frequency but have physically drifted to the tail due to recent insertions, granting them a slightly longer survival window to secure a promotion hit.\n\n3.  **Eviction-Driven Aging Strategy**\n    Change the aging trigger from `access_count` (total operations) to a counter based on **evictions** or **insertions**. The current access-based aging decays frequency counts rapidly during high-hit-rate stable phases (Trace 28), where history should actually be preserved. Tying aging to cache turnover ensures that frequency history decays only when the working set is actively changing, improving stability on static traces.\n\n4.  **Protected-Aware Accelerated Promotion**\n    Enhance the `freq >= 5` acceleration logic by checking the state of the Protected segment. Only allow immediate promotion if `freq >= 5` **AND** (`protected_size < protected_limit` OR `freq > freq_of_protected_LRU`). This ensures that items bypassing the Probation buffer are not just historically frequent, but are specifically competitive against the current incumbents in the Protected segment, preventing aggressive evictions of valid protected items.\n\n5.  **Synchronized Doorkeeper Reset**\n    Decouple the Doorkeeper reset from the arbitrary `2 * capacity` size limit and synchronize it with the frequency aging interval. When `_update_freq` halves the frequencies, clear the Doorkeeper simultaneously. This aligns the \"newcomer filter\" (Doorkeeper) with the \"long-term memory\" (Frequency Sketch), ensuring that after a decay event, the filter resets to capture the new phase of the workload without carrying over stale rejection bits."
  ],
  "total_programs_meta_processed": 100
}