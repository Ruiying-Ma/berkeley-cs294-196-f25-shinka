--- a/original.py
+++ b/original.py
@@ -1,137 +1,172 @@
 # EVOLVE-BLOCK-START
-"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""
+"""Cache eviction algorithm combining S3-FIFO structure with ARC-like adaptation"""
 
-# ARC Globals
-m_t1 = dict() # Recency (L1)
-m_t2 = dict() # Frequency (L2)
-m_b1 = dict() # Ghost Recency
-m_b2 = dict() # Ghost Frequency
-p = 0         # Adaptive parameter
+# Globals
+m_small = dict()
+m_main = dict()
+g_small = dict()
+g_main = dict()
+m_hits = dict()
+s_ratio = 0.1
 
 def evict(cache_snapshot, obj):
     '''
-    ARC Eviction Logic with Randomization:
-    - Adapt p based on hits in ghost lists (B1, B2).
-    - Decide whether to evict from T1 or T2 based on p and T1 size.
-    - Use Random Eviction to robustly handle loops and large working sets.
+    Adaptive S3-FIFO Eviction:
+    - Main and Small queues.
+    - Adaptive Small queue size ratio (s_ratio) based on ghost hits.
+    - Second-chance mechanism for both queues using hit counts.
     '''
-    global p
-    import random
+    global m_small, m_main, m_hits, s_ratio
 
     capacity = cache_snapshot.capacity
+    s_target = max(1, int(capacity * s_ratio))
 
-    # Adaptation: If the incoming object (miss) is in a ghost list
-    if obj.key in m_b1:
-        delta = 1
-        if len(m_b1) < len(m_b2):
-             delta = len(m_b2) / len(m_b1)
-        p = min(capacity, p + delta)
-    elif obj.key in m_b2:
-        delta = 1
-        if len(m_b2) < len(m_b1):
-             delta = len(m_b1) / len(m_b2)
-        p = max(0, p - delta)
+    while True:
+        # Check if we should evict from Small
+        # Condition: Small is over target size OR Main is empty (must evict from Small)
+        if len(m_small) > s_target or not m_main:
+            if not m_small:
+                # Fallback: if Small is empty but Main is not (shouldn't reach here due to 'or not m_main' but for safety)
+                if m_main:
+                    candidate = next(iter(m_main))
+                else:
+                    return next(iter(cache_snapshot.cache))
+            else:
+                candidate = next(iter(m_small))
 
-    # Decision: Select victim
-    evict_t1 = False
-    if len(m_t1) > 0:
-        if len(m_t1) > p:
-            evict_t1 = True
-        elif obj.key in m_b2 and len(m_t1) == int(p):
-            evict_t1 = True
-        elif len(m_t2) == 0:
-            evict_t1 = True
-
-    if evict_t1:
-        return random.choice(list(m_t1.keys()))
-    else:
-        return random.choice(list(m_t2.keys()))
+            if m_hits.get(candidate, 0) > 0:
+                # Hit in Small -> Promote to Main
+                m_hits[candidate] = 0
+                del m_small[candidate]
+                m_main[candidate] = None
+                # Loop continues to find next victim
+            else:
+                # No hit -> Evict from Small
+                return candidate
+        else:
+            # Evict from Main
+            candidate = next(iter(m_main))
+            if m_hits.get(candidate, 0) > 0:
+                # Hit in Main -> Reinsert at tail (Second Chance)
+                m_hits[candidate] = 0
+                del m_main[candidate]
+                m_main[candidate] = None
+            else:
+                # No hit -> Evict from Main
+                return candidate
 
 def update_after_hit(cache_snapshot, obj):
     '''
     On Cache Hit:
-    - If obj in T1, move to T2 (MRU).
-    - If obj in T2, move to MRU of T2.
+    - Increment hit counter (saturated at 3).
     '''
-    global m_t1, m_t2
-
-    if obj.key in m_t1:
-        del m_t1[obj.key]
-        m_t2[obj.key] = None
-    elif obj.key in m_t2:
-        del m_t2[obj.key]
-        m_t2[obj.key] = None
+    global m_hits
+    m_hits[obj.key] = min(m_hits.get(obj.key, 0) + 1, 3)
 
 def update_after_insert(cache_snapshot, obj):
     '''
     On Cache Insert (Miss):
-    - Place obj in T1 or T2.
+    - Adapt s_ratio based on ghost hits.
+    - Insert into Small or Main.
     '''
-    global m_t1, m_t2, m_b1, m_b2, p
+    global m_small, m_main, m_hits, g_small, g_main, s_ratio
 
-    # Reset state at start of new trace (access_count starts at 1 usually for first miss)
+    # Reset state if new trace
     if cache_snapshot.access_count <= 1:
-        m_t1.clear()
-        m_t2.clear()
-        m_b1.clear()
-        m_b2.clear()
-        p = 0
+        m_small.clear()
+        m_main.clear()
+        m_hits.clear()
+        g_small.clear()
+        g_main.clear()
+        s_ratio = 0.1
 
-    # Check if it was a ghost
-    is_ghost = False
-    if obj.key in m_b1:
-        del m_b1[obj.key]
-        is_ghost = True
-    if obj.key in m_b2:
-        del m_b2[obj.key]
-        is_ghost = True
-
-    if is_ghost:
-        # History hit -> promote to frequency list
-        m_t2[obj.key] = None
+    key = obj.key
+    capacity = cache_snapshot.capacity
+    
+    # Check ghost hits to adapt s_ratio
+    if key in g_small:
+        # Hit in ghost small -> Small was too small
+        delta = 1.0
+        if len(g_main) > 0:
+            delta = len(g_main) / len(g_small)
+        delta_ratio = delta / capacity if capacity > 0 else 0.1
+        
+        s_ratio = min(0.99, s_ratio + delta_ratio)
+        
+        del g_small[key]
+        m_main[key] = None # Rescue to Main
+        m_hits[key] = 0
+        
+    elif key in g_main:
+        # Hit in ghost main -> Main was too small
+        delta = 1.0
+        if len(g_small) > 0:
+            delta = len(g_small) / len(g_main)
+        delta_ratio = delta / capacity if capacity > 0 else 0.1
+        
+        s_ratio = max(0.01, s_ratio - delta_ratio)
+        
+        del g_main[key]
+        m_main[key] = None # Rescue to Main
+        m_hits[key] = 0
+        
     else:
-        # New item -> probation list
-        m_t1[obj.key] = None
+        # Completely new item
+        m_small[key] = None
+        m_hits[key] = 0
 
 def update_after_evict(cache_snapshot, obj, evicted_obj):
     '''
     After Eviction:
-    - Update ghost lists.
+    - Add to appropriate ghost list.
     '''
-    global m_t1, m_t2, m_b1, m_b2
+    global m_small, m_main, m_hits, g_small, g_main
 
-    if evicted_obj.key in m_t1:
-        del m_t1[evicted_obj.key]
-        m_b1[evicted_obj.key] = None
-    elif evicted_obj.key in m_t2:
-        del m_t2[evicted_obj.key]
-        m_b2[evicted_obj.key] = None
+    key = evicted_obj.key
 
-    # Constrain ghost list sizes to capacity
+    # Identify where it was evicted from and move to ghost
+    if key in m_small:
+        del m_small[key]
+        g_small[key] = None
+    elif key in m_main:
+        del m_main[key]
+        g_main[key] = None
+
+    if key in m_hits:
+        del m_hits[key]
+
+    # Limit ghost size
+    # Maintain total ghost size <= capacity (ARC style)
     capacity = cache_snapshot.capacity
-    while len(m_b1) > capacity:
-        m_b1.pop(next(iter(m_b1)))
-    while len(m_b2) > capacity:
-        m_b2.pop(next(iter(m_b2)))
-
+    while len(g_small) + len(g_main) > capacity:
+        if len(g_small) > len(g_main):
+            if g_small:
+                g_small.pop(next(iter(g_small)))
+            elif g_main:
+                 g_main.pop(next(iter(g_main)))
+        else:
+            if g_main:
+                g_main.pop(next(iter(g_main)))
+            elif g_small:
+                g_small.pop(next(iter(g_small)))
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate