# EVOLVE-BLOCK-START
"""
W-TinyLFU with Segment-Aware Eviction and Sketch-Accelerated Promotion.
- Structure: Window (1%) + SLRU (Probation + Protected).
- Admission: Duel between Window LRU and Main LRU.
- Segment-Aware Tie-Breaking: Favors Window candidates over Probation, but strictly favors Protected items.
- Sketch-Accelerated Promotion: High-frequency items in Window skip Probation and move directly to Protected.
- Adaptive Aging: 5x Capacity interval with frequency capping at 15.
- Size-based Doorkeeper reset (2x Capacity).
"""
from collections import OrderedDict

# Global State
algo_state = {
    'window': OrderedDict(),    # key -> size (LRU first)
    'probation': OrderedDict(), # key -> size (LRU first)
    'protected': OrderedDict(), # key -> size (LRU first)
    'w_size': 0,
    'prob_size': 0,
    'prot_size': 0,
    'freq': {},                 # key -> count
    'doorkeeper': set(),        # key
    'aging_counter': 0,         # Ops since last aging
    'max_time': 0               # For reset detection
}

def _check_reset(cache_snapshot):
    if cache_snapshot.access_count < algo_state['max_time']:
        algo_state['window'].clear()
        algo_state['probation'].clear()
        algo_state['protected'].clear()
        algo_state['w_size'] = 0
        algo_state['prob_size'] = 0
        algo_state['prot_size'] = 0
        algo_state['freq'].clear()
        algo_state['doorkeeper'].clear()
        algo_state['aging_counter'] = 0
    algo_state['max_time'] = cache_snapshot.access_count

def _update_freq(key, capacity):
    state = algo_state
    state['aging_counter'] += 1
    
    # Adaptive Aging: Age every 5x Capacity
    if state['aging_counter'] >= capacity * 5:
        state['aging_counter'] = 0
        rem = []
        for k, v in state['freq'].items():
            nv = v // 2
            if nv == 0: rem.append(k)
            else: state['freq'][k] = nv
        for k in rem: del state['freq'][k]

    # Doorkeeper Reset: Filter effectiveness check
    if len(state['doorkeeper']) > capacity * 2:
        state['doorkeeper'].clear()

    # Update Logic
    if key in state['freq']:
        state['freq'][key] = min(state['freq'][key] + 1, 15)
    elif key in state['doorkeeper']:
        state['doorkeeper'].remove(key)
        state['freq'][key] = 2
    else:
        state['doorkeeper'].add(key)

def _get_freq(key):
    if key in algo_state['freq']:
        return algo_state['freq'][key]
    if key in algo_state['doorkeeper']:
        return 1
    return 0

def evict(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.01))
    
    # 1. Identify Candidates
    cand_w = next(iter(state['window'])) if state['window'] else None
    
    cand_m = None
    is_probation = False
    if state['probation']:
        cand_m = next(iter(state['probation']))
        is_probation = True
    elif state['protected']:
        cand_m = next(iter(state['protected']))
        is_probation = False
        
    if cand_w is None and cand_m is None: return None
    if cand_w is None: return cand_m
    if cand_m is None: return cand_w
    
    fw = _get_freq(cand_w)
    fm = _get_freq(cand_m)
    
    # 2. Window Growing Logic
    if state['w_size'] < w_cap:
        # Prefer evicting Main to grow Window
        # But if Main is valuable (freq > freq_window), evict Window instead
        if fm > fw:
            return cand_w
        return cand_m
        
    # 3. Duel Logic (Window Full)
    # Segment-Dependent Tie-Breaking
    if is_probation:
        # If Main is Probation, evict it on ties (fw >= fm).
        # This favors flow from Window -> Probation (churn in buffer).
        if fw >= fm:
            return cand_m
        else:
            return cand_w
    else:
        # If Main is Protected, protect it on ties.
        # Only evict if Window candidate is strictly better.
        if fw > fm:
            return cand_m
        else:
            return cand_w

def update_after_hit(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    key = obj.key
    capacity = cache_snapshot.capacity
    
    _update_freq(key, capacity)
    freq_val = _get_freq(key)
    
    if key in state['window']:
        # Sketch-Accelerated Promotion
        # If item has high frequency, promote directly to Protected
        if freq_val >= 5:
            val = state['window'].pop(key)
            state['w_size'] -= val
            state['protected'][key] = val
            state['prot_size'] += val
        else:
            state['window'].move_to_end(key)
            
    elif key in state['probation']:
        val = state['probation'].pop(key)
        state['prob_size'] -= val
        state['protected'][key] = val
        state['prot_size'] += val
        
    elif key in state['protected']:
        state['protected'].move_to_end(key)
        
    # Enforce Protected Limit (80% of total capacity approximation)
    limit = int(capacity * 0.8)
    while state['prot_size'] > limit and state['protected']:
        k, v = state['protected'].popitem(last=False)
        state['prot_size'] -= v
        state['probation'][k] = v
        state['prob_size'] += v
        state['probation'].move_to_end(k)

def update_after_insert(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    key = obj.key
    size = obj.size
    capacity = cache_snapshot.capacity
    
    _update_freq(key, capacity)
    
    state['window'][key] = size
    state['w_size'] += size
    
    w_cap = max(1, int(capacity * 0.01))
    while state['w_size'] > w_cap and state['window']:
        k, v = state['window'].popitem(last=False)
        state['w_size'] -= v
        state['probation'][k] = v
        state['prob_size'] += v
        state['probation'].move_to_end(k)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    state = algo_state
    key = evicted_obj.key
    size = evicted_obj.size
    
    if key in state['window']:
        del state['window'][key]
        state['w_size'] -= size
    elif key in state['probation']:
        del state['probation'][key]
        state['prob_size'] -= size
    elif key in state['protected']:
        del state['protected'][key]
        state['prot_size'] -= size
# EVOLVE-BLOCK-END