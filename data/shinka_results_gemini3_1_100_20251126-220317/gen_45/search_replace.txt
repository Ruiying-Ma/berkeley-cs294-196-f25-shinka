<NAME>
tuned_wtinylfu_params
</NAME>

<DESCRIPTION>
Optimizes the W-TinyLFU implementation with three key tuning adjustments:
1.  **Faster Aging (5x Capacity)**: Reduces the frequency aging interval from 10x to 5x capacity. This allows the algorithm to adapt more quickly to workload phase changes (improving performance on shifting traces).
2.  **Increased Frequency Cap (60)**: Raises the frequency counter cap from 15 to 60. This provides higher resolution to distinguish between "hot" and "warm" items, preventing hot items from being evicted too early during duels.
3.  **Dynamic Admission Tie-Breaker**: Changes the eviction duel tie-breaker (`fw >= fm` instead of `fw > fm`) to favor evicting the Main candidate (Probation) when frequencies are equal. This promotes flow and prevents "static trash" in Probation, making the cache more responsive to recent trends.
4.  **Stricter Promotion**: Raises the threshold for promotion from Probation to Protected. An item now requires `freq > 2` (essentially a 3rd access) to enter the Protected segment, ensuring that the valuable 80% protected space is reserved for truly stable items.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
"""
W-TinyLFU with Doorkeeper and Size-Aware Management
Maintains a 1% Window and an SLRU Main Cache (Probation + Protected).
Uses a Doorkeeper to filter one-hit wonders and frequency counters for admission to Main.
"""
from collections import OrderedDict

# Global State
algo_state = {
    'window': OrderedDict(),    # key -> size (LRU is first)
    'probation': OrderedDict(), # key -> size (LRU is first)
    'protected': OrderedDict(), # key -> size (LRU is first)
    'w_size': 0,
    'prob_size': 0,
    'prot_size': 0,
    'freq': {},                 # key -> count
    'doorkeeper': set(),        # Set of keys seen once
    'freq_counter': 0,          # Counter for aging
    'max_time': 0               # For detecting trace reset
}

def _check_reset(cache_snapshot):
    current_time = cache_snapshot.access_count
    if current_time < algo_state['max_time']:
        algo_state['window'].clear()
        algo_state['probation'].clear()
        algo_state['protected'].clear()
        algo_state['w_size'] = 0
        algo_state['prob_size'] = 0
        algo_state['prot_size'] = 0
        algo_state['freq'].clear()
        algo_state['doorkeeper'].clear()
        algo_state['freq_counter'] = 0
        algo_state['max_time'] = 0
    algo_state['max_time'] = current_time

def evict(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.01))

    # Identify Candidates (LRU is at the beginning of OrderedDict)
    cand_w_key = next(iter(state['window'])) if state['window'] else None
    cand_m_key = None
    if state['probation']:
        cand_m_key = next(iter(state['probation']))
    elif state['protected']:
        cand_m_key = next(iter(state['protected']))

    # Fail-safe
    if cand_w_key is None and cand_m_key is None:
        return None
    if cand_w_key is None:
        return cand_m_key
    if cand_m_key is None:
        return cand_w_key

    # Admission Policy
    # 1. If Window is growing (below capacity), evict from Main to make room.
    if state['w_size'] < w_cap:
        return cand_m_key

    # 2. Window is full. Duel Window LRU vs Main LRU.
    freq = state['freq']
    dk = state['doorkeeper']

    def get_freq(k):
        # If in Doorkeeper, effectively freq 1. If not seen, 0.
        return freq.get(k, 1 if k in dk else 0)

    fw = get_freq(cand_w_key)
    fm = get_freq(cand_m_key)

    # If Window candidate has higher frequency, it wins (is better to keep).
    # We evict Main candidate. Window candidate will overflow to Probation in insert.
    if fw > fm:
        return cand_m_key
    else:
        # Window candidate loses (or tie). Evict it.
        # Prefer evicting new random items (Window) over established ones (Main) on ties.
        return cand_w_key

def update_after_hit(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    key = obj.key
    capacity = cache_snapshot.capacity

    # 1. Update Frequency
    state['freq_counter'] += 1
    # Aging
    if state['freq_counter'] >= capacity * 10:
        state['freq_counter'] = 0
        state['doorkeeper'].clear()
        # Halve frequencies
        rem = []
        for k, v in state['freq'].items():
            nv = v // 2
            if nv == 0: rem.append(k)
            else: state['freq'][k] = nv
        for k in rem: del state['freq'][k]

    if key in state['freq']:
        state['freq'][key] = min(state['freq'][key] + 1, 15)
    elif key in state['doorkeeper']:
        state['doorkeeper'].remove(key)
        state['freq'][key] = 2
    else:
        state['doorkeeper'].add(key)

    # 2. Update Cache Position
    if key in state['window']:
        state['window'].move_to_end(key)
    elif key in state['protected']:
        state['protected'].move_to_end(key)
    elif key in state['probation']:
        # Promote: Probation -> Protected
        val = state['probation'].pop(key)
        state['prob_size'] -= val
        state['protected'][key] = val
        state['prot_size'] += val

        # Enforce Protected Limit (80% of Main)
        # Main Capacity ~ 99% of Total. Protected ~ 80% of Main.
        limit = int(capacity * 0.8)
        while state['prot_size'] > limit and state['protected']:
            # Demote: Protected LRU -> Probation MRU
            k, v = state['protected'].popitem(last=False)
            state['prot_size'] -= v
            state['probation'][k] = v
            state['prob_size'] += v
            state['probation'].move_to_end(k)

def update_after_insert(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    key = obj.key
    size = obj.size
    capacity = cache_snapshot.capacity

    # 1. Update Frequency (Insert counts as access)
    state['freq_counter'] += 1
    if state['freq_counter'] >= capacity * 10:
        state['freq_counter'] = 0
        state['doorkeeper'].clear()
        rem = []
        for k, v in state['freq'].items():
            nv = v // 2
            if nv == 0: rem.append(k)
            else: state['freq'][k] = nv
        for k in rem: del state['freq'][k]

    if key in state['freq']:
        state['freq'][key] = min(state['freq'][key] + 1, 15)
    elif key in state['doorkeeper']:
        state['doorkeeper'].remove(key)
        state['freq'][key] = 2
    else:
        state['doorkeeper'].add(key)

    # 2. Insert into Window
    state['window'][key] = size
    state['w_size'] += size

    # 3. Handle Window Overflow -> Move to Probation
    w_cap = max(1, int(capacity * 0.01))
    while state['w_size'] > w_cap and state['window']:
        k, v = state['window'].popitem(last=False) # Pop LRU
        state['w_size'] -= v
        state['probation'][k] = v
        state['prob_size'] += v
        state['probation'].move_to_end(k) # MRU
=======
"""
W-TinyLFU with Doorkeeper, Faster Aging, and Dynamic Admission
Maintains a 1% Window and an SLRU Main Cache (Probation + Protected).
"""
from collections import OrderedDict

# Global State
algo_state = {
    'window': OrderedDict(),    # key -> size (LRU is first)
    'probation': OrderedDict(), # key -> size (LRU is first)
    'protected': OrderedDict(), # key -> size (LRU is first)
    'w_size': 0,
    'prob_size': 0,
    'prot_size': 0,
    'freq': {},                 # key -> count
    'doorkeeper': set(),        # Set of keys seen once
    'freq_counter': 0,          # Counter for aging
    'max_time': 0               # For detecting trace reset
}

def _check_reset(cache_snapshot):
    current_time = cache_snapshot.access_count
    if current_time < algo_state['max_time']:
        algo_state['window'].clear()
        algo_state['probation'].clear()
        algo_state['protected'].clear()
        algo_state['w_size'] = 0
        algo_state['prob_size'] = 0
        algo_state['prot_size'] = 0
        algo_state['freq'].clear()
        algo_state['doorkeeper'].clear()
        algo_state['freq_counter'] = 0
        algo_state['max_time'] = 0
    algo_state['max_time'] = current_time

def _update_freq(state, key, capacity):
    # Update Frequency
    state['freq_counter'] += 1
    # Aging: 5x capacity (faster adaptation)
    if state['freq_counter'] >= capacity * 5:
        state['freq_counter'] = 0
        state['doorkeeper'].clear()
        rem = []
        for k, v in state['freq'].items():
            nv = v // 2
            if nv == 0: rem.append(k)
            else: state['freq'][k] = nv
        for k in rem: del state['freq'][k]

    if key in state['freq']:
        state['freq'][key] = min(state['freq'][key] + 1, 60) # Increased cap
    elif key in state['doorkeeper']:
        state['doorkeeper'].remove(key)
        state['freq'][key] = 2
    else:
        state['doorkeeper'].add(key)

def evict(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.01))

    cand_w_key = next(iter(state['window'])) if state['window'] else None
    cand_m_key = None
    if state['probation']:
        cand_m_key = next(iter(state['probation']))
    elif state['protected']:
        cand_m_key = next(iter(state['protected']))

    if cand_w_key is None and cand_m_key is None:
        return None
    if cand_w_key is None:
        return cand_m_key
    if cand_m_key is None:
        return cand_w_key

    # 1. Grow Window if needed
    if state['w_size'] < w_cap:
        return cand_m_key

    # 2. Duel
    freq = state['freq']
    dk = state['doorkeeper']

    def get_freq(k):
        return freq.get(k, 1 if k in dk else 0)

    fw = get_freq(cand_w_key)
    fm = get_freq(cand_m_key)

    # Tie-breaker: Favor Window (Recency) over Probation (Static) on ties
    if fw >= fm:
        return cand_m_key
    else:
        return cand_w_key

def update_after_hit(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    key = obj.key
    capacity = cache_snapshot.capacity

    _update_freq(state, key, capacity)

    if key in state['window']:
        state['window'].move_to_end(key)
    elif key in state['protected']:
        state['protected'].move_to_end(key)
    elif key in state['probation']:
        # Higher threshold for promotion to Protected
        if state['freq'].get(key, 0) > 2:
            val = state['probation'].pop(key)
            state['prob_size'] -= val
            state['protected'][key] = val
            state['prot_size'] += val

            limit = int(capacity * 0.8)
            while state['prot_size'] > limit and state['protected']:
                k, v = state['protected'].popitem(last=False)
                state['prot_size'] -= v
                state['probation'][k] = v
                state['prob_size'] += v
                state['probation'].move_to_end(k)
        else:
            state['probation'].move_to_end(key)

def update_after_insert(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    key = obj.key
    size = obj.size
    capacity = cache_snapshot.capacity

    _update_freq(state, key, capacity)

    state['window'][key] = size
    state['w_size'] += size

    w_cap = max(1, int(capacity * 0.01))
    while state['w_size'] > w_cap and state['window']:
        k, v = state['window'].popitem(last=False)
        state['w_size'] -= v
        state['probation'][k] = v
        state['prob_size'] += v
        state['probation'].move_to_end(k)
>>>>>>> REPLACE
</DIFF>