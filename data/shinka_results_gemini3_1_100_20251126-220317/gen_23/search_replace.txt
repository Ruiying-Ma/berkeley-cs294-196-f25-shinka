<NAME>
w_tinylfu_implementation
</NAME>

<DESCRIPTION>
Implement W-TinyLFU (Window Tiny Least Frequently Used) eviction policy.
- Maintains a Window Cache (FIFO, ~5% capacity) and a Main Cache (SLRU: Probation + Protected).
- Uses a Frequency Filter (Approximate counting with DoorKeeper and periodic reset) to govern admission from Window to Main.
- On eviction, if the Window is full, the Window victim duels with the Main (Probation) victim based on frequency.
- If Window victim has higher frequency, it is admitted to Main (Probation), and the Main victim is evicted.
- This handles scan resistance (scans don't pass the filter) and frequency-based patterns better than pure LRU/ARC.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# ARC Globals
m_t1 = dict() # Recency (L1)
m_t2 = dict() # Frequency (L2)
m_b1 = dict() # Ghost Recency
m_b2 = dict() # Ghost Frequency
p = 0         # Adaptive parameter

def evict(cache_snapshot, obj):
    '''
    ARC Eviction Logic with Randomization:
    - Adapt p based on hits in ghost lists (B1, B2).
    - Decide whether to evict from T1 or T2 based on p and T1 size.
    - Use Random Eviction to robustly handle loops and large working sets.
    '''
    global p
    import random

    capacity = cache_snapshot.capacity

    # Adaptation: If the incoming object (miss) is in a ghost list
    if obj.key in m_b1:
        delta = 1
        if len(m_b1) < len(m_b2):
             delta = len(m_b2) / len(m_b1)
        p = min(capacity, p + delta)
    elif obj.key in m_b2:
        delta = 1
        if len(m_b2) < len(m_b1):
             delta = len(m_b1) / len(m_b2)
        p = max(0, p - delta)

    # Decision: Select victim
    evict_t1 = False
    if len(m_t1) > 0:
        if len(m_t1) > p:
            evict_t1 = True
        elif obj.key in m_b2 and len(m_t1) == int(p):
            evict_t1 = True
        elif len(m_t2) == 0:
            evict_t1 = True

    if evict_t1:
        return random.choice(list(m_t1.keys()))
    else:
        return random.choice(list(m_t2.keys()))

def update_after_hit(cache_snapshot, obj):
    '''
    On Cache Hit:
    - If obj in T1, move to T2 (MRU).
    - If obj in T2, move to MRU of T2.
    '''
    global m_t1, m_t2

    if obj.key in m_t1:
        del m_t1[obj.key]
        m_t2[obj.key] = None
    elif obj.key in m_t2:
        del m_t2[obj.key]
        m_t2[obj.key] = None

def update_after_insert(cache_snapshot, obj):
    '''
    On Cache Insert (Miss):
    - Place obj in T1 or T2.
    '''
    global m_t1, m_t2, m_b1, m_b2, p

    # Reset state at start of new trace (access_count starts at 1 usually for first miss)
    if cache_snapshot.access_count <= 1:
        m_t1.clear()
        m_t2.clear()
        m_b1.clear()
        m_b2.clear()
        p = 0

    # Check if it was a ghost
    is_ghost = False
    if obj.key in m_b1:
        del m_b1[obj.key]
        is_ghost = True
    if obj.key in m_b2:
        del m_b2[obj.key]
        is_ghost = True

    if is_ghost:
        # History hit -> promote to frequency list
        m_t2[obj.key] = None
    else:
        # New item -> probation list
        m_t1[obj.key] = None

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    After Eviction:
    - Update ghost lists.
    '''
    global m_t1, m_t2, m_b1, m_b2

    if evicted_obj.key in m_t1:
        del m_t1[evicted_obj.key]
        m_b1[evicted_obj.key] = None
    elif evicted_obj.key in m_t2:
        del m_t2[evicted_obj.key]
        m_b2[evicted_obj.key] = None

    # Constrain ghost list sizes to capacity
    capacity = cache_snapshot.capacity
    while len(m_b1) > capacity:
        m_b1.pop(next(iter(m_b1)))
    while len(m_b2) > capacity:
        m_b2.pop(next(iter(m_b2)))
=======
# W-TinyLFU Globals
t_window = dict()       # FIFO Window (Nursery)
t_probation = dict()    # SLRU Probation (Main L1)
t_protected = dict()    # SLRU Protected (Main L2)
t_freq = dict()         # Frequency Counts (Approx)
t_doorkeeper = set()    # Bloom Filter / Set for 1st hit
t_accesses = 0          # Counter for aging

def estimate_freq(key):
    '''Helper to get frequency estimate'''
    global t_freq, t_doorkeeper
    count = 0
    if key in t_freq:
        count = t_freq[key]
    if key in t_doorkeeper:
        count += 1
    return count

def evict(cache_snapshot, obj):
    '''
    W-TinyLFU Eviction Logic:
    - Candidates: Head of Window (FIFO) vs LRU of Main (Probation).
    - If Window > 5% Cap: Duel candidates based on frequency.
    - Winner stays (Window moves to Main), Loser is evicted.
    '''
    global t_window, t_probation, t_protected, t_freq, t_doorkeeper

    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.05)) # 5% Window

    cand_w = None
    if t_window:
        cand_w = next(iter(t_window))

    cand_m = None
    # Main candidate: LRU of probation, else LRU of protected
    if t_probation:
        cand_m = next(iter(t_probation))
    elif t_protected:
        cand_m = next(iter(t_protected))

    victim = None

    # Logic: If Window full or Main empty, consider Window eviction
    if len(t_window) > w_cap and cand_w and cand_m:
        # Duel
        score_w = estimate_freq(cand_w)
        score_m = estimate_freq(cand_m)

        if score_w > score_m:
            # Window wins, Main victim dies.
            # Move Window candidate to Probation (Promote)
            del t_window[cand_w]
            t_probation[cand_w] = None
            victim = cand_m
        else:
            # Window loses
            victim = cand_w
    elif len(t_window) > w_cap and cand_w:
         # Main empty
         victim = cand_w
    else:
        # Window under budget, evict from Main
        if cand_m:
            victim = cand_m
        else:
            # Main empty? Fallback
            victim = cand_w if cand_w else next(iter(cache_snapshot.cache))

    # Cleanup internal lists for the victim immediately to keep sync
    if victim in t_window:
        del t_window[victim]
    elif victim in t_probation:
        del t_probation[victim]
    elif victim in t_protected:
        del t_protected[victim]

    return victim

def update_after_hit(cache_snapshot, obj):
    '''
    On Cache Hit:
    - Update frequency.
    - Manage SLRU promotions/demotions.
    '''
    global t_window, t_probation, t_protected, t_freq, t_doorkeeper

    key = obj.key

    # Update Frequency
    if key in t_doorkeeper:
        t_freq[key] = t_freq.get(key, 0) + 1
    else:
        t_doorkeeper.add(key)

    # Cache Policy
    if key in t_window:
        # Window is FIFO, do not move on hit
        pass
    elif key in t_probation:
        # Promote to Protected
        del t_probation[key]
        t_protected[key] = None
    elif key in t_protected:
        # Move to MRU
        del t_protected[key]
        t_protected[key] = None

    # Check Protected Capacity (80% of Main)
    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.05))
    main_cap = max(1, capacity - w_cap)
    protected_cap = int(main_cap * 0.8)

    if len(t_protected) > protected_cap:
        # Demote LRU of protected to probation
        demote_key = next(iter(t_protected))
        del t_protected[demote_key]
        t_probation[demote_key] = None

def update_after_insert(cache_snapshot, obj):
    '''
    On Cache Insert (Miss):
    - Reset if new trace.
    - Insert to Window.
    - Update frequency and handle aging.
    '''
    global t_window, t_probation, t_protected, t_freq, t_doorkeeper, t_accesses

    # Reset
    if cache_snapshot.access_count <= 1:
        t_window.clear()
        t_probation.clear()
        t_protected.clear()
        t_freq.clear()
        t_doorkeeper.clear()
        t_accesses = 0

    key = obj.key
    # Insert to Window (FIFO tail)
    t_window[key] = None

    # Freq
    if key in t_doorkeeper:
        t_freq[key] = t_freq.get(key, 0) + 1
    else:
        t_doorkeeper.add(key)

    # Aging
    t_accesses += 1
    capacity = cache_snapshot.capacity
    if t_accesses >= 10 * capacity:
        t_accesses = 0
        t_doorkeeper.clear()
        # Halve frequencies
        for k in list(t_freq.keys()):
            t_freq[k] //= 2
            if t_freq[k] == 0:
                del t_freq[k]

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    After Eviction:
    - Internal structures already updated in evict().
    '''
    pass
>>>>>>> REPLACE
</DIFF>