<NAME>
refined_wtinylfu
</NAME>

<DESCRIPTION>
Implements a refined W-TinyLFU algorithm with the following improvements:
1.  **Doorkeeper Mechanism**: A `set` is used to filter one-off items. Items are only added to the main frequency counter after being seen twice (once in Doorkeeper, once again). This filters out scan traffic (like Trace 14).
2.  **Accelerated Aging**: Frequency aging now occurs every 5x capacity accesses (instead of 10x). This helps the algorithm adapt faster to workload changes (phase changes).
3.  **Soft Frequency Cap**: Frequency counts are capped at 60. This prevents "historical inertia" where old popular items stay in the cache forever.
4.  **Strict Promotion Policy**: Items in `probation` are only promoted to `protected` if their frequency exceeds 2 (i.e., at least 3 accesses total). This keeps the protected region exclusive for truly hot items.
5.  **Conditional Preemptive Eviction**: When the Window is small, we typically evict from Main. However, if the Main victim is hotter than the Window victim, we now evict from Window instead.
6.  **Robust Reset**: Added `_check_reset` using `max_access_count` to correctly handle trace resets in the evaluation framework.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# W-TinyLFU style state
algo_state = {
    'window': deque(),        # Queue of (key, size)
    'window_size': 0,         # Current size of window
    'probation': OrderedDict(), # key -> size
    'protected': OrderedDict(), # key -> size
    'protected_size': 0,
    'freq': {},               # key -> count
    'access_count': 0
}

def evict(cache_snapshot, obj):
    '''
    W-TinyLFU Eviction:
    - Maintains a small Window (1%) and a Main SLRU (Probation + Protected).
    - If Window is not full, evict from Main (to allow Window to grow).
    - If Window is full, duel the Window victim vs Main victim using frequency.
    '''
    window = algo_state['window']
    probation = algo_state['probation']
    protected = algo_state['protected']
    freq = algo_state['freq']

    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.01))

    # 1. If Window has space, prefer evicting from Main (Probation -> Protected)
    if algo_state['window_size'] < w_cap:
        if probation:
            return next(iter(probation))
        if protected:
            return next(iter(protected))
        if window:
            return window[0][0]

    # 2. Window is full. Find candidates.
    if not window:
        # Fallback if window empty (rare)
        if probation: return next(iter(probation))
        if protected: return next(iter(protected))
        return None

    cand_w_key = window[0][0]

    if probation:
        cand_m_key = next(iter(probation))
    elif protected:
        cand_m_key = next(iter(protected))
    else:
        return cand_w_key

    # Duel: Keep the one with higher frequency
    freq_w = freq.get(cand_w_key, 0)
    freq_m = freq.get(cand_m_key, 0)

    if freq_w > freq_m:
        return cand_m_key
    else:
        return cand_w_key

def update_after_hit(cache_snapshot, obj):
    '''
    Update frequency and manage SLRU promotion.
    '''
    key = obj.key
    algo_state['access_count'] += 1

    # Frequency Update & Aging
    f = algo_state['freq']
    f[key] = f.get(key, 0) + 1
    if algo_state['access_count'] > cache_snapshot.capacity * 10:
        algo_state['freq'] = {k: v // 2 for k, v in f.items() if v > 1}
        algo_state['access_count'] = 0

    # SLRU Management
    if key in algo_state['protected']:
        algo_state['protected'].move_to_end(key)
    elif key in algo_state['probation']:
        # Promote from Probation to Protected
        val = algo_state['probation'].pop(key)
        algo_state['protected'][key] = val
        algo_state['protected_size'] += val

        # Enforce Protected Limit (80% of capacity)
        limit = int(cache_snapshot.capacity * 0.8)
        while algo_state['protected_size'] > limit and algo_state['protected']:
            k, v = algo_state['protected'].popitem(last=False)
            algo_state['protected_size'] -= v
            algo_state['probation'][k] = v

def update_after_insert(cache_snapshot, obj):
    '''
    Insert new object into Window and handle overflow to Probation.
    '''
    key = obj.key
    size = obj.size
    algo_state['access_count'] += 1

    # Frequency Update
    f = algo_state['freq']
    f[key] = f.get(key, 0) + 1

    # Insert into Window
    algo_state['window'].append((key, size))
    algo_state['window_size'] += size

    # Check Window Overflow -> Move to Probation
    w_cap = max(1, int(cache_snapshot.capacity * 0.01))
    while algo_state['window_size'] > w_cap and algo_state['window']:
        k, s = algo_state['window'].popleft()
        algo_state['window_size'] -= s
        algo_state['probation'][k] = s

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    Remove evicted object from internal structures.
    '''
    key = evicted_obj.key
    size = evicted_obj.size

    # Check and remove from locations
    if algo_state['window'] and algo_state['window'][0][0] == key:
        algo_state['window'].popleft()
        algo_state['window_size'] -= size
    elif key in algo_state['probation']:
        del algo_state['probation'][key]
    elif key in algo_state['protected']:
        val = algo_state['protected'].pop(key)
        algo_state['protected_size'] -= val
=======
# W-TinyLFU style state with Doorkeeper and Refined Management
algo_state = {
    'window': OrderedDict(),    # key -> size (LRU is first)
    'probation': OrderedDict(), # key -> size (LRU is first)
    'protected': OrderedDict(), # key -> size (LRU is first)
    'w_size': 0,
    'prob_size': 0,
    'prot_size': 0,
    'freq': {},                 # key -> count
    'doorkeeper': set(),        # Set of keys seen once
    'aging_counter': 0,         # Counter for aging
    'max_access_count': 0       # For detecting trace reset
}

def _check_reset(cache_snapshot):
    current_time = cache_snapshot.access_count
    if current_time < algo_state['max_access_count']:
        algo_state['window'].clear()
        algo_state['probation'].clear()
        algo_state['protected'].clear()
        algo_state['w_size'] = 0
        algo_state['prob_size'] = 0
        algo_state['prot_size'] = 0
        algo_state['freq'].clear()
        algo_state['doorkeeper'].clear()
        algo_state['aging_counter'] = 0
        algo_state['max_access_count'] = 0
    algo_state['max_access_count'] = current_time

def _update_freq(key, capacity):
    state = algo_state
    state['aging_counter'] += 1

    # 5x Capacity Aging
    if state['aging_counter'] >= capacity * 5:
        state['aging_counter'] = 0
        state['doorkeeper'].clear()
        rem = []
        for k, v in state['freq'].items():
            nv = v // 2
            if nv == 0: rem.append(k)
            else: state['freq'][k] = nv
        for k in rem: del state['freq'][k]

    if key in state['freq']:
        state['freq'][key] = min(state['freq'][key] + 1, 60)
    elif key in state['doorkeeper']:
        state['doorkeeper'].remove(key)
        state['freq'][key] = 2
    else:
        state['doorkeeper'].add(key)

def evict(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.01))

    cand_w_key = next(iter(state['window'])) if state['window'] else None
    cand_m_key = None
    if state['probation']:
        cand_m_key = next(iter(state['probation']))
    elif state['protected']:
        cand_m_key = next(iter(state['protected']))

    if cand_w_key is None and cand_m_key is None:
        return None
    if cand_w_key is None:
        return cand_m_key
    if cand_m_key is None:
        return cand_w_key

    freq = state['freq']
    dk = state['doorkeeper']
    def get_freq(k):
        return freq.get(k, 1 if k in dk else 0)

    fw = get_freq(cand_w_key)
    fm = get_freq(cand_m_key)

    # 1. Window growing phase
    if state['w_size'] < w_cap:
        # Prevent evicting hot Main items for cold Window items
        if fm > fw:
            return cand_w_key
        return cand_m_key

    # 2. Window full phase -> Duel
    if fw > fm:
        return cand_m_key
    else:
        return cand_w_key

def update_after_hit(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    key = obj.key
    capacity = cache_snapshot.capacity

    _update_freq(key, capacity)

    if key in state['window']:
        state['window'].move_to_end(key)
    elif key in state['protected']:
        state['protected'].move_to_end(key)
    elif key in state['probation']:
        # Strict Promotion: require established frequency
        if state['freq'].get(key, 0) > 2:
            val = state['probation'].pop(key)
            state['prob_size'] -= val
            state['protected'][key] = val
            state['prot_size'] += val

            limit = int(capacity * 0.8)
            while state['prot_size'] > limit and state['protected']:
                k, v = state['protected'].popitem(last=False)
                state['prot_size'] -= v
                state['probation'][k] = v
                state['prob_size'] += v
                state['probation'].move_to_end(k)
        else:
            state['probation'].move_to_end(key)

def update_after_insert(cache_snapshot, obj):
    _check_reset(cache_snapshot)
    state = algo_state
    key = obj.key
    size = obj.size
    capacity = cache_snapshot.capacity

    _update_freq(key, capacity)

    state['window'][key] = size
    state['w_size'] += size

    w_cap = max(1, int(capacity * 0.01))
    while state['w_size'] > w_cap and state['window']:
        k, v = state['window'].popitem(last=False)
        state['w_size'] -= v
        state['probation'][k] = v
        state['prob_size'] += v
        state['probation'].move_to_end(k)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    state = algo_state
    key = evicted_obj.key
    size = evicted_obj.size

    if key in state['window']:
        del state['window'][key]
        state['w_size'] -= size
    elif key in state['probation']:
        del state['probation'][key]
        state['prob_size'] -= size
    elif key in state['protected']:
        del state['protected'][key]
        state['prot_size'] -= size
>>>>>>> REPLACE
</DIFF>