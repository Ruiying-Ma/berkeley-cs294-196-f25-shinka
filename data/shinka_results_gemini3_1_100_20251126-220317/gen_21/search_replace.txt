<NAME>
s3fifo_algorithm
</NAME>

<DESCRIPTION>
Replacing the ARC algorithm with S3-FIFO (Simple Scalable S3-FIFO).
S3-FIFO divides the cache into a Small queue (S) and a Main queue (M) using a 10/90 split.
New items enter S. If they are accessed while in S or were in the Ghost queue (history of evictions from S), they are promoted to M.
Items in M that are accessed get a second chance (reinserted to tail).
This algorithm is highly resistant to scans (items pass through S and are evicted) while capturing frequent items in M.
This addresses the poor performance on scan traces (e.g. 14-19) observed in previous runs.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
"""
ARC (Adaptive Replacement Cache) Eviction Algorithm
Maintains two LRU lists: T1 (recency) and T2 (frequency), and two ghost lists B1 and B2.
Dynamically adjusts the target size `p` for T1 based on hits in the ghost lists.
"""

class ARCState:
    def __init__(self, cache_id):
        self.cache_id = cache_id
        # Use dicts as ordered sets for O(1) access and LRU preservation
        self.T1 = dict() # Recency (L1 cache)
        self.T2 = dict() # Frequency (L2 cache)
        self.B1 = dict() # Ghost Recency
        self.B2 = dict() # Ghost Frequency
        self.p = 0.0     # Target size for T1

_state = None

def get_state(cache_snapshot):
    global _state
    current_id = id(cache_snapshot.cache)
    if _state is None or _state.cache_id != current_id:
        _state = ARCState(current_id)

    # Sync check: if state deviates significantly from cache
    state_count = len(_state.T1) + len(_state.T2)
    cache_count = len(cache_snapshot.cache)

    if abs(state_count - cache_count) > 5:
        # Re-initialize from cache content
        _state = ARCState(current_id)
        for k in cache_snapshot.cache:
            # Assume recency for unknown state
            _state.T1[k] = None
        _state.p = 0.0

    return _state

def evict(cache_snapshot, obj):
    '''
    ARC eviction logic: adjusts p based on ghosts, then selects T1 or T2 victim.
    '''
    state = get_state(cache_snapshot)
    c = cache_snapshot.capacity
    key = obj.key

    # 1. Adapt p if hit in ghosts
    if key in state.B1:
        delta = 1
        if len(state.B1) >= len(state.B2) and len(state.B2) > 0:
             delta = 1
        elif len(state.B2) > len(state.B1):
             delta = len(state.B2) / len(state.B1)
        state.p = min(c, state.p + delta)
        # Move to MRU in B1 to protect from eviction in update_after_evict
        del state.B1[key]
        state.B1[key] = None

    elif key in state.B2:
        delta = 1
        if len(state.B2) >= len(state.B1) and len(state.B1) > 0:
             delta = 1
        elif len(state.B1) > len(state.B2):
             delta = len(state.B1) / len(state.B2)
        state.p = max(0, state.p - delta)
        # Move to MRU in B2
        del state.B2[key]
        state.B2[key] = None

    # 2. Determine victim
    # Replace(x) logic
    t1_excess = len(state.T1) > state.p
    in_b2_cond = (key in state.B2) and (len(state.T1) == int(state.p))

    if t1_excess or in_b2_cond:
        # Evict from T1 (LRU)
        if state.T1:
            return next(iter(state.T1))
        if state.T2: return next(iter(state.T2))
    else:
        # Evict from T2 (LRU)
        if state.T2:
            return next(iter(state.T2))
        if state.T1: return next(iter(state.T1))

    # Fallback
    if cache_snapshot.cache:
        return next(iter(cache_snapshot.cache))
    return None

def update_after_hit(cache_snapshot, obj):
    '''
    ARC: Hit in T1 -> move to T2. Hit in T2 -> MRU T2.
    '''
    state = get_state(cache_snapshot)
    key = obj.key

    if key in state.T1:
        del state.T1[key]
        state.T2[key] = None
    elif key in state.T2:
        del state.T2[key]
        state.T2[key] = None

def update_after_insert(cache_snapshot, obj):
    '''
    ARC: Insert to T1 (if new) or T2 (if in ghosts).
    '''
    state = get_state(cache_snapshot)
    key = obj.key

    is_ghost = False
    if key in state.B1:
        del state.B1[key]
        is_ghost = True
    if key in state.B2:
        del state.B2[key]
        is_ghost = True

    if is_ghost:
        state.T2[key] = None
    else:
        state.T1[key] = None

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    ARC: Move evicted to B1/B2 and trim ghosts.
    '''
    state = get_state(cache_snapshot)
    key = evicted_obj.key

    # Identify source
    if key in state.T1:
        del state.T1[key]
        state.B1[key] = None # Add to MRU B1
    elif key in state.T2:
        del state.T2[key]
        state.B2[key] = None # Add to MRU B2
    else:
        # Fallback sync
        state.B1[key] = None

    # Enforce ghost capacity (simplification: |B1| <= c, |B2| <= c)
    c = cache_snapshot.capacity
    while len(state.B1) > c:
        del state.B1[next(iter(state.B1))]
    while len(state.B2) > c:
        del state.B2[next(iter(state.B2))]
=======
"""
S3-FIFO Eviction Algorithm
Uses a Small (S) queue for new items and a Main (M) queue for frequent items.
Items in S are evicted early (scan resistance) unless accessed or previously in Ghost (G).
Items in M are given second chances upon access.
"""

class S3FIFOState:
    def __init__(self, cache_id):
        self.cache_id = cache_id
        self.small = dict()   # Small FIFO queue (approx 10%)
        self.main = dict()    # Main FIFO queue (approx 90%)
        self.ghost = dict()   # Ghost FIFO queue
        self.accessed = dict() # Track access bits
        self.capacity = 0

_state = None

def get_state(cache_snapshot):
    global _state
    current_id = id(cache_snapshot.cache)
    if _state is None or _state.cache_id != current_id:
        _state = S3FIFOState(current_id)

    # Sync check
    state_count = len(_state.small) + len(_state.main)
    cache_count = len(cache_snapshot.cache)
    if abs(state_count - cache_count) > 5:
        _state = S3FIFOState(current_id)
        # Heuristic recovery: put all in Main
        for k in cache_snapshot.cache:
            _state.main[k] = None
            _state.accessed[k] = False

    _state.capacity = cache_snapshot.capacity
    return _state

def evict(cache_snapshot, obj):
    '''
    S3-FIFO Eviction Logic
    '''
    state = get_state(cache_snapshot)
    target_small = max(1, int(state.capacity * 0.1))

    # Loop to find victim, handling lazy promotions/reinsertions
    loops = 0
    max_loops = len(cache_snapshot.cache) * 3 + 20 # Safety limit

    while loops < max_loops:
        loops += 1

        # Determine which queue to operate on
        if len(state.small) > target_small or not state.main:
            # Check Small queue
            if not state.small:
                # Fallback
                if state.main: return next(iter(state.main))
                return None

            candidate = next(iter(state.small))
            if state.accessed.get(candidate, False):
                # Second chance: promote to Main
                del state.small[candidate]
                state.main[candidate] = None
                state.accessed[candidate] = False
            else:
                return candidate
        else:
            # Check Main queue
            if not state.main:
                if state.small: return next(iter(state.small))
                return None

            candidate = next(iter(state.main))
            if state.accessed.get(candidate, False):
                # Second chance: reinsert to Main
                del state.main[candidate]
                state.main[candidate] = None
                state.accessed[candidate] = False
            else:
                return candidate

    # Emergency fallback
    if cache_snapshot.cache:
        return next(iter(cache_snapshot.cache))
    return None

def update_after_hit(cache_snapshot, obj):
    '''
    Hit: Set accessed bit. Lazy promotion happens at eviction time.
    '''
    state = get_state(cache_snapshot)
    state.accessed[obj.key] = True

def update_after_insert(cache_snapshot, obj):
    '''
    Insert: Add to Small, or Main if in Ghost.
    '''
    state = get_state(cache_snapshot)
    key = obj.key
    state.accessed[key] = False

    if key in state.ghost:
        state.main[key] = None
        del state.ghost[key]
    else:
        state.small[key] = None

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    Evict: Clean up queues and update Ghost if evicted from Small.
    '''
    state = get_state(cache_snapshot)
    key = evicted_obj.key

    if key in state.small:
        del state.small[key]
        state.ghost[key] = None # Evicted from S -> G
    elif key in state.main:
        del state.main[key]
        # Evicted from M -> Gone

    if key in state.accessed:
        del state.accessed[key]

    # Bound Ghost size
    while len(state.ghost) > state.capacity:
        del state.ghost[next(iter(state.ghost))]
>>>>>>> REPLACE

</DIFF>