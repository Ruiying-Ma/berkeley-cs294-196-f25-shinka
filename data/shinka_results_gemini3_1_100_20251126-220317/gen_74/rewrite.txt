# EVOLVE-BLOCK-START
"""
W-TinyLFU with Segmented Duel Bias and Adaptive Aging.
Maintains a small Window and an SLRU Main Cache.
Refines the eviction policy by applying different biases depending on whether the 
victim candidate is in Probation or Protected segments.
"""
from collections import OrderedDict

# Global State
algo_state = {
    'window': OrderedDict(),    # key -> size (LRU is first)
    'probation': OrderedDict(), # key -> size (LRU is first)
    'protected': OrderedDict(), # key -> size (LRU is first)
    'w_size': 0,
    'prob_size': 0,
    'prot_size': 0,
    'freq': {},                 # key -> count
    'doorkeeper': set(),        # Set of keys seen approximately once
    'aging_counter': 0,         # Counter for frequency aging
    'max_time': 0               # For detecting trace reset
}

def _reset_if_needed(current_time):
    # Reset state if time goes backwards (new trace)
    if current_time < algo_state['max_time']:
        algo_state['window'].clear()
        algo_state['probation'].clear()
        algo_state['protected'].clear()
        algo_state['w_size'] = 0
        algo_state['prob_size'] = 0
        algo_state['prot_size'] = 0
        algo_state['freq'].clear()
        algo_state['doorkeeper'].clear()
        algo_state['aging_counter'] = 0
        algo_state['max_time'] = 0
    algo_state['max_time'] = current_time

def _update_freq(key, capacity):
    state = algo_state
    
    # Aging Mechanism
    state['aging_counter'] += 1
    # Age frequencies every 5x capacity to adapt to phase changes
    if state['aging_counter'] >= capacity * 5:
        state['aging_counter'] = 0
        # Halve frequencies
        rem = []
        for k, v in state['freq'].items():
            nv = v // 2
            if nv == 0: rem.append(k)
            else: state['freq'][k] = nv
        for k in rem: del state['freq'][k]

    # Doorkeeper Management
    # Reset Doorkeeper when it grows too large to maintain filter effectiveness
    if len(state['doorkeeper']) > capacity * 2:
        state['doorkeeper'].clear()

    # Frequency Update
    if key in state['freq']:
        state['freq'][key] = min(state['freq'][key] + 1, 15)
    elif key in state['doorkeeper']:
        state['doorkeeper'].remove(key)
        state['freq'][key] = 2
    else:
        state['doorkeeper'].add(key)

def _get_freq(key):
    # Returns estimated frequency
    if key in algo_state['freq']:
        return algo_state['freq'][key]
    if key in algo_state['doorkeeper']:
        return 1
    return 0

def evict(cache_snapshot, obj):
    _reset_if_needed(cache_snapshot.access_count)
    state = algo_state
    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.01))
    
    # Identify Candidates (LRU is at the beginning of OrderedDict)
    cand_w_key = next(iter(state['window'])) if state['window'] else None
    
    cand_p_key = next(iter(state['probation'])) if state['probation'] else None
    cand_prot_key = next(iter(state['protected'])) if state['protected'] else None
    
    # Prefer Probation candidate over Protected
    cand_m_key = cand_p_key if cand_p_key else cand_prot_key
    
    # Fail-safe
    if cand_w_key is None and cand_m_key is None:
        return None
    if cand_w_key is None:
        return cand_m_key
    if cand_m_key is None:
        return cand_w_key

    fw = _get_freq(cand_w_key)
    fm = _get_freq(cand_m_key)

    # 1. Window Growing Phase
    # Ideally, we evict Main to let Window grow. 
    # Exception: If Main victim is strictly valuable (fm > fw), sacrifice Window instead.
    if state['w_size'] < w_cap:
        if fm > fw:
            return cand_w_key
        return cand_m_key
    
    # 2. Window Full - Duel
    # Segment-aware bias
    if cand_p_key:
        # Victim is in Probation
        # Relaxed Bias: Allow Window item to win if strictly better (fw > fm)
        # Ties (fw == fm) favor Main (Incumbent)
        if fw > fm:
            return cand_m_key
        else:
            return cand_w_key
    else:
        # Victim is in Protected
        # Strong Bias: Protect core items. Window must be significantly better.
        if fw > fm + 2:
            return cand_m_key
        else:
            return cand_w_key

def update_after_hit(cache_snapshot, obj):
    _reset_if_needed(cache_snapshot.access_count)
    state = algo_state
    key = obj.key
    capacity = cache_snapshot.capacity
    
    _update_freq(key, capacity)
    
    # Cache Position Updates
    if key in state['window']:
        state['window'].move_to_end(key)
    elif key in state['protected']:
        state['protected'].move_to_end(key)
    elif key in state['probation']:
        # SLRU Promotion: Probation -> Protected
        val = state['probation'].pop(key)
        state['prob_size'] -= val
        state['protected'][key] = val
        state['prot_size'] += val
        
        # Enforce Protected Limit (80% of Main)
        limit = int(capacity * 0.8)
        while state['prot_size'] > limit and state['protected']:
            # Demote: Protected LRU -> Probation MRU
            k, v = state['protected'].popitem(last=False)
            state['prot_size'] -= v
            state['probation'][k] = v
            state['prob_size'] += v
            state['probation'].move_to_end(k)

def update_after_insert(cache_snapshot, obj):
    _reset_if_needed(cache_snapshot.access_count)
    state = algo_state
    key = obj.key
    size = obj.size
    capacity = cache_snapshot.capacity

    # 1. Update Frequency
    _update_freq(key, capacity)
    
    # 2. Insert into Window
    state['window'][key] = size
    state['w_size'] += size
    
    # 3. Handle Window Overflow -> Move to Probation
    w_cap = max(1, int(capacity * 0.01))
    while state['w_size'] > w_cap and state['window']:
        k, v = state['window'].popitem(last=False) # Pop LRU
        state['w_size'] -= v
        state['probation'][k] = v
        state['prob_size'] += v
        state['probation'].move_to_end(k) # MRU
        
def update_after_evict(cache_snapshot, obj, evicted_obj):
    state = algo_state
    key = evicted_obj.key
    size = evicted_obj.size
    
    if key in state['window']:
        del state['window'][key]
        state['w_size'] -= size
    elif key in state['probation']:
        del state['probation'][key]
        state['prob_size'] -= size
    elif key in state['protected']:
        del state['protected'][key]
        state['prot_size'] -= size
# EVOLVE-BLOCK-END