--- a/original.py
+++ b/original.py
@@ -1,137 +1,192 @@
 # EVOLVE-BLOCK-START
-"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""
+"""W-TinyLFU with optimized parameters"""
 
-# ARC Globals
-m_t1 = dict() # Recency (L1)
-m_t2 = dict() # Frequency (L2)
-m_b1 = dict() # Ghost Recency
-m_b2 = dict() # Ghost Frequency
-p = 0         # Adaptive parameter
+# Globals
+g_window = dict()
+g_probation = dict()
+g_protected = dict()
+
+# Frequency Sketch
+g_freq = dict()
+g_doorkeeper = set()
+
+# Configuration
+g_window_limit = 0
+g_protected_limit = 0
+g_access_counter = 0
 
 def evict(cache_snapshot, obj):
     '''
-    ARC Eviction Logic with Randomization:
-    - Adapt p based on hits in ghost lists (B1, B2).
-    - Decide whether to evict from T1 or T2 based on p and T1 size.
-    - Use Random Eviction to robustly handle loops and large working sets.
+    W-TinyLFU Eviction:
+    - Maintains Window (1%), Probation, Protected segments.
+    - If Window > Limit:
+        - TinyLFU duel: Window LRU vs Probation LRU.
+        - If Window LRU has higher freq, evict Probation LRU and move Window item to Probation.
+        - Else evict Window LRU.
+    - Else:
+        - Evict Probation LRU.
     '''
-    global p
-    import random
-
-    capacity = cache_snapshot.capacity
-
-    # Adaptation: If the incoming object (miss) is in a ghost list
-    if obj.key in m_b1:
-        delta = 1
-        if len(m_b1) < len(m_b2):
-             delta = len(m_b2) / len(m_b1)
-        p = min(capacity, p + delta)
-    elif obj.key in m_b2:
-        delta = 1
-        if len(m_b2) < len(m_b1):
-             delta = len(m_b1) / len(m_b2)
-        p = max(0, p - delta)
-
-    # Decision: Select victim
-    evict_t1 = False
-    if len(m_t1) > 0:
-        if len(m_t1) > p:
-            evict_t1 = True
-        elif obj.key in m_b2 and len(m_t1) == int(p):
-            evict_t1 = True
-        elif len(m_t2) == 0:
-            evict_t1 = True
-
-    if evict_t1:
-        return random.choice(list(m_t1.keys()))
-    else:
-        return random.choice(list(m_t2.keys()))
+    global g_window, g_probation, g_protected, g_window_limit, g_freq, g_doorkeeper
+    
+    # Identify candidates (LRU is first in dict iteration)
+    window_candidate = next(iter(g_window)) if g_window else None
+    probation_candidate = next(iter(g_probation)) if g_probation else None
+    
+    # 1. Window Overflow Handling with Duel
+    # We only trigger the duel if the Window is exceeding its allowance.
+    if window_candidate is not None and len(g_window) > g_window_limit:
+        if probation_candidate is None:
+            return window_candidate
+        
+        # Frequencies
+        fw = g_freq.get(window_candidate, 0) + (1 if window_candidate in g_doorkeeper else 0)
+        fp = g_freq.get(probation_candidate, 0) + (1 if probation_candidate in g_doorkeeper else 0)
+        
+        # Bias: Favor Main by +1 to reduce churn
+        if fw > fp + 1:
+            # Window wins: Promote Window Candidate to Probation, Evict Probation Candidate
+            # Move window_candidate to Probation MRU
+            val = g_window.pop(window_candidate)
+            g_probation[window_candidate] = val
+            return probation_candidate
+        else:
+            # Main wins (or tie): Evict Window Candidate
+            return window_candidate
+            
+    # 2. Main Cache Full Handling (or Window small)
+    # Prefer evicting from Probation, then Protected
+    if probation_candidate is not None:
+        return probation_candidate
+    
+    if g_protected:
+        return next(iter(g_protected))
+        
+    # Fallback
+    if window_candidate is not None:
+        return window_candidate
+        
+    return next(iter(cache_snapshot.cache))
 
 def update_after_hit(cache_snapshot, obj):
     '''
-    On Cache Hit:
-    - If obj in T1, move to T2 (MRU).
-    - If obj in T2, move to MRU of T2.
+    On Hit:
+    - Update Frequency.
+    - Update Position (LRU/MRU) and Segment.
     '''
-    global m_t1, m_t2
-
-    if obj.key in m_t1:
-        del m_t1[obj.key]
-        m_t2[obj.key] = None
-    elif obj.key in m_t2:
-        del m_t2[obj.key]
-        m_t2[obj.key] = None
+    global g_window, g_probation, g_protected, g_freq, g_doorkeeper, g_protected_limit
+    
+    key = obj.key
+    
+    # Update Frequency (Cap at 15)
+    curr = g_freq.get(key, 0)
+    if curr < 15:
+        g_freq[key] = curr + 1
+        
+    # Segment Management
+    if key in g_window:
+        # Move to MRU
+        val = g_window.pop(key)
+        g_window[key] = val
+    elif key in g_probation:
+        # Promote to Protected MRU
+        val = g_probation.pop(key)
+        g_protected[key] = val
+        # Handle Protected Overflow: Demote LRU to Probation MRU
+        if len(g_protected) > g_protected_limit:
+            lru_p_key = next(iter(g_protected))
+            val_p = g_protected.pop(lru_p_key)
+            g_probation[lru_p_key] = val_p
+    elif key in g_protected:
+        # Move to MRU
+        val = g_protected.pop(key)
+        g_protected[key] = val
 
 def update_after_insert(cache_snapshot, obj):
     '''
-    On Cache Insert (Miss):
-    - Place obj in T1 or T2.
+    On Insert (Miss):
+    - Initialize if needed.
+    - Update Frequency/Doorkeeper.
+    - Insert into Window.
+    - Periodic Reset.
     '''
-    global m_t1, m_t2, m_b1, m_b2, p
+    global g_window, g_probation, g_protected, g_freq, g_doorkeeper
+    global g_window_limit, g_protected_limit, g_access_counter
+    
+    capacity = cache_snapshot.capacity
+    
+    # Init
+    if cache_snapshot.access_count <= 1:
+        g_window.clear()
+        g_probation.clear()
+        g_protected.clear()
+        g_freq.clear()
+        g_doorkeeper.clear()
+        g_access_counter = 0
+        g_window_limit = max(1, int(capacity * 0.01))
+        # Main is 99%, Protected is 80% of Main
+        main = capacity - g_window_limit
+        g_protected_limit = int(main * 0.8)
 
-    # Reset state at start of new trace (access_count starts at 1 usually for first miss)
-    if cache_snapshot.access_count <= 1:
-        m_t1.clear()
-        m_t2.clear()
-        m_b1.clear()
-        m_b2.clear()
-        p = 0
+    key = obj.key
+    g_access_counter += 1
+    
+    # Update Frequency
+    if key not in g_doorkeeper:
+        g_doorkeeper.add(key)
+    else:
+        curr = g_freq.get(key, 0)
+        if curr < 15:
+            g_freq[key] = curr + 1
 
-    # Check if it was a ghost
-    is_ghost = False
-    if obj.key in m_b1:
-        del m_b1[obj.key]
-        is_ghost = True
-    if obj.key in m_b2:
-        del m_b2[obj.key]
-        is_ghost = True
-
-    if is_ghost:
-        # History hit -> promote to frequency list
-        m_t2[obj.key] = None
-    else:
-        # New item -> probation list
-        m_t1[obj.key] = None
+    # Insert to Window MRU
+    g_window[key] = None
+    
+    # Aging / Reset
+    # 1. Clear Doorkeeper if too big
+    if len(g_doorkeeper) > capacity * 2:
+        g_doorkeeper.clear()
+        
+    # 2. Halve Frequencies periodically
+    if g_access_counter >= capacity * 10:
+        g_access_counter = 0
+        # Halve
+        for k in list(g_freq):
+            g_freq[k] //= 2
+            if g_freq[k] == 0:
+                del g_freq[k]
 
 def update_after_evict(cache_snapshot, obj, evicted_obj):
     '''
     After Eviction:
-    - Update ghost lists.
+    - Remove from internal structure.
     '''
-    global m_t1, m_t2, m_b1, m_b2
-
-    if evicted_obj.key in m_t1:
-        del m_t1[evicted_obj.key]
-        m_b1[evicted_obj.key] = None
-    elif evicted_obj.key in m_t2:
-        del m_t2[evicted_obj.key]
-        m_b2[evicted_obj.key] = None
-
-    # Constrain ghost list sizes to capacity
-    capacity = cache_snapshot.capacity
-    while len(m_b1) > capacity:
-        m_b1.pop(next(iter(m_b1)))
-    while len(m_b2) > capacity:
-        m_b2.pop(next(iter(m_b2)))
-
+    global g_window, g_probation, g_protected
+    
+    key = evicted_obj.key
+    if key in g_window:
+        del g_window[key]
+    elif key in g_probation:
+        del g_probation[key]
+    elif key in g_protected:
+        del g_protected[key]
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate