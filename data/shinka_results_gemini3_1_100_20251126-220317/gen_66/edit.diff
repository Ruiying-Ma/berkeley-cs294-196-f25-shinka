--- a/original.py
+++ b/original.py
@@ -1,210 +1,208 @@
 # EVOLVE-BLOCK-START
 """
-W-TinyLFU with Refined Doorkeeper, Adaptive Aging, and Biased Eviction
-Maintains a small Window and an SLRU Main Cache.
-Uses a Doorkeeper to filter one-hit wonders and frequency counters for admission to Main.
-Improvements:
-- Size-based Doorkeeper reset to handle scans better.
-- Adaptive Window eviction (checks Main victim value).
-- Biased duel favoring Main cache to reduce churn.
-- 5x capacity aging for faster adaptability.
+W-TinyLFU Optimized Hybrid
+Combines W-TinyLFU eviction policy with tuned parameters:
+- Window (1%) + SLRU Main Cache (Probation + Protected).
+- Doorkeeper for admission (resets at 4x capacity).
+- Frequency counting with Adaptive Aging (halves every 5x capacity).
+- Increased frequency resolution (max 31).
+- Biased duel to prefer Main cache victims unless Window is significantly better.
 """
 from collections import OrderedDict
 
 # Global State
 algo_state = {
     'window': OrderedDict(),    # key -> size (LRU is first)
     'probation': OrderedDict(), # key -> size (LRU is first)
     'protected': OrderedDict(), # key -> size (LRU is first)
     'w_size': 0,
     'prob_size': 0,
     'prot_size': 0,
-    'freq': {},                 # key -> count (>= 2)
-    'doorkeeper': set(),        # Set of keys seen approximately once
-    'aging_counter': 0,         # Counter for frequency aging
+    'freq': {},                 # key -> count
+    'doorkeeper': set(),        # Set of keys seen once
+    'aging_counter': 0,         # Counter for aging
     'max_time': 0               # For detecting trace reset
 }
 
 def _check_reset(cache_snapshot):
     current_time = cache_snapshot.access_count
+    # If time goes backward, it means a new trace started
     if current_time < algo_state['max_time']:
         algo_state['window'].clear()
         algo_state['probation'].clear()
         algo_state['protected'].clear()
         algo_state['w_size'] = 0
         algo_state['prob_size'] = 0
         algo_state['prot_size'] = 0
         algo_state['freq'].clear()
         algo_state['doorkeeper'].clear()
         algo_state['aging_counter'] = 0
         algo_state['max_time'] = 0
     algo_state['max_time'] = current_time
 
 def _update_freq(key, capacity):
     state = algo_state
-    
+
     # Aging Mechanism
     state['aging_counter'] += 1
-    # Age frequencies every 5x capacity to adapt to phase changes
+    # Age frequencies every 5x capacity (Fast adaptation)
     if state['aging_counter'] >= capacity * 5:
         state['aging_counter'] = 0
         # Halve frequencies
         rem = []
         for k, v in state['freq'].items():
             nv = v // 2
             if nv == 0: rem.append(k)
             else: state['freq'][k] = nv
         for k in rem: del state['freq'][k]
-    
+
     # Doorkeeper Management
-    # Reset Doorkeeper when it grows too large to maintain filter effectiveness
-    if len(state['doorkeeper']) > capacity * 2:
+    # Reset Doorkeeper when it grows too large (4x capacity - Hybrid value)
+    if len(state['doorkeeper']) > capacity * 4:
         state['doorkeeper'].clear()
 
     # Frequency Update
     if key in state['freq']:
-        state['freq'][key] = min(state['freq'][key] + 1, 15)
+        # Cap frequency at 31 (Higher resolution than 15)
+        state['freq'][key] = min(state['freq'][key] + 1, 31)
     elif key in state['doorkeeper']:
         state['doorkeeper'].remove(key)
         state['freq'][key] = 2
     else:
         state['doorkeeper'].add(key)
 
 def _get_freq(key):
-    # Returns estimated frequency
     if key in algo_state['freq']:
         return algo_state['freq'][key]
     if key in algo_state['doorkeeper']:
         return 1
     return 0
 
 def evict(cache_snapshot, obj):
     _check_reset(cache_snapshot)
     state = algo_state
     capacity = cache_snapshot.capacity
     w_cap = max(1, int(capacity * 0.01))
-    
-    # Identify Candidates (LRU is at the beginning of OrderedDict)
+
+    # Candidates (LRU is first in OrderedDict)
     cand_w_key = next(iter(state['window'])) if state['window'] else None
     cand_m_key = None
     if state['probation']:
         cand_m_key = next(iter(state['probation']))
     elif state['protected']:
         cand_m_key = next(iter(state['protected']))
-    
+
     # Fail-safe
     if cand_w_key is None and cand_m_key is None:
         return None
     if cand_w_key is None:
         return cand_m_key
     if cand_m_key is None:
         return cand_w_key
 
     fw = _get_freq(cand_w_key)
     fm = _get_freq(cand_m_key)
 
     # 1. Window Growing Phase
-    # Ideally, we evict Main to let Window grow. 
-    # Exception: If Main victim is valuable (fm > fw), sacrifice Window instead.
+    # Prefer evicting from Main to let Window grow to its target size.
+    # Exception: If Main victim is strictly more valuable than Window victim.
     if state['w_size'] < w_cap:
         if fm > fw:
             return cand_w_key
         return cand_m_key
-    
+
     # 2. Window Full - Duel
-    # Bias towards Main: Evict Window unless Window candidate is strictly better + bias.
-    # This protects established Main items from churn.
+    # Bias towards Main to prevent churn.
+    # Evict Window unless Window candidate is significantly better (fw > fm + 1).
     if fw > fm + 1:
         return cand_m_key
     else:
         return cand_w_key
 
 def update_after_hit(cache_snapshot, obj):
     _check_reset(cache_snapshot)
     state = algo_state
     key = obj.key
     capacity = cache_snapshot.capacity
-    
+
     _update_freq(key, capacity)
-    
-    # Cache Position Updates
+
+    # Position Update
     if key in state['window']:
         state['window'].move_to_end(key)
     elif key in state['protected']:
         state['protected'].move_to_end(key)
     elif key in state['probation']:
-        # SLRU Promotion: Probation -> Protected
+        # Promote Probation -> Protected
         val = state['probation'].pop(key)
         state['prob_size'] -= val
         state['protected'][key] = val
         state['prot_size'] += val
-        
-        # Enforce Protected Limit (80% of Main)
-        # Main capacity roughly Capacity - Window.
+
+        # Enforce Protected Limit (80% of Main Capacity)
         limit = int(capacity * 0.8)
         while state['prot_size'] > limit and state['protected']:
-            # Demote: Protected LRU -> Probation MRU
             k, v = state['protected'].popitem(last=False)
             state['prot_size'] -= v
             state['probation'][k] = v
             state['prob_size'] += v
             state['probation'].move_to_end(k)
 
 def update_after_insert(cache_snapshot, obj):
     _check_reset(cache_snapshot)
     state = algo_state
     key = obj.key
     size = obj.size
     capacity = cache_snapshot.capacity
 
-    # 1. Update Frequency
+    # Insert counts as access for frequency
     _update_freq(key, capacity)
-    
-    # 2. Insert into Window
+
+    # Insert to Window
     state['window'][key] = size
     state['w_size'] += size
-    
-    # 3. Handle Window Overflow -> Move to Probation
+
+    # Handle Window Overflow -> Move to Probation
     w_cap = max(1, int(capacity * 0.01))
     while state['w_size'] > w_cap and state['window']:
-        k, v = state['window'].popitem(last=False) # Pop LRU
+        k, v = state['window'].popitem(last=False)
         state['w_size'] -= v
         state['probation'][k] = v
         state['prob_size'] += v
-        state['probation'].move_to_end(k) # MRU
-        
+        state['probation'].move_to_end(k)
+
 def update_after_evict(cache_snapshot, obj, evicted_obj):
     state = algo_state
     key = evicted_obj.key
     size = evicted_obj.size
-    
+
     if key in state['window']:
         del state['window'][key]
         state['w_size'] -= size
     elif key in state['probation']:
         del state['probation'][key]
         state['prob_size'] -= size
     elif key in state['protected']:
         del state['protected'][key]
         state['prot_size'] -= size
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate