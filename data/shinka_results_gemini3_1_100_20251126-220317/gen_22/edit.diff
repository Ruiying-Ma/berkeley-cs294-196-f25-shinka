--- a/original.py
+++ b/original.py
@@ -1,171 +1,236 @@
 # EVOLVE-BLOCK-START
-"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""
+"""Cache eviction algorithm with Adaptive TinyLFU, Doorkeeper, and SLRU"""
 from collections import OrderedDict
 
-# W-TinyLFU inspired State
+# Adaptive TinyLFU State
 algo_state = {
-    'window': OrderedDict(),    # Window Cache (SLRU or LRU)
+    'window': OrderedDict(),    # Nursery (FIFO behavior for eviction, promote on hit)
     'probation': OrderedDict(), # Main Cache - Probation (SLRU)
     'protected': OrderedDict(), # Main Cache - Protected (SLRU)
+    'ghost_w': OrderedDict(),   # History of keys evicted from Window
+    'ghost_p': OrderedDict(),   # History of keys evicted from Probation
     'freq': {},                 # Frequency Counter
-    'freq_count': 0,            # Total increments for reset
-    'max_time': 0
+    'doorkeeper': set(),        # Doorkeeper (1-bit counter approx)
+    'target_w': 1.0,            # Target Window Size
+    'op_count': 0,              # Operation counter for aging
+    'max_time': 0,              # Track trace reset
+    'initialized': False        # Flag for initial setup
 }
 
 def _check_reset(current_time):
     if current_time < algo_state['max_time']:
         algo_state['window'].clear()
         algo_state['probation'].clear()
         algo_state['protected'].clear()
+        algo_state['ghost_w'].clear()
+        algo_state['ghost_p'].clear()
         algo_state['freq'].clear()
-        algo_state['freq_count'] = 0
+        algo_state['doorkeeper'].clear()
+        algo_state['target_w'] = 1.0
+        algo_state['op_count'] = 0
+        algo_state['initialized'] = False
         algo_state['max_time'] = 0
     algo_state['max_time'] = current_time
 
+def _get_freq(key):
+    # Calculate frequency with Doorkeeper logic
+    f = algo_state['freq'].get(key, 0)
+    if key in algo_state['doorkeeper']:
+        f += 1
+    return f
+
 def evict(cache_snapshot, obj):
     '''
-    W-TinyLFU Eviction Logic
+    Eviction Logic:
+    1. Determine candidates (Window LRU vs Main LRU).
+    2. Check Adaptive Window Sizing logic.
+    3. Duel if necessary using Frequency.
     '''
     window = algo_state['window']
     probation = algo_state['probation']
     protected = algo_state['protected']
-    freq = algo_state['freq']
-
-    capacity = cache_snapshot.capacity
-    w_cap = max(1, int(capacity * 0.05)) # 5% Window
-
-    # Candidates
+    target_w = algo_state['target_w']
+    
+    # Identify candidates
     candidate_w = next(iter(window)) if window else None
-
-    # Main Candidate: Probation LRU, else Protected LRU
+    
     candidate_m = None
     if probation:
         candidate_m = next(iter(probation))
     elif protected:
         candidate_m = next(iter(protected))
-
-    victim = None
-
-    # 1. If Window needs space (is below target), grow it by evicting Main
-    # (Unless Main is empty, then evict Window)
-    if len(window) < w_cap and candidate_m:
-        victim = candidate_m
-    elif not candidate_m:
-        victim = candidate_w
-    elif not candidate_w:
-        victim = candidate_m
+        
+    # If Main is empty, must evict Window
+    if not candidate_m:
+        return candidate_w
+    # If Window is empty, must evict Main
+    if not candidate_w:
+        return candidate_m
+
+    # Adaptive Logic
+    # If Window is growing (<= target), prefer evicting Main to make space
+    if len(window) <= target_w:
+        return candidate_m
     else:
-        # 2. Window is full. Duel.
-        # Compare frequency
-        fw = freq.get(candidate_w, 0)
-        fm = freq.get(candidate_m, 0)
-
+        # Window is full/oversized. Duel to decide.
+        fw = _get_freq(candidate_w)
+        fm = _get_freq(candidate_m)
+        
         # Tie-breaker: Prefer Main (Incumbent) -> Evict Window
-        # This provides scan and loop resistance
         if fw > fm:
-            victim = candidate_m
+            return candidate_m
         else:
-            victim = candidate_w
-
-    return victim
+            return candidate_w
 
 def update_after_hit(cache_snapshot, obj):
     _check_reset(cache_snapshot.access_count)
     key = obj.key
     window = algo_state['window']
     probation = algo_state['probation']
     protected = algo_state['protected']
-    freq = algo_state['freq']
-
-    # Frequency
-    freq[key] = freq.get(key, 0) + 1
-    algo_state['freq_count'] += 1
-    if algo_state['freq_count'] >= cache_snapshot.capacity * 10:
+    
+    # Update Frequency & Doorkeeper
+    if key in algo_state['freq']:
+        algo_state['freq'][key] += 1
+    elif key in algo_state['doorkeeper']:
+        algo_state['freq'][key] = 1
+        algo_state['doorkeeper'].remove(key)
+    else:
+        algo_state['doorkeeper'].add(key)
+        
+    # Aging
+    algo_state['op_count'] += 1
+    if algo_state['op_count'] >= cache_snapshot.capacity * 10:
         to_remove = []
-        for k in freq:
-            freq[k] //= 2
-            if freq[k] == 0: to_remove.append(k)
-        for k in to_remove: del freq[k]
-        algo_state['freq_count'] = 0
-
-    # Cache Maintenance
+        for k in algo_state['freq']:
+            algo_state['freq'][k] //= 2
+            if algo_state['freq'][k] == 0: to_remove.append(k)
+        for k in to_remove: del algo_state['freq'][k]
+        algo_state['doorkeeper'].clear()
+        algo_state['op_count'] = 0
+
+    # Cache Promotions
     if key in window:
-        window.move_to_end(key)
-    elif key in protected:
-        protected.move_to_end(key)
+        # Hit in Window -> Promote to Probation (S3-FIFO logic)
+        del window[key]
+        probation[key] = None
     elif key in probation:
-        # Promote
+        # Hit in Probation -> Promote to Protected
         del probation[key]
         protected[key] = None
-
-        # Enforce Protected Limit
-        w_cap = max(1, int(cache_snapshot.capacity * 0.05))
-        m_cap = cache_snapshot.capacity - w_cap
-        p_cap = int(m_cap * 0.8) # 80% of Main
-
-        while len(protected) > p_cap:
+    elif key in protected:
+        # Hit in Protected -> MRU
+        protected.move_to_end(key)
+        
+    # Enforce Protected Capacity (80% of Main)
+    main_size = len(probation) + len(protected)
+    if main_size > 0:
+        protected_cap = int(main_size * 0.8)
+        while len(protected) > protected_cap:
             k, _ = protected.popitem(last=False)
-            probation[k] = None # Move to Probation MRU
-            probation.move_to_end(k)
+            probation[k] = None # Demote to Probation MRU
 
 def update_after_insert(cache_snapshot, obj):
     _check_reset(cache_snapshot.access_count)
     key = obj.key
-    freq = algo_state['freq']
-
-    # Frequency
-    freq[key] = freq.get(key, 0) + 1
-    algo_state['freq_count'] += 1
-    if algo_state['freq_count'] >= cache_snapshot.capacity * 10:
+    capacity = cache_snapshot.capacity
+    
+    # Initialize target_w on first run
+    if not algo_state['initialized']:
+        algo_state['target_w'] = max(1, int(capacity * 0.1))
+        algo_state['initialized'] = True
+
+    # Frequency Update (Insert counts as access)
+    if key in algo_state['freq']:
+        algo_state['freq'][key] += 1
+    elif key in algo_state['doorkeeper']:
+        algo_state['freq'][key] = 1
+        algo_state['doorkeeper'].remove(key)
+    else:
+        algo_state['doorkeeper'].add(key)
+
+    # Adaptive Sizing based on Ghosts
+    if key in algo_state['ghost_w']:
+        # Hit in window ghost -> Window too small
+        algo_state['target_w'] = min(capacity, algo_state['target_w'] + 1)
+        del algo_state['ghost_w'][key]
+    elif key in algo_state['ghost_p']:
+        # Hit in main ghost -> Main too small
+        algo_state['target_w'] = max(1, algo_state['target_w'] - 1)
+        del algo_state['ghost_p'][key]
+
+    # Insert New Item into Window
+    algo_state['window'][key] = None
+
+    # Aging
+    algo_state['op_count'] += 1
+    if algo_state['op_count'] >= capacity * 10:
         to_remove = []
-        for k in freq:
-            freq[k] //= 2
-            if freq[k] == 0: to_remove.append(k)
-        for k in to_remove: del freq[k]
-        algo_state['freq_count'] = 0
-
-    # Insert to Window MRU
-    algo_state['window'][key] = None
+        for k in algo_state['freq']:
+            algo_state['freq'][k] //= 2
+            if algo_state['freq'][k] == 0: to_remove.append(k)
+        for k in to_remove: del algo_state['freq'][k]
+        algo_state['doorkeeper'].clear()
+        algo_state['op_count'] = 0
 
 def update_after_evict(cache_snapshot, obj, evicted_obj):
     v_key = evicted_obj.key
     window = algo_state['window']
     probation = algo_state['probation']
     protected = algo_state['protected']
-
+    
+    # Determine source and clean up
+    src_is_main = False
     if v_key in window:
         del window[v_key]
+        algo_state['ghost_w'][v_key] = None
     elif v_key in probation:
         del probation[v_key]
+        algo_state['ghost_p'][v_key] = None
+        src_is_main = True
     elif v_key in protected:
         del protected[v_key]
-
-    # Check for Window promotion
-    # If we evicted Main, and Window is now > Cap (it wasn't evicted), move Window LRU to Probation
-    w_cap = max(1, int(cache_snapshot.capacity * 0.05))
-    if len(window) > w_cap:
-        k, _ = window.popitem(last=False)
-        probation[k] = None # To Probation MRU
-        probation.move_to_end(k)
-
+        algo_state['ghost_p'][v_key] = None
+        src_is_main = True
+        
+    # Manage Ghost Capacity (Global or per list)
+    # Keeping total ghosts ~ capacity is standard
+    capacity = cache_snapshot.capacity
+    while len(algo_state['ghost_w']) + len(algo_state['ghost_p']) > capacity:
+        # Prune ghosts (simple FIFO/LRU)
+        if len(algo_state['ghost_w']) > len(algo_state['ghost_p']):
+             algo_state['ghost_w'].popitem(last=False)
+        else:
+             if algo_state['ghost_p']:
+                 algo_state['ghost_p'].popitem(last=False)
+             elif algo_state['ghost_w']:
+                 algo_state['ghost_w'].popitem(last=False)
+
+    # Rebalance if we evicted Main but Window is too large
+    # This prevents Window from consuming all space if Main keeps losing duels
+    # We move Window LRU to Probation (transferring the pressure)
+    if src_is_main and len(window) > algo_state['target_w']:
+        if window:
+            k, _ = window.popitem(last=False)
+            probation[k] = None
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate