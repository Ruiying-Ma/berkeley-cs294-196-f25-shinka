<NAME>
optimize_tinylfu_parameters_and_logic
</NAME>

<DESCRIPTION>
Optimizes the W-TinyLFU algorithm with several improvements:
1.  **Relaxed SLRU Promotion**: Items in the probation segment are promoted to the protected segment immediately upon their first hit, removing the 'second hit' requirement. This helps the protected segment fill faster with the working set.
2.  **Duel Bias**: Introduces a bias in the eviction duel favoring the Main cache victim. The Window victim is only saved (and Main victim evicted) if the Window victim's frequency is significantly higher (`freq_w > freq_m + 1`).
3.  **Conditional Main Eviction**: When the Window is below its target size, the algorithm normally evicts from Main to allow Window growth. This logic is refined to spare the Main victim if it has a non-zero frequency, evicting from the Window instead. This prevents flushing valuable history for the sake of a static segment ratio.
4.  **Optimized Metadata Management**: Reduces `max_freq` to 15 (from 60) to adapt faster to workload changes. Separates Doorkeeper clearing from the aging interval, clearing it based on a size threshold (`2 * capacity`) to better handle scan resistance.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
class TinyLFUState:
    def __init__(self, capacity):
        self.capacity = capacity
        # Cache Segments
        self.window = OrderedDict()
        self.probation = OrderedDict()
        self.protected = OrderedDict()

        # Metadata
        self.freq = {}
        self.doorkeeper = set()
        self.probation_hits = {} # Track hits for probation items
        self.access_count = 0

        # Configuration
        # 1% Window, 99% Main (split 80/20 Protected/Probation)
        self.window_size = max(1, int(capacity * 0.01))
        self.protected_size = max(1, int(capacity * 0.79))

        # Aging and Constraints
        # Age every 5x capacity to handle phase changes
        self.aging_interval = capacity * 5
        self.max_freq = 60

    def get_freq(self, key):
        return self.freq.get(key, 0)

    def record_access(self, key):
        self.access_count += 1

        # Doorkeeper & Frequency Logic
        if key in self.freq:
            if self.freq[key] < self.max_freq:
                self.freq[key] += 1
        elif key in self.doorkeeper:
            self.doorkeeper.remove(key)
            self.freq[key] = 1 # Promoted from Doorkeeper to Frequency Map
        else:
            self.doorkeeper.add(key)

        if self.access_count % self.aging_interval == 0:
            self.age()

    def age(self):
        # Halve frequencies
        rem = []
        for k in self.freq:
            self.freq[k] //= 2
            if self.freq[k] == 0:
                rem.append(k)
        for k in rem:
            del self.freq[k]
        self.doorkeeper.clear()
=======
class TinyLFUState:
    def __init__(self, capacity):
        self.capacity = capacity
        # Cache Segments
        self.window = OrderedDict()
        self.probation = OrderedDict()
        self.protected = OrderedDict()

        # Metadata
        self.freq = {}
        self.doorkeeper = set()
        self.access_count = 0

        # Configuration
        # 1% Window, 99% Main (split 80/20 Protected/Probation)
        self.window_size = max(1, int(capacity * 0.01))
        self.protected_size = max(1, int(capacity * 0.79))

        # Aging and Constraints
        # Age every 5x capacity to handle phase changes
        self.aging_interval = capacity * 5
        self.max_freq = 15
        self.doorkeeper_limit = max(1000, capacity * 2)

    def get_freq(self, key):
        return self.freq.get(key, 0)

    def record_access(self, key):
        self.access_count += 1

        # Doorkeeper & Frequency Logic
        if key in self.freq:
            if self.freq[key] < self.max_freq:
                self.freq[key] += 1
        elif key in self.doorkeeper:
            self.doorkeeper.remove(key)
            self.freq[key] = 1 # Promoted from Doorkeeper to Frequency Map
        else:
            self.doorkeeper.add(key)

        if len(self.doorkeeper) > self.doorkeeper_limit:
            self.doorkeeper.clear()

        if self.access_count % self.aging_interval == 0:
            self.age()

    def age(self):
        # Halve frequencies
        rem = []
        for k in self.freq:
            self.freq[k] //= 2
            if self.freq[k] == 0:
                rem.append(k)
        for k in rem:
            del self.freq[k]
>>>>>>> REPLACE
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    """
    Determine eviction victim.
    If Window is full, duel Window LRU vs Main Probation LRU.
    Otherwise, evict from Main to make room for Window growth.
    """
    state = get_state(cache_snapshot)

    # Consistency Check (Reset if cache was cleared externally)
    if not cache_snapshot.cache and (state.window or state.probation):
        state.window.clear()
        state.probation.clear()
        state.protected.clear()
        state.freq.clear()
        state.doorkeeper.clear()
        state.probation_hits.clear()

    # If Window is full (or overfull), we must duel or evict from Window
    if len(state.window) >= state.window_size:
        w_victim_key = next(iter(state.window))

        # If Main is empty, Window victim must go
        if not state.probation and not state.protected:
            return w_victim_key

        # Identify Main victim (Probation LRU preferred, else Protected LRU)
        if state.probation:
            m_victim_key = next(iter(state.probation))
        else:
            m_victim_key = next(iter(state.protected))

        # TinyLFU Duel
        freq_w = state.get_freq(w_victim_key)
        freq_m = state.get_freq(m_victim_key)

        if freq_w > freq_m:
            return m_victim_key
        else:
            return w_victim_key
    else:
        # Window not full: Prefer evicting from Main to grow Window
        if state.probation:
            return next(iter(state.probation))
        elif state.protected:
            return next(iter(state.protected))
        elif state.window:
            return next(iter(state.window))
        else:
            # Fallback
            return next(iter(cache_snapshot.cache))
=======
def evict(cache_snapshot, obj):
    """
    Determine eviction victim.
    If Window is full, duel Window LRU vs Main Probation LRU.
    Otherwise, evict from Main to make room for Window growth.
    """
    state = get_state(cache_snapshot)

    # Consistency Check (Reset if cache was cleared externally)
    if not cache_snapshot.cache and (state.window or state.probation):
        state.window.clear()
        state.probation.clear()
        state.protected.clear()
        state.freq.clear()
        state.doorkeeper.clear()

    # If Window is full (or overfull), we must duel or evict from Window
    if len(state.window) >= state.window_size:
        w_victim_key = next(iter(state.window))

        # If Main is empty, Window victim must go
        if not state.probation and not state.protected:
            return w_victim_key

        # Identify Main victim (Probation LRU preferred, else Protected LRU)
        if state.probation:
            m_victim_key = next(iter(state.probation))
        else:
            m_victim_key = next(iter(state.protected))

        # TinyLFU Duel
        freq_w = state.get_freq(w_victim_key)
        freq_m = state.get_freq(m_victim_key)

        # Bias towards Main: only evict Main if Window item is significantly better
        if freq_w > freq_m + 1:
            return m_victim_key
        else:
            return w_victim_key
    else:
        # Window not full: Generally prefer evicting from Main to grow Window.
        # However, if Main victim has history, spare it and evict from Window instead.

        m_victim_key = None
        if state.probation:
            m_victim_key = next(iter(state.probation))
        elif state.protected:
            m_victim_key = next(iter(state.protected))

        if m_victim_key:
            # Check if Main victim is valuable
            if state.window and state.get_freq(m_victim_key) > 0:
                # Spare Main, evict Window to keep valuable item
                return next(iter(state.window))
            return m_victim_key

        elif state.window:
            return next(iter(state.window))
        else:
            # Fallback
            return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    state = get_state(cache_snapshot)
    key = obj.key
    state.record_access(key)

    if key in state.window:
        state.window.move_to_end(key)

    elif key in state.probation:
        # Promote to Protected if it has proved itself (2 hits in probation)
        if key in state.probation_hits:
            del state.probation[key]
            del state.probation_hits[key]
            state.protected[key] = True

            # Handle Protected Overflow: Move LRU to Probation
            if len(state.protected) > state.protected_size:
                victim, _ = state.protected.popitem(last=False)
                state.probation[victim] = True
                state.probation.move_to_end(victim)
                # Note: Demoted item enters probation without 'probation_hits' credit
        else:
            state.probation_hits[key] = True
            state.probation.move_to_end(key)

    elif key in state.protected:
        state.protected.move_to_end(key)
=======
def update_after_hit(cache_snapshot, obj):
    state = get_state(cache_snapshot)
    key = obj.key
    state.record_access(key)

    if key in state.window:
        state.window.move_to_end(key)

    elif key in state.probation:
        # Promote to Protected immediately
        del state.probation[key]
        state.protected[key] = True

        # Handle Protected Overflow: Move LRU to Probation
        if len(state.protected) > state.protected_size:
            victim, _ = state.protected.popitem(last=False)
            state.probation[victim] = True
            state.probation.move_to_end(victim)

    elif key in state.protected:
        state.protected.move_to_end(key)
>>>>>>> REPLACE
<<<<<<< SEARCH
def update_after_evict(cache_snapshot, obj, evicted_obj):
    state = get_state(cache_snapshot)
    key = evicted_obj.key

    if key in state.window:
        del state.window[key]
    elif key in state.probation:
        del state.probation[key]
        if key in state.probation_hits:
            del state.probation_hits[key]
    elif key in state.protected:
        del state.protected[key]
=======
def update_after_evict(cache_snapshot, obj, evicted_obj):
    state = get_state(cache_snapshot)
    key = evicted_obj.key

    if key in state.window:
        del state.window[key]
    elif key in state.probation:
        del state.probation[key]
    elif key in state.protected:
        del state.protected[key]
>>>>>>> REPLACE
</DIFF>