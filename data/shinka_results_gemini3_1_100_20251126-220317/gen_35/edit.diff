--- a/original.py
+++ b/original.py
@@ -1,198 +1,210 @@
 # EVOLVE-BLOCK-START
-"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""
+"""
+W-TinyLFU with Doorkeeper and Size-Aware Management
+Maintains a 1% Window and an SLRU Main Cache (Probation + Protected).
+Uses a Doorkeeper to filter one-hit wonders and frequency counters for admission to Main.
+"""
 from collections import OrderedDict
 
-# W-TinyLFU inspired State
+# Global State
 algo_state = {
-    'window': OrderedDict(),    # Window Cache (SLRU or LRU)
-    'probation': OrderedDict(), # Main Cache - Probation (SLRU)
-    'protected': OrderedDict(), # Main Cache - Protected (SLRU)
-    'freq': {},                 # Frequency Counter
-    'doorkeeper': set(),        # Doorkeeper for one-hit wonders
-    'freq_count': 0,            # Total increments for reset
-    'max_time': 0
+    'window': OrderedDict(),    # key -> size (LRU is first)
+    'probation': OrderedDict(), # key -> size (LRU is first)
+    'protected': OrderedDict(), # key -> size (LRU is first)
+    'w_size': 0,
+    'prob_size': 0,
+    'prot_size': 0,
+    'freq': {},                 # key -> count
+    'doorkeeper': set(),        # Set of keys seen once
+    'freq_counter': 0,          # Counter for aging
+    'max_time': 0               # For detecting trace reset
 }
 
-def _check_reset(current_time):
+def _check_reset(cache_snapshot):
+    current_time = cache_snapshot.access_count
     if current_time < algo_state['max_time']:
         algo_state['window'].clear()
         algo_state['probation'].clear()
         algo_state['protected'].clear()
+        algo_state['w_size'] = 0
+        algo_state['prob_size'] = 0
+        algo_state['prot_size'] = 0
         algo_state['freq'].clear()
         algo_state['doorkeeper'].clear()
-        algo_state['freq_count'] = 0
+        algo_state['freq_counter'] = 0
         algo_state['max_time'] = 0
     algo_state['max_time'] = current_time
 
 def evict(cache_snapshot, obj):
-    '''
-    W-TinyLFU Eviction Logic with Doorkeeper Support
-    '''
-    window = algo_state['window']
-    probation = algo_state['probation']
-    protected = algo_state['protected']
-    freq = algo_state['freq']
-    doorkeeper = algo_state['doorkeeper']
-
+    _check_reset(cache_snapshot)
+    state = algo_state
     capacity = cache_snapshot.capacity
-    w_cap = max(1, int(capacity * 0.05)) # 5% Window
-
-    # Candidates
-    candidate_w = next(iter(window)) if window else None
-
-    # Main Candidate: Probation LRU, else Protected LRU
-    candidate_m = None
-    if probation:
-        candidate_m = next(iter(probation))
-    elif protected:
-        candidate_m = next(iter(protected))
-
-    victim = None
-
-    # 1. If Window needs space (is below target), grow it by evicting Main
-    # (Unless Main is empty, then evict Window)
-    if len(window) < w_cap and candidate_m:
-        victim = candidate_m
-    elif not candidate_m:
-        victim = candidate_w
-    elif not candidate_w:
-        victim = candidate_m
+    w_cap = max(1, int(capacity * 0.01))
+    
+    # Identify Candidates (LRU is at the beginning of OrderedDict)
+    cand_w_key = next(iter(state['window'])) if state['window'] else None
+    cand_m_key = None
+    if state['probation']:
+        cand_m_key = next(iter(state['probation']))
+    elif state['protected']:
+        cand_m_key = next(iter(state['protected']))
+    
+    # Fail-safe
+    if cand_w_key is None and cand_m_key is None:
+        return None
+    if cand_w_key is None:
+        return cand_m_key
+    if cand_m_key is None:
+        return cand_w_key
+
+    # Admission Policy
+    # 1. If Window is growing (below capacity), evict from Main to make room.
+    if state['w_size'] < w_cap:
+        return cand_m_key
+    
+    # 2. Window is full. Duel Window LRU vs Main LRU.
+    freq = state['freq']
+    dk = state['doorkeeper']
+    
+    def get_freq(k):
+        # If in Doorkeeper, effectively freq 1. If not seen, 0.
+        return freq.get(k, 1 if k in dk else 0)
+
+    fw = get_freq(cand_w_key)
+    fm = get_freq(cand_m_key)
+    
+    # If Window candidate has higher frequency, it wins (is better to keep).
+    # We evict Main candidate. Window candidate will overflow to Probation in insert.
+    if fw > fm:
+        return cand_m_key
     else:
-        # 2. Window is full. Duel.
-        # Helper to get frequency
-        def get_freq(k):
-            if k in freq: return freq[k]
-            if k in doorkeeper: return 1
-            return 0
-
-        fw = get_freq(candidate_w)
-        fm = get_freq(candidate_m)
-
-        # Tie-breaker: Prefer Main (Incumbent) -> Evict Window
-        if fw > fm:
-            victim = candidate_m
-        else:
-            victim = candidate_w
-
-    return victim
+        # Window candidate loses (or tie). Evict it.
+        # Prefer evicting new random items (Window) over established ones (Main) on ties.
+        return cand_w_key
 
 def update_after_hit(cache_snapshot, obj):
-    _check_reset(cache_snapshot.access_count)
+    _check_reset(cache_snapshot)
+    state = algo_state
     key = obj.key
-    window = algo_state['window']
-    probation = algo_state['probation']
-    protected = algo_state['protected']
-    freq = algo_state['freq']
-    doorkeeper = algo_state['doorkeeper']
-
-    # Frequency Aging
-    algo_state['freq_count'] += 1
-    if algo_state['freq_count'] >= cache_snapshot.capacity * 5:
-        doorkeeper.clear()
-        to_remove = []
-        for k in freq:
-            freq[k] //= 2
-            if freq[k] == 0: to_remove.append(k)
-        for k in to_remove: del freq[k]
-        algo_state['freq_count'] = 0
-
-    # Frequency Update
-    if key in freq:
-        freq[key] = min(freq[key] + 1, 15)
-    elif key in doorkeeper:
-        freq[key] = 2
-        doorkeeper.remove(key)
+    capacity = cache_snapshot.capacity
+    
+    # 1. Update Frequency
+    state['freq_counter'] += 1
+    # Aging
+    if state['freq_counter'] >= capacity * 10:
+        state['freq_counter'] = 0
+        state['doorkeeper'].clear()
+        # Halve frequencies
+        rem = []
+        for k, v in state['freq'].items():
+            nv = v // 2
+            if nv == 0: rem.append(k)
+            else: state['freq'][k] = nv
+        for k in rem: del state['freq'][k]
+
+    if key in state['freq']:
+        state['freq'][key] = min(state['freq'][key] + 1, 15)
+    elif key in state['doorkeeper']:
+        state['doorkeeper'].remove(key)
+        state['freq'][key] = 2
     else:
-        doorkeeper.add(key)
-
-    # Cache Maintenance
-    if key in window:
-        window.move_to_end(key)
-    elif key in protected:
-        protected.move_to_end(key)
-    elif key in probation:
-        # Promote
-        del probation[key]
-        protected[key] = None
-
-        # Enforce Protected Limit
-        w_cap = max(1, int(cache_snapshot.capacity * 0.05))
-        m_cap = cache_snapshot.capacity - w_cap
-        p_cap = int(m_cap * 0.8) # 80% of Main
-
-        while len(protected) > p_cap:
-            k, _ = protected.popitem(last=False)
-            probation[k] = None # Move to Probation MRU
-            probation.move_to_end(k)
+        state['doorkeeper'].add(key)
+        
+    # 2. Update Cache Position
+    if key in state['window']:
+        state['window'].move_to_end(key)
+    elif key in state['protected']:
+        state['protected'].move_to_end(key)
+    elif key in state['probation']:
+        # Promote: Probation -> Protected
+        val = state['probation'].pop(key)
+        state['prob_size'] -= val
+        state['protected'][key] = val
+        state['prot_size'] += val
+        
+        # Enforce Protected Limit (80% of Main)
+        # Main Capacity ~ 99% of Total. Protected ~ 80% of Main.
+        limit = int(capacity * 0.8)
+        while state['prot_size'] > limit and state['protected']:
+            # Demote: Protected LRU -> Probation MRU
+            k, v = state['protected'].popitem(last=False)
+            state['prot_size'] -= v
+            state['probation'][k] = v
+            state['prob_size'] += v
+            state['probation'].move_to_end(k)
 
 def update_after_insert(cache_snapshot, obj):
-    _check_reset(cache_snapshot.access_count)
+    _check_reset(cache_snapshot)
+    state = algo_state
     key = obj.key
-    freq = algo_state['freq']
-    doorkeeper = algo_state['doorkeeper']
-
-    # Frequency Aging
-    algo_state['freq_count'] += 1
-    if algo_state['freq_count'] >= cache_snapshot.capacity * 5:
-        doorkeeper.clear()
-        to_remove = []
-        for k in freq:
-            freq[k] //= 2
-            if freq[k] == 0: to_remove.append(k)
-        for k in to_remove: del freq[k]
-        algo_state['freq_count'] = 0
-
-    # Frequency Update
-    if key in freq:
-        freq[key] = min(freq[key] + 1, 15)
-    elif key in doorkeeper:
-        freq[key] = 2
-        doorkeeper.remove(key)
+    size = obj.size
+    capacity = cache_snapshot.capacity
+
+    # 1. Update Frequency (Insert counts as access)
+    state['freq_counter'] += 1
+    if state['freq_counter'] >= capacity * 10:
+        state['freq_counter'] = 0
+        state['doorkeeper'].clear()
+        rem = []
+        for k, v in state['freq'].items():
+            nv = v // 2
+            if nv == 0: rem.append(k)
+            else: state['freq'][k] = nv
+        for k in rem: del state['freq'][k]
+
+    if key in state['freq']:
+        state['freq'][key] = min(state['freq'][key] + 1, 15)
+    elif key in state['doorkeeper']:
+        state['doorkeeper'].remove(key)
+        state['freq'][key] = 2
     else:
-        doorkeeper.add(key)
-
-    # Insert to Window MRU
-    algo_state['window'][key] = None
+        state['doorkeeper'].add(key)
+    
+    # 2. Insert into Window
+    state['window'][key] = size
+    state['w_size'] += size
+    
+    # 3. Handle Window Overflow -> Move to Probation
+    w_cap = max(1, int(capacity * 0.01))
+    while state['w_size'] > w_cap and state['window']:
+        k, v = state['window'].popitem(last=False) # Pop LRU
+        state['w_size'] -= v
+        state['probation'][k] = v
+        state['prob_size'] += v
+        state['probation'].move_to_end(k) # MRU
 
 def update_after_evict(cache_snapshot, obj, evicted_obj):
-    v_key = evicted_obj.key
-    window = algo_state['window']
-    probation = algo_state['probation']
-    protected = algo_state['protected']
-
-    if v_key in window:
-        del window[v_key]
-    elif v_key in probation:
-        del probation[v_key]
-    elif v_key in protected:
-        del protected[v_key]
-
-    # Check for Window promotion
-    # If we evicted Main, and Window is now > Cap (it wasn't evicted), move Window LRU to Probation
-    w_cap = max(1, int(cache_snapshot.capacity * 0.05))
-    if len(window) > w_cap:
-        k, _ = window.popitem(last=False)
-        probation[k] = None # To Probation MRU
-        probation.move_to_end(k)
-
+    state = algo_state
+    key = evicted_obj.key
+    size = evicted_obj.size
+    
+    if key in state['window']:
+        del state['window'][key]
+        state['w_size'] -= size
+    elif key in state['probation']:
+        del state['probation'][key]
+        state['prob_size'] -= size
+    elif key in state['protected']:
+        del state['protected'][key]
+        state['prot_size'] -= size
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate