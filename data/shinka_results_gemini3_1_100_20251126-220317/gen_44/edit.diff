--- a/original.py
+++ b/original.py
@@ -1,183 +1,201 @@
 # EVOLVE-BLOCK-START
 """
-WALRUS: Window-LFU with Aging and Ghost Frequencies
-Combines a FIFO Window for scan resistance with a Frequency-based Main segment.
-Uses randomized sampling for approximate LFU eviction in the Main segment.
-Maintains ghost frequencies to support loop patterns and applies periodic aging.
+W-TinyLFU with Doorkeeper and SLRU
+Implements Window-TinyLFU eviction policy.
+- Window Cache (1%): LRU policy for new items.
+- Main Cache (99%): SLRU (Segmented LRU) with Probation (20%) and Protected (80%).
+- TinyLFU Admission: Adopts a Doorkeeper to filter rare items and a Frequency Sketch (Map) to guide eviction.
+- Aging: Halves frequencies periodically to adapt to changing workloads.
 """
 import random
-from collections import deque
-
-class WalrusState:
+from collections import OrderedDict
+
+class TinyLFUState:
     def __init__(self, capacity):
         self.capacity = capacity
-        self.window = deque()          # FIFO queue for new items
-        self.main = set()              # Set of keys in the Main segment
-        self.freq = {}                 # Global frequency counter (includes ghosts)
-        self.access_count = 0          # Total access counter
-        self.aging_interval = capacity # Age frequencies every 'capacity' accesses
-        
-        # Tuning parameters
-        self.window_ratio = 0.1
-        self.sample_size = 5
-        self.max_freq_history = capacity * 5 
+        # Cache Segments
+        self.window = OrderedDict()
+        self.probation = OrderedDict()
+        self.protected = OrderedDict()
+        
+        # Metadata
+        self.freq = {}
+        self.doorkeeper = set()
+        self.probation_hits = {} # Track hits for probation items
+        self.access_count = 0
+        
+        # Configuration
+        # 1% Window, 99% Main (split 80/20 Protected/Probation)
+        self.window_size = max(1, int(capacity * 0.01))
+        self.protected_size = max(1, int(capacity * 0.79))
+        
+        # Aging and Constraints
+        # Age every 5x capacity to handle phase changes
+        self.aging_interval = capacity * 5
+        self.max_freq = 60
 
     def get_freq(self, key):
         return self.freq.get(key, 0)
 
-    def inc_freq(self, key):
-        self.freq[key] = self.freq.get(key, 0) + 1
-
-    def age_freqs(self):
-        # Halve frequencies to bias towards recent popularity
-        keys_to_remove = []
-        for k, v in self.freq.items():
-            new_v = v >> 1 # Integer division by 2
-            if new_v == 0:
-                keys_to_remove.append(k)
-            else:
-                self.freq[k] = new_v
-        
-        for k in keys_to_remove:
-            # Don't remove if currently in cache!
-            if k not in self.main and k not in self.window:
-                del self.freq[k]
-            else:
-                self.freq[k] = 1 # Keep at least 1 if in cache
-
-_walrus_state = {}
+    def record_access(self, key):
+        self.access_count += 1
+        
+        # Doorkeeper & Frequency Logic
+        if key in self.freq:
+            if self.freq[key] < self.max_freq:
+                self.freq[key] += 1
+        elif key in self.doorkeeper:
+            self.doorkeeper.remove(key)
+            self.freq[key] = 1 # Promoted from Doorkeeper to Frequency Map
+        else:
+            self.doorkeeper.add(key)
+            
+        if self.access_count % self.aging_interval == 0:
+            self.age()
+
+    def age(self):
+        # Halve frequencies
+        rem = []
+        for k in self.freq:
+            self.freq[k] //= 2
+            if self.freq[k] == 0:
+                rem.append(k)
+        for k in rem:
+            del self.freq[k]
+        self.doorkeeper.clear()
+
+_states = {}
 
 def get_state(cache_snapshot):
-    cache_id = id(cache_snapshot.cache)
-    if cache_id not in _walrus_state:
-        _walrus_state[cache_id] = WalrusState(cache_snapshot.capacity)
-    return _walrus_state[cache_id]
+    cid = id(cache_snapshot.cache)
+    if cid not in _states:
+        _states[cid] = TinyLFUState(cache_snapshot.capacity)
+    return _states[cid]
 
 def evict(cache_snapshot, obj):
-    '''
-    Decide eviction victim based on Window vs Main duel.
-    '''
-    state = get_state(cache_snapshot)
-    
-    # Clean up state if cache was reset externally
-    if not cache_snapshot.cache and (state.window or state.main):
+    """
+    Determine eviction victim.
+    If Window is full, duel Window LRU vs Main Probation LRU.
+    Otherwise, evict from Main to make room for Window growth.
+    """
+    state = get_state(cache_snapshot)
+    
+    # Consistency Check (Reset if cache was cleared externally)
+    if not cache_snapshot.cache and (state.window or state.probation):
         state.window.clear()
-        state.main.clear()
+        state.probation.clear()
+        state.protected.clear()
         state.freq.clear()
-
-    # Target Window Size
-    target_window = max(1, int(cache_snapshot.capacity * state.window_ratio))
-    
-    victim = None
-    
-    # Scenario 1: Window is full (or over quota)
-    # Check if we should evict from Window or if Window victim can displace a Main item
-    if len(state.window) >= target_window:
-        # Candidate from Window (FIFO Tail)
-        w_candidate = state.window[0]
-        
-        # If Main is empty, we must evict from Window
-        if not state.main:
-            return w_candidate
-            
-        # Candidate from Main (Approximate LFU via Sampling)
-        # Random sampling is used to avoid O(N) sort/scan
-        sample_keys = random.sample(list(state.main), min(len(state.main), state.sample_size))
-        m_candidate = min(sample_keys, key=lambda k: state.get_freq(k))
-        
-        # Duel: Frequency check
-        # Strict inequality (>): New items must PROVE they are better to displace Main items.
-        # This provides scan resistance (frequency 1 items lose to frequency > 1).
-        w_freq = state.get_freq(w_candidate)
-        m_freq = state.get_freq(m_candidate)
-        
-        if w_freq > m_freq:
-            victim = m_candidate
-        else:
-            victim = w_candidate
-            
-    # Scenario 2: Window is under quota.
-    # Ideally we make space in Main to allow Window to grow.
+        state.doorkeeper.clear()
+        state.probation_hits.clear()
+
+    # If Window is full (or overfull), we must duel or evict from Window
+    if len(state.window) >= state.window_size:
+        w_victim_key = next(iter(state.window))
+        
+        # If Main is empty, Window victim must go
+        if not state.probation and not state.protected:
+            return w_victim_key
+            
+        # Identify Main victim (Probation LRU preferred, else Protected LRU)
+        if state.probation:
+            m_victim_key = next(iter(state.probation))
+        else:
+            m_victim_key = next(iter(state.protected))
+            
+        # TinyLFU Duel
+        freq_w = state.get_freq(w_victim_key)
+        freq_m = state.get_freq(m_victim_key)
+        
+        if freq_w > freq_m:
+            return m_victim_key
+        else:
+            return w_victim_key
     else:
-        if state.main:
-            sample_keys = random.sample(list(state.main), min(len(state.main), state.sample_size))
-            victim = min(sample_keys, key=lambda k: state.get_freq(k))
+        # Window not full: Prefer evicting from Main to grow Window
+        if state.probation:
+            return next(iter(state.probation))
+        elif state.protected:
+            return next(iter(state.protected))
         elif state.window:
-             victim = state.window[0]
-        else:
-             victim = next(iter(cache_snapshot.cache))
-
-    return victim
+            return next(iter(state.window))
+        else:
+            # Fallback
+            return next(iter(cache_snapshot.cache))
 
 def update_after_hit(cache_snapshot, obj):
     state = get_state(cache_snapshot)
-    state.access_count += 1
-    state.inc_freq(obj.key)
-    
-    # Aging
-    if state.access_count % state.aging_interval == 0:
-        state.age_freqs()
+    key = obj.key
+    state.record_access(key)
+    
+    if key in state.window:
+        state.window.move_to_end(key)
+        
+    elif key in state.probation:
+        # Promote to Protected if it has proved itself (2 hits in probation)
+        if key in state.probation_hits:
+            del state.probation[key]
+            del state.probation_hits[key]
+            state.protected[key] = True
+            
+            # Handle Protected Overflow: Move LRU to Probation
+            if len(state.protected) > state.protected_size:
+                victim, _ = state.protected.popitem(last=False)
+                state.probation[victim] = True
+                state.probation.move_to_end(victim) 
+                # Note: Demoted item enters probation without 'probation_hits' credit
+        else:
+            state.probation_hits[key] = True
+            state.probation.move_to_end(key)
+            
+    elif key in state.protected:
+        state.protected.move_to_end(key)
 
 def update_after_insert(cache_snapshot, obj):
     state = get_state(cache_snapshot)
-    state.access_count += 1
-    state.inc_freq(obj.key)
+    key = obj.key
+    state.record_access(key)
     
     # New items always enter Window
-    state.window.append(obj.key)
-    
-    # Clean up frequency map if growing too large (Ghost cleanup)
-    if len(state.freq) > state.max_freq_history:
-        # Simple cleanup heuristic could go here, but relying on aging is usually sufficient
-        pass
-    
-    if state.access_count % state.aging_interval == 0:
-        state.age_freqs()
+    state.window[key] = True
+    
+    # Balance segments if Window grew too large due to Main eviction
+    # (i.e. we evicted Main to make room, so Window grew by 1. Move old window item to Main)
+    if len(state.window) > state.window_size:
+        victim, _ = state.window.popitem(last=False)
+        state.probation[victim] = True
+        state.probation.move_to_end(victim)
 
 def update_after_evict(cache_snapshot, obj, evicted_obj):
     state = get_state(cache_snapshot)
     key = evicted_obj.key
     
-    # Remove from local structures
-    if key in state.main:
-        state.main.remove(key)
-    
-    if state.window:
-        if state.window[0] == key:
-            state.window.popleft()
-        else:
-            try:
-                state.window.remove(key)
-            except ValueError:
-                pass
-                
-    # Logic Update:
-    # If we evicted a Main item to make room for a Window item (Duel won),
-    # The Window item (the duel winner) must be moved to Main to free up the Window slot.
-    # We detect this condition by checking if Window is over capacity.
-    target_window = max(1, int(cache_snapshot.capacity * state.window_ratio))
-    while len(state.window) > target_window:
-        # Promote the oldest window item to Main
-        winner = state.window.popleft()
-        state.main.add(winner)
+    if key in state.window:
+        del state.window[key]
+    elif key in state.probation:
+        del state.probation[key]
+        if key in state.probation_hits:
+            del state.probation_hits[key]
+    elif key in state.protected:
+        del state.protected[key]
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate