--- a/original.py
+++ b/original.py
@@ -1,185 +1,218 @@
 # EVOLVE-BLOCK-START
-"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""
-
-from collections import deque, OrderedDict
-
-# W-TinyLFU style state
+"""
+Adaptive W-TinyLFU with Ghost Lists
+- Dynamically adjusts Window vs Main sizes based on ghost hits.
+- Uses W-TinyLFU admission policy (Frequency Duel).
+- SLRU for Main Cache (Probation + Protected).
+- Doorkeeper for scan resistance.
+"""
+from collections import OrderedDict
+
 algo_state = {
-    'window': deque(),        # Queue of (key, size)
-    'window_size': 0,         # Current size of window
+    'window': OrderedDict(),    # key -> size
     'probation': OrderedDict(), # key -> size
     'protected': OrderedDict(), # key -> size
+    'window_size': 0,
     'protected_size': 0,
-    'freq': {},               # key -> count
-    'doorkeeper': set(),      # key
-    'access_count': 0
+    'freq': {},                 # key -> count
+    'doorkeeper': set(),        # key
+    'access_count': 0,
+    'w_ratio': 0.01,            # 1% initial window
+    'ghost_w': OrderedDict(),   # keys evicted from Window
+    'ghost_m': OrderedDict(),   # keys evicted from Main
 }
 
 def evict(cache_snapshot, obj):
     '''
-    W-TinyLFU Eviction:
-    - Maintains a small Window (1%) and a Main SLRU (Probation + Protected).
-    - If Window is not full, evict from Main (to allow Window to grow).
-    - If Window is full, duel the Window victim vs Main victim using frequency.
+    Adaptive W-TinyLFU Eviction with Doorkeeper
     '''
     window = algo_state['window']
     probation = algo_state['probation']
     protected = algo_state['protected']
     freq = algo_state['freq']
     dk = algo_state['doorkeeper']
-
+    
     capacity = cache_snapshot.capacity
-    w_cap = max(1, int(capacity * 0.01))
+    w_cap = int(capacity * algo_state['w_ratio'])
+    if w_cap < 1: w_cap = 1
 
     def get_freq(k):
-        return freq.get(k, 1 if k in dk else 0)
-
-    # 1. If Window has space, prefer evicting from Main (Probation -> Protected)
-    if algo_state['window_size'] < w_cap:
-        if probation:
-            return next(iter(probation))
-        if protected:
-            return next(iter(protected))
-        if window:
-            return window[0][0]
-
-    # 2. Window is full. Find candidates.
-    if not window:
-        # Fallback if window empty (rare)
-        if probation: return next(iter(probation))
-        if protected: return next(iter(protected))
-        return None
-
-    cand_w_key = window[0][0]
-
+        if k in freq: return freq[k]
+        if k in dk: return 1
+        return 0
+
+    candidate_w = next(iter(window)) if window else None
+    
+    candidate_m = None
     if probation:
-        cand_m_key = next(iter(probation))
+        candidate_m = next(iter(probation))
     elif protected:
-        cand_m_key = next(iter(protected))
+        candidate_m = next(iter(protected))
+
+    victim = None
+
+    # 1. Grow Window if needed (and Main has victim)
+    if algo_state['window_size'] < w_cap and candidate_m:
+        victim = candidate_m
+    
+    # 2. Window Full -> Duel
+    elif candidate_w:
+        if not candidate_m:
+            victim = candidate_w
+        else:
+            fw = get_freq(candidate_w)
+            fm = get_freq(candidate_m)
+            # Tie-breaker: Evict Window (reject new)
+            if fw > fm:
+                victim = candidate_m
+            else:
+                victim = candidate_w
     else:
-        return cand_w_key
-
-    # Duel: Keep the one with higher frequency
-    freq_w = get_freq(cand_w_key)
-    freq_m = get_freq(cand_m_key)
-
-    if freq_w > freq_m:
-        return cand_m_key
-    else:
-        return cand_w_key
+        victim = candidate_m
+
+    return victim
 
 def update_after_hit(cache_snapshot, obj):
-    '''
-    Update frequency and manage SLRU promotion.
-    '''
     key = obj.key
     algo_state['access_count'] += 1
 
-    # Frequency Update & Aging
     f = algo_state['freq']
     dk = algo_state['doorkeeper']
-
+    
+    # Frequency & Aging
     if key in f:
-        f[key] = min(f[key] + 1, 15)
+        f[key] = min(f[key] + 1, 63)
     elif key in dk:
         dk.remove(key)
         f[key] = 2
     else:
         dk.add(key)
 
-    if algo_state['access_count'] > cache_snapshot.capacity * 5:
+    if algo_state['access_count'] >= cache_snapshot.capacity * 10:
         algo_state['doorkeeper'].clear()
-        algo_state['freq'] = {k: v // 2 for k, v in f.items() if v > 1}
+        to_rem = []
+        for k, v in f.items():
+            f[k] = v // 2
+            if f[k] == 0: to_rem.append(k)
+        for k in to_rem: del f[k]
         algo_state['access_count'] = 0
 
-    # SLRU Management
-    if key in algo_state['protected']:
+    # Cache Update
+    if key in algo_state['window']:
+        algo_state['window'].move_to_end(key)
+    elif key in algo_state['protected']:
         algo_state['protected'].move_to_end(key)
     elif key in algo_state['probation']:
-        # Promote from Probation to Protected
-        val = algo_state['probation'].pop(key)
-        algo_state['protected'][key] = val
-        algo_state['protected_size'] += val
-
-        # Enforce Protected Limit (80% of capacity)
-        limit = int(cache_snapshot.capacity * 0.8)
-        while algo_state['protected_size'] > limit and algo_state['protected']:
+        # Promote
+        s = algo_state['probation'].pop(key)
+        algo_state['protected'][key] = s
+        algo_state['protected_size'] += s
+        
+        # SLRU Limit (80% of Main)
+        m_cap = max(1, cache_snapshot.capacity - algo_state['window_size'])
+        p_limit = int(m_cap * 0.8)
+        
+        while algo_state['protected_size'] > p_limit and algo_state['protected']:
             k, v = algo_state['protected'].popitem(last=False)
             algo_state['protected_size'] -= v
             algo_state['probation'][k] = v
+            algo_state['probation'].move_to_end(k)
 
 def update_after_insert(cache_snapshot, obj):
-    '''
-    Insert new object into Window and handle overflow to Probation.
-    '''
     key = obj.key
     size = obj.size
     algo_state['access_count'] += 1
 
-    # Frequency Update
+    # Adaptive Window - Ghost Hits
+    gw = algo_state['ghost_w']
+    gm = algo_state['ghost_m']
+    
+    if key in gw:
+        algo_state['w_ratio'] = min(0.8, algo_state['w_ratio'] + 0.01)
+        del gw[key]
+    elif key in gm:
+        algo_state['w_ratio'] = max(0.01, algo_state['w_ratio'] - 0.01)
+        del gm[key]
+
+    # Frequency
     f = algo_state['freq']
     dk = algo_state['doorkeeper']
-
     if key in f:
-        f[key] = min(f[key] + 1, 15)
+        f[key] = min(f[key] + 1, 63)
     elif key in dk:
         dk.remove(key)
         f[key] = 2
     else:
         dk.add(key)
 
-    # Aging (also on insert)
-    if algo_state['access_count'] > cache_snapshot.capacity * 5:
+    if algo_state['access_count'] >= cache_snapshot.capacity * 10:
         algo_state['doorkeeper'].clear()
-        algo_state['freq'] = {k: v // 2 for k, v in f.items() if v > 1}
+        to_rem = []
+        for k, v in f.items():
+            f[k] = v // 2
+            if f[k] == 0: to_rem.append(k)
+        for k in to_rem: del f[k]
         algo_state['access_count'] = 0
 
-    # Insert into Window
-    algo_state['window'].append((key, size))
+    # Insert to Window
+    algo_state['window'][key] = size
     algo_state['window_size'] += size
 
-    # Check Window Overflow -> Move to Probation
-    w_cap = max(1, int(cache_snapshot.capacity * 0.01))
-    while algo_state['window_size'] > w_cap and algo_state['window']:
-        k, s = algo_state['window'].popleft()
+def update_after_evict(cache_snapshot, obj, evicted_obj):
+    v_key = evicted_obj.key
+    v_size = evicted_obj.size
+    
+    window = algo_state['window']
+    probation = algo_state['probation']
+    protected = algo_state['protected']
+    gw = algo_state['ghost_w']
+    gm = algo_state['ghost_m']
+
+    # Identify and Remove
+    if v_key in window:
+        del window[v_key]
+        algo_state['window_size'] -= v_size
+        gw[v_key] = None
+    elif v_key in probation:
+        del probation[v_key]
+        gm[v_key] = None
+    elif v_key in protected:
+        val = protected.pop(v_key)
+        algo_state['protected_size'] -= val
+        gm[v_key] = None
+        
+    # Trim Ghosts
+    g_cap = cache_snapshot.capacity
+    if len(gw) > g_cap: gw.popitem(last=False)
+    if len(gm) > g_cap: gm.popitem(last=False)
+    
+    # Manage Window -> Probation migration
+    w_cap = int(cache_snapshot.capacity * algo_state['w_ratio'])
+    if w_cap < 1: w_cap = 1
+    
+    if algo_state['window_size'] >= w_cap and window:
+        k, s = window.popitem(last=False)
         algo_state['window_size'] -= s
-        algo_state['probation'][k] = s
-
-def update_after_evict(cache_snapshot, obj, evicted_obj):
-    '''
-    Remove evicted object from internal structures.
-    '''
-    key = evicted_obj.key
-    size = evicted_obj.size
-
-    # Check and remove from locations
-    if algo_state['window'] and algo_state['window'][0][0] == key:
-        algo_state['window'].popleft()
-        algo_state['window_size'] -= size
-    elif key in algo_state['probation']:
-        del algo_state['probation'][key]
-    elif key in algo_state['protected']:
-        val = algo_state['protected'].pop(key)
-        algo_state['protected_size'] -= val
-
+        probation[k] = s
+        probation.move_to_end(k) # MRU
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate