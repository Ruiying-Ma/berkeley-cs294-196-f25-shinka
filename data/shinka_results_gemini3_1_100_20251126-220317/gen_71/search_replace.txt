<NAME>
segment_aware_wtinylfu
</NAME>

<DESCRIPTION>
Refined W-TinyLFU with segment-aware eviction, slower aging, and higher resolution frequency.
- Segment-Aware Eviction: Differentiates between Probation and Protected victims. Probation victims are evicted if Window candidate is equal or better (fw >= fm), promoting turnover. Protected victims are defended (fw > fm + 1).
- Tuned Frequency: Increased max frequency to 31 for better resolution.
- Tuned Aging: Aging interval increased to 10x capacity to retain history longer, suiting stable working sets.
- Tuned Doorkeeper: Reset threshold increased to 5x capacity to improve scan resistance.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
"""
W-TinyLFU with Doorkeeper, Adaptive Aging, and Biased Eviction.
Maintains a small Window and an SLRU Main Cache.
Uses a Doorkeeper to filter one-hit wonders.
"""
from collections import deque, OrderedDict

# Global State
algo_state = {
    'window': OrderedDict(),    # key -> size (LRU is first)
    'window_size': 0,           # Current total size of window
    'probation': OrderedDict(), # key -> size (LRU is first)
    'protected': OrderedDict(), # key -> size (LRU is first)
    'protected_size': 0,
    'freq': {},                 # key -> count
    'doorkeeper': set(),        # Set of keys seen approximately once
    'aging_counter': 0,
    'max_time': 0               # For detecting trace reset
}

def _reset_state(current_time):
    if current_time < algo_state['max_time']:
        algo_state['window'].clear()
        algo_state['window_size'] = 0
        algo_state['probation'].clear()
        algo_state['protected'].clear()
        algo_state['protected_size'] = 0
        algo_state['freq'].clear()
        algo_state['doorkeeper'].clear()
        algo_state['aging_counter'] = 0
        algo_state['max_time'] = 0
    algo_state['max_time'] = current_time

def _update_freq(key, capacity):
    state = algo_state

    # Aging
    state['aging_counter'] += 1
    if state['aging_counter'] >= capacity * 5:
        state['aging_counter'] = 0
        # Halve frequencies
        rem = []
        for k, v in state['freq'].items():
            nv = v // 2
            if nv == 0: rem.append(k)
            else: state['freq'][k] = nv
        for k in rem: del state['freq'][k]

    # Doorkeeper Management
    if len(state['doorkeeper']) > capacity * 2:
        state['doorkeeper'].clear()

    # Update
    if key in state['freq']:
        state['freq'][key] = min(state['freq'][key] + 1, 15)
    elif key in state['doorkeeper']:
        state['doorkeeper'].remove(key)
        state['freq'][key] = 2
    else:
        state['doorkeeper'].add(key)

def _get_freq(key):
    if key in algo_state['freq']:
        return algo_state['freq'][key]
    if key in algo_state['doorkeeper']:
        return 1
    return 0

def evict(cache_snapshot, obj):
    _reset_state(cache_snapshot.access_count)
    state = algo_state
    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.01))

    # Candidates
    cand_w_key = next(iter(state['window'])) if state['window'] else None

    cand_m_key = None
    if state['probation']:
        cand_m_key = next(iter(state['probation']))
    elif state['protected']:
        cand_m_key = next(iter(state['protected']))

    # Fail-safe
    if cand_w_key is None and cand_m_key is None: return None
    if cand_w_key is None: return cand_m_key
    if cand_m_key is None: return cand_w_key

    fw = _get_freq(cand_w_key)
    fm = _get_freq(cand_m_key)

    # 1. Window Growing Logic
    if state['window_size'] < w_cap:
        # If Main victim is valuable (fm > fw), sacrifice Window instead.
        if fm > fw:
            return cand_w_key
        return cand_m_key

    # 2. Window Full - Duel
    # Bias towards Main (Probation/Protected) to avoid churn.
    if fw > fm + 1:
        return cand_m_key
    else:
        return cand_w_key

def update_after_hit(cache_snapshot, obj):
    _reset_state(cache_snapshot.access_count)
    state = algo_state
    key = obj.key
    capacity = cache_snapshot.capacity

    _update_freq(key, capacity)

    # Position Update
    if key in state['window']:
        state['window'].move_to_end(key)
    elif key in state['protected']:
        state['protected'].move_to_end(key)
    elif key in state['probation']:
        # Promote Probation -> Protected
        val = state['probation'].pop(key)
        state['protected'][key] = val
        state['protected_size'] += val

        # Enforce Protected Limit (80% of Main)
        limit = int(capacity * 0.8)
        while state['protected_size'] > limit and state['protected']:
            k, v = state['protected'].popitem(last=False)
            state['protected_size'] -= v
            state['probation'][k] = v
            state['probation'].move_to_end(k)

def update_after_insert(cache_snapshot, obj):
    _reset_state(cache_snapshot.access_count)
    state = algo_state
    key = obj.key
    size = obj.size
    capacity = cache_snapshot.capacity

    _update_freq(key, capacity)

    # Insert to Window
    state['window'][key] = size
    state['window_size'] += size

    # Check Window Overflow -> Move to Probation
    w_cap = max(1, int(capacity * 0.01))
    while state['window_size'] > w_cap and state['window']:
        k, s = state['window'].popitem(last=False)
        state['window_size'] -= s

        state['probation'][k] = s
        state['probation'].move_to_end(k)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    state = algo_state
    key = evicted_obj.key
    size = evicted_obj.size

    if key in state['window']:
        del state['window'][key]
        state['window_size'] -= size
    elif key in state['probation']:
        del state['probation'][key]
    elif key in state['protected']:
        val = state['protected'].pop(key)
        state['protected_size'] -= val
=======
"""
W-TinyLFU with Segment-Aware Eviction, Tuned Aging, and High-Res Frequency.
Maintains a small Window and an SLRU Main Cache (Probation + Protected).
- Segment-Aware: Eviction policy varies if victim is Probation (fair duel) or Protected (defensive).
- Tuned Aging: 10x capacity aging and 5x capacity Doorkeeper reset.
- High-Res Frequency: Max frequency 31.
"""
from collections import deque, OrderedDict

# Global State
algo_state = {
    'window': OrderedDict(),    # key -> size (LRU is first)
    'window_size': 0,           # Current total size of window
    'probation': OrderedDict(), # key -> size (LRU is first)
    'protected': OrderedDict(), # key -> size (LRU is first)
    'protected_size': 0,
    'freq': {},                 # key -> count
    'doorkeeper': set(),        # Set of keys seen approximately once
    'aging_counter': 0,
    'max_time': 0               # For detecting trace reset
}

def _reset_state(current_time):
    if current_time < algo_state['max_time']:
        algo_state['window'].clear()
        algo_state['window_size'] = 0
        algo_state['probation'].clear()
        algo_state['protected'].clear()
        algo_state['protected_size'] = 0
        algo_state['freq'].clear()
        algo_state['doorkeeper'].clear()
        algo_state['aging_counter'] = 0
        algo_state['max_time'] = 0
    algo_state['max_time'] = current_time

def _update_freq(key, capacity):
    state = algo_state

    # Aging (Slower aging: 10x capacity to retain history longer)
    state['aging_counter'] += 1
    if state['aging_counter'] >= capacity * 10:
        state['aging_counter'] = 0
        # Halve frequencies
        rem = []
        for k, v in state['freq'].items():
            nv = v // 2
            if nv == 0: rem.append(k)
            else: state['freq'][k] = nv
        for k in rem: del state['freq'][k]

    # Doorkeeper Management (Larger size: 5x capacity)
    if len(state['doorkeeper']) > capacity * 5:
        state['doorkeeper'].clear()

    # Update
    if key in state['freq']:
        state['freq'][key] = min(state['freq'][key] + 1, 31) # Max freq 31
    elif key in state['doorkeeper']:
        state['doorkeeper'].remove(key)
        state['freq'][key] = 2
    else:
        state['doorkeeper'].add(key)

def _get_freq(key):
    if key in algo_state['freq']:
        return algo_state['freq'][key]
    if key in algo_state['doorkeeper']:
        return 1
    return 0

def evict(cache_snapshot, obj):
    _reset_state(cache_snapshot.access_count)
    state = algo_state
    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.01))

    # Candidates
    cand_w_key = next(iter(state['window'])) if state['window'] else None

    cand_m_key = None
    is_probation = False
    if state['probation']:
        cand_m_key = next(iter(state['probation']))
        is_probation = True
    elif state['protected']:
        cand_m_key = next(iter(state['protected']))

    # Fail-safe
    if cand_w_key is None and cand_m_key is None: return None
    if cand_w_key is None: return cand_m_key
    if cand_m_key is None: return cand_w_key

    fw = _get_freq(cand_w_key)
    fm = _get_freq(cand_m_key)

    # 1. Window Growing Logic
    if state['window_size'] < w_cap:
        # If Main victim is valuable (fm > fw), sacrifice Window instead.
        if fm > fw:
            return cand_w_key
        return cand_m_key

    # 2. Window Full - Duel
    # Segment-aware eviction policy
    if is_probation:
        # Probation: Prefer replacing weak items with new candidates.
        # If frequencies are equal, bias towards eviction of Probation (Main).
        if fw >= fm:
            return cand_m_key
        return cand_w_key
    else:
        # Protected: Strong bias to keep Protected items.
        # Evict Window unless Window is significantly better.
        if fw > fm + 1:
            return cand_m_key
        return cand_w_key

def update_after_hit(cache_snapshot, obj):
    _reset_state(cache_snapshot.access_count)
    state = algo_state
    key = obj.key
    capacity = cache_snapshot.capacity

    _update_freq(key, capacity)

    # Position Update
    if key in state['window']:
        state['window'].move_to_end(key)
    elif key in state['protected']:
        state['protected'].move_to_end(key)
    elif key in state['probation']:
        # Promote Probation -> Protected
        val = state['probation'].pop(key)
        state['protected'][key] = val
        state['protected_size'] += val

        # Enforce Protected Limit (80% of Main)
        limit = int(capacity * 0.8)
        while state['protected_size'] > limit and state['protected']:
            k, v = state['protected'].popitem(last=False)
            state['protected_size'] -= v
            state['probation'][k] = v
            state['probation'].move_to_end(k)

def update_after_insert(cache_snapshot, obj):
    _reset_state(cache_snapshot.access_count)
    state = algo_state
    key = obj.key
    size = obj.size
    capacity = cache_snapshot.capacity

    _update_freq(key, capacity)

    # Insert to Window
    state['window'][key] = size
    state['window_size'] += size

    # Check Window Overflow -> Move to Probation
    w_cap = max(1, int(capacity * 0.01))
    while state['window_size'] > w_cap and state['window']:
        k, s = state['window'].popitem(last=False)
        state['window_size'] -= s

        state['probation'][k] = s
        state['probation'].move_to_end(k)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    state = algo_state
    key = evicted_obj.key
    size = evicted_obj.size

    if key in state['window']:
        del state['window'][key]
        state['window_size'] -= size
    elif key in state['probation']:
        del state['probation'][key]
    elif key in state['protected']:
        val = state['protected'].pop(key)
        state['protected_size'] -= val
>>>>>>> REPLACE
</DIFF>