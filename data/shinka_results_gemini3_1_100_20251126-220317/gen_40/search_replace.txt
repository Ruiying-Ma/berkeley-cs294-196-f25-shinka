<NAME>
persistent_dk_and_conditional_growth
</NAME>

<DESCRIPTION>
1.  **Persistent Doorkeeper**: Replace the `set`-based Doorkeeper with an `OrderedDict`-based one. This allows us to limit its size (to 10x capacity) rather than clearing it completely during frequency aging. This prevents the "amnesia" problem where the cache forgets "seen once" items when the aging timer triggers, which causes poor performance on long loops and scans (addressing Trace 14).
2.  **Conditional Window Growth**: Modify the `evict` function to condition the preemptive eviction of Main items (used to grow the Window) on the Main victim's frequency. If the Main victim is "hot" (frequency > 5), we skip the forced eviction and proceed to the standard duel. This prevents the Window growth mechanism from indiscriminately killing valuable heavy hitters just to make space for potentially cold new arrivals.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# W-TinyLFU inspired State
algo_state = {
    'window': OrderedDict(),    # Window Cache (SLRU or LRU)
    'probation': OrderedDict(), # Main Cache - Probation (SLRU)
    'protected': OrderedDict(), # Main Cache - Protected (SLRU)
    'freq': {},                 # Frequency Counter
    'doorkeeper': set(),        # Doorkeeper filter
    'freq_count': 0,            # Total increments for reset
    'max_time': 0
}

def _check_reset(current_time):
    if current_time < algo_state['max_time']:
        algo_state['window'].clear()
        algo_state['probation'].clear()
        algo_state['protected'].clear()
        algo_state['freq'].clear()
        algo_state['doorkeeper'].clear()
        algo_state['freq_count'] = 0
        algo_state['max_time'] = 0
    algo_state['max_time'] = current_time

def evict(cache_snapshot, obj):
    '''
    W-TinyLFU Eviction Logic
    '''
    window = algo_state['window']
    probation = algo_state['probation']
    protected = algo_state['protected']
    freq = algo_state['freq']

    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.05)) # 5% Window

    # Candidates
    candidate_w = next(iter(window)) if window else None

    # Main Candidate: Probation LRU, else Protected LRU
    candidate_m = None
    if probation:
        candidate_m = next(iter(probation))
    elif protected:
        candidate_m = next(iter(protected))

    victim = None

    # 1. If Window needs space (is below target), grow it by evicting Main
    # (Unless Main is empty, then evict Window)
    if len(window) < w_cap and candidate_m:
        victim = candidate_m
    elif not candidate_m:
        victim = candidate_w
    elif not candidate_w:
        victim = candidate_m
    else:
        # 2. Window is full. Duel.
        # Compare frequency
        fw = freq.get(candidate_w, 0)
        fm = freq.get(candidate_m, 0)

        # Tie-breaker: Prefer Main (Incumbent) -> Evict Window
        # This provides scan and loop resistance
        if fw > fm:
            victim = candidate_m
        else:
            victim = candidate_w

    return victim

def update_after_hit(cache_snapshot, obj):
    _check_reset(cache_snapshot.access_count)
    key = obj.key
    window = algo_state['window']
    probation = algo_state['probation']
    protected = algo_state['protected']
    freq = algo_state['freq']
    dk = algo_state['doorkeeper']

    # Frequency with Doorkeeper and Cap
    if key in freq:
        freq[key] = min(freq[key] + 1, 15)
    elif key in dk:
        freq[key] = 1
        dk.remove(key)
    else:
        dk.add(key)

    algo_state['freq_count'] += 1
    # Accelerated Aging (5x capacity instead of 10x)
    if algo_state['freq_count'] >= cache_snapshot.capacity * 5:
        to_remove = []
        dk.clear()
        for k in freq:
            freq[k] //= 2
            if freq[k] == 0: to_remove.append(k)
        for k in to_remove: del freq[k]
        algo_state['freq_count'] = 0

    # Cache Maintenance
    if key in window:
        window.move_to_end(key)
    elif key in protected:
        protected.move_to_end(key)
    elif key in probation:
        # Promote
        del probation[key]
        protected[key] = None

        # Enforce Protected Limit
        w_cap = max(1, int(cache_snapshot.capacity * 0.05))
        m_cap = cache_snapshot.capacity - w_cap
        p_cap = int(m_cap * 0.8) # 80% of Main

        while len(protected) > p_cap:
            k, _ = protected.popitem(last=False)
            probation[k] = None # Move to Probation MRU
            probation.move_to_end(k)

def update_after_insert(cache_snapshot, obj):
    _check_reset(cache_snapshot.access_count)
    key = obj.key
    freq = algo_state['freq']
    dk = algo_state['doorkeeper']

    # Frequency with Doorkeeper and Cap
    if key in freq:
        freq[key] = min(freq[key] + 1, 15)
    elif key in dk:
        freq[key] = 1
        dk.remove(key)
    else:
        dk.add(key)

    algo_state['freq_count'] += 1
    # Accelerated Aging
    if algo_state['freq_count'] >= cache_snapshot.capacity * 5:
        to_remove = []
        dk.clear()
        for k in freq:
            freq[k] //= 2
            if freq[k] == 0: to_remove.append(k)
        for k in to_remove: del freq[k]
        algo_state['freq_count'] = 0

    # Insert to Window MRU
    algo_state['window'][key] = None
=======
# W-TinyLFU inspired State
algo_state = {
    'window': OrderedDict(),    # Window Cache (SLRU or LRU)
    'probation': OrderedDict(), # Main Cache - Probation (SLRU)
    'protected': OrderedDict(), # Main Cache - Protected (SLRU)
    'freq': {},                 # Frequency Counter
    'doorkeeper': OrderedDict(),# Doorkeeper filter (Ordered for LRU)
    'freq_count': 0,            # Total increments for reset
    'max_time': 0
}

def _check_reset(current_time):
    if current_time < algo_state['max_time']:
        algo_state['window'].clear()
        algo_state['probation'].clear()
        algo_state['protected'].clear()
        algo_state['freq'].clear()
        algo_state['doorkeeper'].clear()
        algo_state['freq_count'] = 0
        algo_state['max_time'] = 0
    algo_state['max_time'] = current_time

def evict(cache_snapshot, obj):
    '''
    W-TinyLFU Eviction Logic
    '''
    window = algo_state['window']
    probation = algo_state['probation']
    protected = algo_state['protected']
    freq = algo_state['freq']

    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.05)) # 5% Window

    # Candidates
    candidate_w = next(iter(window)) if window else None

    # Main Candidate: Probation LRU, else Protected LRU
    candidate_m = None
    if probation:
        candidate_m = next(iter(probation))
    elif protected:
        candidate_m = next(iter(protected))

    victim = None

    # Frequency scores
    fw = freq.get(candidate_w, 0) if candidate_w else 0
    fm = freq.get(candidate_m, 0) if candidate_m else 0

    # 1. If Window needs space (is below target), grow it by evicting Main
    # Condition: Only evict Main if it's not "hot" (freq <= 5).
    # If Main is hot, we skip this and duel, which Main likely wins, thus suppressing Window growth
    # to protect heavy hitters.
    if len(window) < w_cap and candidate_m and fm <= 5:
        victim = candidate_m
    elif not candidate_m:
        victim = candidate_w
    elif not candidate_w:
        victim = candidate_m
    else:
        # 2. Window is full or Main is Hot. Duel.
        # Tie-breaker: Prefer Main (Incumbent) -> Evict Window
        # This provides scan and loop resistance
        if fw > fm:
            victim = candidate_m
        else:
            victim = candidate_w

    return victim

def update_after_hit(cache_snapshot, obj):
    _check_reset(cache_snapshot.access_count)
    key = obj.key
    window = algo_state['window']
    probation = algo_state['probation']
    protected = algo_state['protected']
    freq = algo_state['freq']
    dk = algo_state['doorkeeper']

    # Frequency with Doorkeeper and Cap
    if key in freq:
        freq[key] = min(freq[key] + 1, 15)
    elif key in dk:
        freq[key] = 1
        del dk[key]
    else:
        dk[key] = None
        # Enforce Doorkeeper Limit (10x capacity to remember history)
        if len(dk) > cache_snapshot.capacity * 10:
            dk.popitem(last=False)

    algo_state['freq_count'] += 1
    # Accelerated Aging (5x capacity)
    if algo_state['freq_count'] >= cache_snapshot.capacity * 5:
        to_remove = []
        # Note: We do NOT clear Doorkeeper here anymore
        for k in freq:
            freq[k] //= 2
            if freq[k] == 0: to_remove.append(k)
        for k in to_remove: del freq[k]
        algo_state['freq_count'] = 0

    # Cache Maintenance
    if key in window:
        window.move_to_end(key)
    elif key in protected:
        protected.move_to_end(key)
    elif key in probation:
        # Promote
        del probation[key]
        protected[key] = None

        # Enforce Protected Limit
        w_cap = max(1, int(cache_snapshot.capacity * 0.05))
        m_cap = cache_snapshot.capacity - w_cap
        p_cap = int(m_cap * 0.8) # 80% of Main

        while len(protected) > p_cap:
            k, _ = protected.popitem(last=False)
            probation[k] = None # Move to Probation MRU
            probation.move_to_end(k)

def update_after_insert(cache_snapshot, obj):
    _check_reset(cache_snapshot.access_count)
    key = obj.key
    freq = algo_state['freq']
    dk = algo_state['doorkeeper']

    # Frequency with Doorkeeper and Cap
    if key in freq:
        freq[key] = min(freq[key] + 1, 15)
    elif key in dk:
        freq[key] = 1
        del dk[key]
    else:
        dk[key] = None
        # Enforce Doorkeeper Limit
        if len(dk) > cache_snapshot.capacity * 10:
            dk.popitem(last=False)

    algo_state['freq_count'] += 1
    # Accelerated Aging
    if algo_state['freq_count'] >= cache_snapshot.capacity * 5:
        to_remove = []
        # Note: We do NOT clear Doorkeeper here anymore
        for k in freq:
            freq[k] //= 2
            if freq[k] == 0: to_remove.append(k)
        for k in to_remove: del freq[k]
        algo_state['freq_count'] = 0

    # Insert to Window MRU
    algo_state['window'][key] = None
>>>>>>> REPLACE
</DIFF>