# EVOLVE-BLOCK-START
"""
W-TinyLFU with Adaptive Bias and Refined Aging
Maintains 1% Window and SLRU Main (Probation + Protected).
Uses Doorkeeper (approximate counting) and Frequency Sketch.
Key Improvements:
- 5x Capacity Aging: Faster adaptation to workload changes.
- Adaptive Eviction Bias: Neutral comparison for weak Main items, biased for established ones.
- Strict Window Growing: Prioritizes Window growth unless Main victim is strictly better.
- Doorkeeper Reset: Clears based on size to prevent saturation.
"""
from collections import OrderedDict

# Global State
algo_state = {
    'window': OrderedDict(),    # key -> size
    'window_size': 0,
    'probation': OrderedDict(), # key -> size
    'protected': OrderedDict(), # key -> size
    'protected_size': 0,
    'freq': {},                 # key -> count
    'doorkeeper': set(),        # keys seen once
    'access_count': 0,          # For aging
    'last_trace_access': -1
}

def _check_trace_reset(snapshot_access_count):
    if snapshot_access_count < algo_state['last_trace_access']:
        algo_state['window'].clear()
        algo_state['window_size'] = 0
        algo_state['probation'].clear()
        algo_state['protected'].clear()
        algo_state['protected_size'] = 0
        algo_state['freq'].clear()
        algo_state['doorkeeper'].clear()
        algo_state['access_count'] = 0
    algo_state['last_trace_access'] = snapshot_access_count

def evict(cache_snapshot, obj):
    _check_trace_reset(cache_snapshot.access_count)
    
    window = algo_state['window']
    probation = algo_state['probation']
    protected = algo_state['protected']
    freq = algo_state['freq']
    dk = algo_state['doorkeeper']
    
    capacity = cache_snapshot.capacity
    w_cap = max(1, int(capacity * 0.01))
    
    def get_freq(k):
        if k in freq: return freq[k]
        if k in dk: return 1
        return 0

    # Candidates
    cand_w_key = next(iter(window)) if window else None
    cand_m_key = None
    if probation:
        cand_m_key = next(iter(probation))
    elif protected:
        cand_m_key = next(iter(protected))
        
    # Fail-safe
    if not cand_w_key and not cand_m_key: return None
    if not cand_w_key: return cand_m_key
    if not cand_m_key: return cand_w_key

    fw = get_freq(cand_w_key)
    fm = get_freq(cand_m_key)

    # 1. Window Growing Phase
    if algo_state['window_size'] < w_cap:
        # If Main victim is strictly better, spare it.
        if fm > fw:
            return cand_w_key
        return cand_m_key

    # 2. Steady State - Adaptive Bias
    # If Main candidate is weak (<=1, likely a one-hit wonder leaker), evict it if Window is better.
    # If Main candidate is established (>1), protect it with bias.
    if fm <= 1:
        if fw > fm:
            return cand_m_key
        else:
            return cand_w_key
    else:
        # Main is established, use bias to reduce churn
        if fw > fm + 1:
            return cand_m_key
        else:
            return cand_w_key

def update_after_hit(cache_snapshot, obj):
    _check_trace_reset(cache_snapshot.access_count)
    key = obj.key
    algo_state['access_count'] += 1
    
    # Frequency Update
    f = algo_state['freq']
    dk = algo_state['doorkeeper']
    
    if key in f:
        f[key] = min(f[key] + 1, 15)
    elif key in dk:
        dk.remove(key)
        f[key] = 2
    else:
        dk.add(key)
        
    # Aging (5x Capacity)
    if algo_state['access_count'] >= cache_snapshot.capacity * 5:
        algo_state['access_count'] = 0
        to_rem = []
        for k in f:
            f[k] //= 2
            if f[k] == 0: to_rem.append(k)
        for k in to_rem: del f[k]
        dk.clear()

    # Doorkeeper Safety Reset (Size based)
    if len(dk) > cache_snapshot.capacity * 2:
        dk.clear()

    # Position Updates
    if key in algo_state['window']:
        algo_state['window'].move_to_end(key)
    elif key in algo_state['protected']:
        algo_state['protected'].move_to_end(key)
    elif key in algo_state['probation']:
        # Promote to Protected
        val = algo_state['probation'].pop(key)
        algo_state['protected'][key] = val
        algo_state['protected_size'] += val
        
        # Enforce Protected Limit (80% of Main)
        # Main ~ Capacity - Window (approx Capacity)
        limit = int(cache_snapshot.capacity * 0.8)
        while algo_state['protected_size'] > limit and algo_state['protected']:
            k, v = algo_state['protected'].popitem(last=False) # LRU
            algo_state['protected_size'] -= v
            algo_state['probation'][k] = v
            algo_state['probation'].move_to_end(k) # MRU

def update_after_insert(cache_snapshot, obj):
    _check_trace_reset(cache_snapshot.access_count)
    key = obj.key
    size = obj.size
    algo_state['access_count'] += 1
    
    # Frequency Update
    f = algo_state['freq']
    dk = algo_state['doorkeeper']
    
    if key in f:
        f[key] = min(f[key] + 1, 15)
    elif key in dk:
        dk.remove(key)
        f[key] = 2
    else:
        dk.add(key)
        
    # Aging (5x)
    if algo_state['access_count'] >= cache_snapshot.capacity * 5:
        algo_state['access_count'] = 0
        to_rem = []
        for k in f:
            f[k] //= 2
            if f[k] == 0: to_rem.append(k)
        for k in to_rem: del f[k]
        dk.clear()

    if len(dk) > cache_snapshot.capacity * 2:
        dk.clear()

    # Insert into Window
    algo_state['window'][key] = size
    algo_state['window_size'] += size
    
    # Handle Overflow -> Move to Probation
    w_cap = max(1, int(cache_snapshot.capacity * 0.01))
    while algo_state['window_size'] > w_cap and algo_state['window']:
        k, s = algo_state['window'].popitem(last=False)
        algo_state['window_size'] -= s
        algo_state['probation'][k] = s
        algo_state['probation'].move_to_end(k) # MRU

def update_after_evict(cache_snapshot, obj, evicted_obj):
    key = evicted_obj.key
    size = evicted_obj.size
    
    if key in algo_state['window']:
        del algo_state['window'][key]
        algo_state['window_size'] -= size
    elif key in algo_state['probation']:
        del algo_state['probation'][key]
    elif key in algo_state['protected']:
        val = algo_state['protected'].pop(key)
        algo_state['protected_size'] -= val
# EVOLVE-BLOCK-END