<NAME>
slru_balanced_promotion_qtrim
</NAME>

<DESCRIPTION>
The current S3Q variant aggressively promotes items to the protected segment (Q) on any hit and seldom evicts from Q, causing Q to hoard stale items and degrade adaptation on shifting workloads. It also prioritizes evicting from probation (P) instead of the window (W), which weakens scan resistance, and it inserts too many items into W by default.

This edit makes four targeted improvements:

1) Eviction balancing and Q trimming:
   - Prefer evicting from W when non-empty, especially when |W| > target or when the request hits Gq (ghost of Q), to improve scan resistance.
   - Add a soft capacity for Q and proactively evict the Q-LRU when Q exceeds this soft target. This prevents Q from hoarding stale entries and accelerates recovery when the working set shifts.
   - Keep ghost biases: Gp hit favors Q eviction; Gq hit favors W/P eviction.

2) Promotion discipline (SLRU-style):
   - On hit in W → promote to P (not directly to Q).
   - On hit in P → promote to Q.
   - On hit in Q → refresh only. This avoids over-aggressive protection after a single hit while still promoting genuinely repeating items.

3) Admission tuning:
   - Default insert brand-new items into P; only use W as a scan guard during sustained cold streaks. This reduces pollution of Q due to quick first-hit promotions and better conforms to SLRU semantics.

4) Housekeeping:
   - Drop the frequency counter for evicted keys to avoid stale frequency bias and reduce memory footprint.

These changes collectively reduce misses on scans and shifting workloads while keeping frequent items protected. They preserve ghost-driven window adaptation and TinyLFU frequency guidance for Q victim selection when appropriate.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    """
    Choose the eviction victim.
    Policy:
    - If window exceeds target, evict from W (FIFO-like via LRU on timestamp).
    - Otherwise default SLRU: evict from probation P if non-empty; else W; else Q.
    - Ghost bias: if obj in Gq, favor evicting from recency side (W then P).
                 if obj in Gp, favor evicting from Q.
    Within any segment, choose by lowest frequency then LRU.
    """
    _ensure_init(cache_snapshot)
    cap = _cap(cache_snapshot)
    _clamp_window_target(cap)
    w_keys, p_keys, q_keys = _segment_keys(cache_snapshot)

    # Keep ghosts disjoint from current residents
    for k in cache_snapshot.cache.keys():
        m_ghost_b1_ts.pop(k, None)
        m_ghost_b2_ts.pop(k, None)

    # If window is oversized vs target, shed from W first
    if len(w_keys) > max(1, m_target_p):
        victim = _choose_victim(w_keys) or _choose_victim(p_keys) or _choose_victim(q_keys)
        return victim

    in_gp = obj.key in m_ghost_b1_ts
    in_gq = obj.key in m_ghost_b2_ts

    # Ghost-biased replacement choice
    if in_gq:
        # Favor evicting from recency side first
        victim = _choose_victim(w_keys) or _choose_victim(p_keys) or _choose_victim(q_keys)
        if victim is not None:
            return victim
    elif in_gp:
        # Favor evicting from protected if present
        victim = _choose_victim(q_keys) or _choose_victim(p_keys) or _choose_victim(w_keys)
        if victim is not None:
            return victim

    # Default SLRU: evict from probation if possible
    victim = _choose_victim(p_keys)
    if victim is not None:
        return victim

    # Then from W, else Q
    victim = _choose_victim(w_keys) or _choose_victim(q_keys)
    return victim
=======
def evict(cache_snapshot, obj):
    """
    Choose the eviction victim.
    Policy:
    - Maintain balance: prefer evicting from W if non-empty (fast recency filter).
      If |W| exceeds target or obj ∈ Gq, shed W first.
      If Q is bloated beyond a soft target, take one from Q (LRU) to refresh it.
    - Otherwise default SLRU: evict from P if non-empty; else W; else Q.
    - Ghost bias: if obj in Gq, favor evicting from recency side (W then P).
                 if obj in Gp, favor evicting from Q.
    Within any segment, use LRU for W/P and freq+LRU for Q.
    """
    _ensure_init(cache_snapshot)
    cap = _cap(cache_snapshot)
    _clamp_window_target(cap)
    w_keys, p_keys, q_keys = _segment_keys(cache_snapshot)

    # Keep ghosts disjoint from current residents
    for k in cache_snapshot.cache.keys():
        m_ghost_b1_ts.pop(k, None)
        m_ghost_b2_ts.pop(k, None)

    in_gp = obj.key in m_ghost_b1_ts
    in_gq = obj.key in m_ghost_b2_ts

    # Soft cap for protected segment to avoid hoarding stale items
    p_min = max(1, cap // 8)
    q_soft_max = max(1, cap - max(1, m_target_p) - p_min)

    # If window is oversized or ghost suggests recency pressure, evict from W
    if w_keys and (len(w_keys) > max(1, m_target_p) or in_gq):
        victim = _lru_key(w_keys)
        if victim is not None:
            return victim

    # Trim Q if it exceeds its soft target
    if q_keys and (len(q_keys) > q_soft_max):
        # Prefer LRU in Q to flush stale protected
        victim = _lru_key(q_keys)
        if victim is not None:
            return victim

    # Ghost-biased choice
    if in_gp and q_keys:
        victim = _choose_victim(q_keys)
        if victim is not None:
            return victim
    if in_gq:
        # Favor recency side
        victim = _lru_key(w_keys) or _lru_key(p_keys)
        if victim is not None:
            return victim

    # Default order: W -> P -> Q
    victim = _lru_key(w_keys)
    if victim is not None:
        return victim
    victim = _lru_key(p_keys)
    if victim is not None:
        return victim
    victim = _choose_victim(q_keys)
    return victim
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    """
    On hit:
    - Refresh timestamp and bump frequency.
    - Move from W or P to Q (promotion).
    - Light idle drift: if no ghost hits for ~cap accesses, nudge window toward baseline.
    - Keep ghosts disjoint.
    """
    global m_cold_streak, m_target_p, m_last_ghost_hit_access
    _ensure_init(cache_snapshot)
    _maybe_decay_freq(cache_snapshot)

    now = cache_snapshot.access_count
    cap = _cap(cache_snapshot)
    base_w = max(1, cap // 5)

    # Reset cold streak and update stats
    m_cold_streak = 0
    m_key_timestamp[obj.key] = now
    _bump_freq(obj.key, 2)

    # Promotion to protected
    seg = m_key_segment.get(obj.key, 'p')
    if seg in ('w', 'p'):
        m_key_segment[obj.key] = 'q'

    # Idle drift for window target (slowly home toward baseline without ghost signals)
    if now - m_last_ghost_hit_access > cap:
        if m_target_p > base_w:
            m_target_p -= 1
        elif m_target_p < base_w:
            m_target_p += 1
        _clamp_window_target(cap)

    # Keep ghosts disjoint
    m_ghost_b1_ts.pop(obj.key, None)
    m_ghost_b2_ts.pop(obj.key, None)
=======
def update_after_hit(cache_snapshot, obj):
    """
    On hit:
    - Refresh timestamp and bump frequency.
    - SLRU promotions:
        * W -> P (first hit graduates to probation)
        * P -> Q (second hit graduates to protected)
        * Q -> Q (refresh)
    - Light idle drift: if no ghost hits for ~cap accesses, nudge window toward baseline.
    - Keep ghosts disjoint.
    """
    global m_cold_streak, m_target_p, m_last_ghost_hit_access
    _ensure_init(cache_snapshot)
    _maybe_decay_freq(cache_snapshot)

    now = cache_snapshot.access_count
    cap = _cap(cache_snapshot)
    base_w = max(1, cap // 5)

    # Reset cold streak and update stats
    m_cold_streak = 0
    m_key_timestamp[obj.key] = now

    seg = m_key_segment.get(obj.key, 'p')
    # Promotion discipline
    if seg == 'w':
        m_key_segment[obj.key] = 'p'
        _bump_freq(obj.key, 2)
    elif seg == 'p':
        m_key_segment[obj.key] = 'q'
        _bump_freq(obj.key, 2)
    else:
        # seg == 'q' or unknown default
        m_key_segment[obj.key] = 'q'
        _bump_freq(obj.key, 1)

    # Idle drift for window target (slowly home toward baseline without ghost signals)
    if now - m_last_ghost_hit_access > cap:
        if m_target_p > base_w:
            m_target_p -= 1
        elif m_target_p < base_w:
            m_target_p += 1
        _clamp_window_target(cap)

    # Keep ghosts disjoint
    m_ghost_b1_ts.pop(obj.key, None)
    m_ghost_b2_ts.pop(obj.key, None)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    """
    On insert (miss path):
    - Adapt window size via ghost hits:
        * If key ∈ Gp: increase window target (recency needs more room).
        * If key ∈ Gq: decrease window target (protect frequency).
      Use ceiling ratios and asymmetric caps; stronger decrease during cold streaks.
    - Scan-guard insertion: during sustained cold streaks, insert into probation P
      instead of window W.
    - On ghost hits, promote to Q immediately.
    """
    global m_target_p, m_last_ghost_hit_access, m_last_ghost_hit_side, m_cold_streak
    _ensure_init(cache_snapshot)
    _maybe_decay_freq(cache_snapshot)

    cap = _cap(cache_snapshot)
    _clamp_window_target(cap)

    in_gp = obj.key in m_ghost_b1_ts
    in_gq = obj.key in m_ghost_b2_ts

    inc_cap = max(1, cap // 8)
    dec_cap = max(1, (cap // 4) if m_cold_streak >= max(1, cap // 2) else (cap // 8))

    seg = 'w'  # default insertion into window

    if in_gp:
        # Enlarge window (recency pressure)
        denom = max(1, len(m_ghost_b1_ts))
        numer = len(m_ghost_b2_ts)
        raw_inc = max(1, (numer + denom - 1) // denom)  # ceil(|Gq|/|Gp|)
        m_target_p = min(cap, m_target_p + min(inc_cap, raw_inc))
        _clamp_window_target(cap)
        seg = 'q'  # strong signal ⇒ direct protect
        # Ghost bookkeeping
        m_ghost_b1_ts.pop(obj.key, None)
        m_ghost_b2_ts.pop(obj.key, None)
        m_last_ghost_hit_access = cache_snapshot.access_count
        m_last_ghost_hit_side = 'Gp'
        m_cold_streak = 0
        _bump_freq(obj.key, 3)
    elif in_gq:
        # Shrink window (favor frequency)
        denom = max(1, len(m_ghost_b2_ts))
        numer = len(m_ghost_b1_ts)
        raw_dec = max(1, (numer + denom - 1) // denom)  # ceil(|Gp|/|Gq|)
        m_target_p = max(0, m_target_p - min(dec_cap, raw_dec))
        _clamp_window_target(cap)
        seg = 'q'  # strong signal ⇒ direct protect
        # Ghost bookkeeping
        m_ghost_b2_ts.pop(obj.key, None)
        m_ghost_b1_ts.pop(obj.key, None)
        m_last_ghost_hit_access = cache_snapshot.access_count
        m_last_ghost_hit_side = 'Gq'
        m_cold_streak = 0
        _bump_freq(obj.key, 4)
    else:
        # Cold miss: scan guard and gentle clamp
        m_cold_streak += 1
        # During sustained cold streaks, divert brand-new keys to probation
        if m_cold_streak >= max(1, cap // 2):
            seg = 'p'
        else:
            seg = 'w'
        # Gentle clamp to reduce window if streak persists
        if m_cold_streak % max(1, cap // 2) == 0:
            m_target_p = max(0, m_target_p - max(1, cap // 16))
            _clamp_window_target(cap)
        _bump_freq(obj.key, 1)

    # Install resident metadata
    m_key_segment[obj.key] = seg
    m_key_timestamp[obj.key] = cache_snapshot.access_count

    # Ensure ghosts remain disjoint
    m_ghost_b1_ts.pop(obj.key, None)
    m_ghost_b2_ts.pop(obj.key, None)

    # Control ghost history size
    _prune_ghosts(cache_snapshot)
=======
def update_after_insert(cache_snapshot, obj):
    """
    On insert (miss path):
    - Adapt window size via ghost hits:
        * If key ∈ Gp: increase window target (recency needs more room).
        * If key ∈ Gq: decrease window target (protect frequency).
      Use ceiling ratios and asymmetric caps; stronger decrease during cold streaks.
    - Scan-guard insertion: default to probation P; during sustained cold streaks,
      route to window W for quick shedding.
    - On ghost hits, promote to Q immediately.
    """
    global m_target_p, m_last_ghost_hit_access, m_last_ghost_hit_side, m_cold_streak
    _ensure_init(cache_snapshot)
    _maybe_decay_freq(cache_snapshot)

    cap = _cap(cache_snapshot)
    _clamp_window_target(cap)

    in_gp = obj.key in m_ghost_b1_ts
    in_gq = obj.key in m_ghost_b2_ts

    inc_cap = max(1, cap // 8)
    dec_cap = max(1, (cap // 4) if m_cold_streak >= max(1, cap // 2) else (cap // 8))

    # Default insertion is into probation; W is used as a scan guard only
    seg = 'p'

    if in_gp:
        # Enlarge window (recency pressure)
        denom = max(1, len(m_ghost_b1_ts))
        numer = len(m_ghost_b2_ts)
        raw_inc = max(1, (numer + denom - 1) // denom)  # ceil(|Gq|/|Gp|)
        m_target_p = min(cap, m_target_p + min(inc_cap, raw_inc))
        _clamp_window_target(cap)
        seg = 'q'  # strong signal ⇒ direct protect
        # Ghost bookkeeping
        m_ghost_b1_ts.pop(obj.key, None)
        m_ghost_b2_ts.pop(obj.key, None)
        m_last_ghost_hit_access = cache_snapshot.access_count
        m_last_ghost_hit_side = 'Gp'
        m_cold_streak = 0
        _bump_freq(obj.key, 3)
    elif in_gq:
        # Shrink window (favor frequency)
        denom = max(1, len(m_ghost_b2_ts))
        numer = len(m_ghost_b1_ts)
        raw_dec = max(1, (numer + denom - 1) // denom)  # ceil(|Gp|/|Gq|)
        m_target_p = max(0, m_target_p - min(dec_cap, raw_dec))
        _clamp_window_target(cap)
        seg = 'q'  # strong signal ⇒ direct protect
        # Ghost bookkeeping
        m_ghost_b2_ts.pop(obj.key, None)
        m_ghost_b1_ts.pop(obj.key, None)
        m_last_ghost_hit_access = cache_snapshot.access_count
        m_last_ghost_hit_side = 'Gq'
        m_cold_streak = 0
        _bump_freq(obj.key, 4)
    else:
        # Cold miss: scan guard and gentle clamp
        m_cold_streak += 1
        # During sustained cold streaks, divert brand-new keys to window for quick eviction
        if m_cold_streak >= max(1, cap // 3):
            seg = 'w'
        # Gentle clamp to reduce window if streak persists
        if m_cold_streak % max(1, cap // 2) == 0:
            m_target_p = max(0, m_target_p - max(1, cap // 16))
            _clamp_window_target(cap)
        _bump_freq(obj.key, 1)

    # Install resident metadata
    m_key_segment[obj.key] = seg
    m_key_timestamp[obj.key] = cache_snapshot.access_count

    # Ensure ghosts remain disjoint
    m_ghost_b1_ts.pop(obj.key, None)
    m_ghost_b2_ts.pop(obj.key, None)

    # Control ghost history size
    _prune_ghosts(cache_snapshot)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_evict(cache_snapshot, obj, evicted_obj):
    """
    After eviction, move evicted resident to appropriate ghost:
    - If evicted from Q → Gq
    - Else (from W or P) → Gp
    """
    _ensure_init(cache_snapshot)

    seg = m_key_segment.pop(evicted_obj.key, 'p')
    m_key_timestamp.pop(evicted_obj.key, None)

    ts = cache_snapshot.access_count
    if seg == 'q':
        m_ghost_b2_ts[evicted_obj.key] = ts  # Gq
        m_ghost_b1_ts.pop(evicted_obj.key, None)
    else:
        m_ghost_b1_ts[evicted_obj.key] = ts  # Gp
        m_ghost_b2_ts.pop(evicted_obj.key, None)

    _prune_ghosts(cache_snapshot)
=======
def update_after_evict(cache_snapshot, obj, evicted_obj):
    """
    After eviction, move evicted resident to appropriate ghost:
    - If evicted from Q → Gq
    - Else (from W or P) → Gp
    """
    _ensure_init(cache_snapshot)

    seg = m_key_segment.pop(evicted_obj.key, 'p')
    m_key_timestamp.pop(evicted_obj.key, None)

    ts = cache_snapshot.access_count
    if seg == 'q':
        m_ghost_b2_ts[evicted_obj.key] = ts  # Gq
        m_ghost_b1_ts.pop(evicted_obj.key, None)
    else:
        m_ghost_b1_ts[evicted_obj.key] = ts  # Gp
        m_ghost_b2_ts.pop(evicted_obj.key, None)

    # Drop frequency accounting for evicted keys to avoid stale bias and memory growth
    m_freq.pop(evicted_obj.key, None)

    _prune_ghosts(cache_snapshot)
>>>>>>> REPLACE
</DIFF>