# EVOLVE-BLOCK-START
"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""

from collections import OrderedDict

# LRU timestamp map used as a tie-breaker and fallback
m_key_timestamp = dict()

# Adaptive Replacement Cache (ARC) metadata
arc_T1 = OrderedDict()  # recent, resident
arc_T2 = OrderedDict()  # frequent, resident
arc_B1 = OrderedDict()  # ghost of T1
arc_B2 = OrderedDict()  # ghost of T2
arc_p = 0               # target size of T1
arc_capacity = None     # will be initialized from cache_snapshot

# Adaptation and phase tracking
arc_last_ghost_hit_access = 0   # last access_count when a ghost hit occurred
arc_last_ghost_hit_side = None  # 'B1' or 'B2'
arc_last_decay_access = 0       # throttle decay operations (kept for safety)
cold_streak = 0                 # consecutive brand-new admissions without ghost/hit signal

# Short-term trimming bias window
arc_current_access = 0
arc_ghost_bias_until = 0  # access_count until which trimming bias applies


def _ceil_div(a, b):
    b = max(1, b)
    return (a + b - 1) // b


def _pending_window():
    cap = arc_capacity if arc_capacity is not None else 1
    return max(1, cap // 4)


def _ensure_capacity(cache_snapshot):
    global arc_capacity
    if arc_capacity is None:
        arc_capacity = max(int(cache_snapshot.capacity), 1)


def _move_to_mru(od, key):
    # Push key to MRU position of an OrderedDict
    if key in od:
        od.pop(key, None)
    od[key] = True


def _insert_at_lru(od, key):
    # Insert key at LRU position (probationary)
    if key in od:
        od.pop(key, None)
    od[key] = True
    try:
        od.move_to_end(key, last=False)
    except Exception:
        # Fallback: rebuild by rotating (rarely needed)
        items = list(od.items())
        od.clear()
        od[key] = True
        for k, v in items:
            if k != key:
                od[k] = v


def _pop_lru(od):
    if od:
        k, _ = od.popitem(last=False)
        return k
    return None


def _demote_t2_to_t1(count):
    # Move up to 'count' least-recent T2 items into T1 at LRU
    moved = 0
    while moved < count:
        k = _pop_lru(arc_T2)
        if k is None:
            break
        _insert_at_lru(arc_T1, k)
        moved += 1


def _trim_ghosts():
    # Keep ghosts total size within 2x capacity with proportional trimming to p
    cap_base = (arc_capacity if arc_capacity is not None else 1)
    total_cap = cap_base * 2
    target_B1 = min(total_cap, max(0, int(round(total_cap * (float(arc_p) / max(1.0, float(cap_base)))))))
    target_B2 = max(0, total_cap - target_B1)

    # Apply short-term bias to preserve the most recent ghost-hit signal
    bias_active = (arc_current_access <= arc_ghost_bias_until)

    while (len(arc_B1) + len(arc_B2)) > total_cap:
        if bias_active and arc_last_ghost_hit_side == 'B1' and len(arc_B2) > 0:
            # Preserve B1 signal; trim opposite side first
            _pop_lru(arc_B2)
            continue
        if bias_active and arc_last_ghost_hit_side == 'B2' and len(arc_B1) > 0:
            # Preserve B2 signal; trim opposite side first
            _pop_lru(arc_B1)
            continue

        # Proportional trimming if a side exceeds its target
        if len(arc_B1) > target_B1:
            _pop_lru(arc_B1)
        elif len(arc_B2) > target_B2:
            _pop_lru(arc_B2)
        else:
            # If neither is over its proportional target, drop from the larger one
            if len(arc_B1) >= len(arc_B2):
                _pop_lru(arc_B1)
            else:
                _pop_lru(arc_B2)


# Decay controller: if no ghost hits for a while, bias toward recency (smaller p),
# with faster recovery during long idle (e.g., scans).
def _decay_arc_p_if_idle(now):
    global arc_p, arc_last_decay_access
    if arc_capacity is None:
        return
    idle = now - arc_last_ghost_hit_access
    if idle >= arc_capacity:
        step_cap = max(1, arc_capacity // 8)
        dec = min(step_cap, max(1, idle // max(1, arc_capacity)))
        if arc_p > 0:
            arc_p = max(0, arc_p - dec)
        arc_last_decay_access = now


def _resync(cache_snapshot):
    # Ensure resident metadata tracks actual cache content
    cache_keys = set(cache_snapshot.cache.keys())
    for k in list(arc_T1.keys()):
        if k not in cache_keys:
            arc_T1.pop(k, None)
    for k in list(arc_T2.keys()):
        if k not in cache_keys:
            arc_T2.pop(k, None)
    # Ghost-aware seeding for any cached keys we missed
    for k in cache_keys:
        if k not in arc_T1 and k not in arc_T2:
            if k in arc_B2:
                _move_to_mru(arc_T2, k)
                arc_B2.pop(k, None)
            elif k in arc_B1:
                _move_to_mru(arc_T1, k)
                arc_B1.pop(k, None)
            else:
                _move_to_mru(arc_T1, k)
    # Remove any ghost entries that collide with residents (keep disjointness)
    for k in list(arc_B1.keys()):
        if k in arc_T1 or k in arc_T2:
            arc_B1.pop(k, None)
    for k in list(arc_B2.keys()):
        if k in arc_T1 or k in arc_T2:
            arc_B2.pop(k, None)
    _trim_ghosts()


def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    _ensure_capacity(cache_snapshot)
    _resync(cache_snapshot)
    _decay_arc_p_if_idle(cache_snapshot.access_count)

    # ARC replacement: choose between T1 and T2 depending on p and whether obj is in B2
    x_in_B2 = obj.key in arc_B2
    t1_sz = len(arc_T1)
    victim = None
    if t1_sz >= 1 and (t1_sz > arc_p or (x_in_B2 and t1_sz == arc_p)):
        # Evict LRU from T1
        victim = next(iter(arc_T1)) if arc_T1 else None
    else:
        # Evict LRU from T2
        victim = next(iter(arc_T2)) if arc_T2 else None

    # Strict ARC fallback: use the other list if the chosen one is empty
    if victim is None:
        if t1_sz > 0:
            victim = next(iter(arc_T1))
        elif len(arc_T2) > 0:
            victim = next(iter(arc_T2))
        else:
            # Rare drift: resync once and retry; then ghost-informed fallback
            _resync(cache_snapshot)
            if arc_T1:
                victim = next(iter(arc_T1))
            elif arc_T2:
                victim = next(iter(arc_T2))
            else:
                # Ghost-informed deterministic fallback
                # Prefer evicting a key present in B1; avoid keys hinted by B2
                for k in cache_snapshot.cache.keys():
                    if k in arc_B1:
                        return k
                for k in cache_snapshot.cache.keys():
                    if k not in arc_B2:
                        return k
                # Final fallback: first key iteration
                if cache_snapshot.cache:
                    victim = next(iter(cache_snapshot.cache.keys()))
    return victim


def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global m_key_timestamp, cold_streak, arc_current_access
    _ensure_capacity(cache_snapshot)
    now = cache_snapshot.access_count
    arc_current_access = now
    _decay_arc_p_if_idle(now)
    # Any hit breaks cold streaks
    cold_streak = 0

    # Keep resident metadata consistent with actual cache
    if (len(arc_T1) + len(arc_T2)) != len(cache_snapshot.cache):
        _resync(cache_snapshot)

    key = obj.key
    if key in arc_T1:
        # Canonical ARC: on a hit in T1, move to T2 (become frequent)
        arc_T1.pop(key, None)
        _move_to_mru(arc_T2, key)
    elif key in arc_T2:
        # Refresh recency within T2
        _move_to_mru(arc_T2, key)
    else:
        # Metadata drift: protect a hit by placing into T2 (has demonstrated reuse)
        _move_to_mru(arc_T2, key)

    # Maintain disjointness: resident keys must not appear in ghosts
    arc_B1.pop(key, None)
    arc_B2.pop(key, None)

    _trim_ghosts()
    # Update timestamp for tie-breaking/fallback
    m_key_timestamp[key] = now


def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global m_key_timestamp, arc_p, arc_last_ghost_hit_access, cold_streak
    global arc_last_ghost_hit_side, arc_current_access, arc_ghost_bias_until
    _ensure_capacity(cache_snapshot)
    now = cache_snapshot.access_count
    arc_current_access = now
    _decay_arc_p_if_idle(now)
    key = obj.key

    # Keep resident metadata consistent with actual cache
    if (len(arc_T1) + len(arc_T2)) != len(cache_snapshot.cache):
        _resync(cache_snapshot)

    C = (arc_capacity if arc_capacity is not None else 1)
    inc_cap = max(1, C // 8)
    dec_cap = max(1, C // 4) if cold_streak >= (C // 2) else max(1, C // 8)

    # ARC admission policy with bounded, responsive, asymmetric p-updates
    if key in arc_B1:
        # Previously evicted from T1: favor recency by increasing p
        ratio = _ceil_div(len(arc_B2), max(1, len(arc_B1)))
        inc = min(ratio, inc_cap, max(0, C - arc_p))
        arc_p = min(C, arc_p + inc)
        arc_B1.pop(key, None)
        arc_B2.pop(key, None)  # keep ghosts disjoint
        _move_to_mru(arc_T2, key)
        arc_last_ghost_hit_access = now
        arc_last_ghost_hit_side = 'B1'
        arc_ghost_bias_until = now + max(1, C // 8)
        cold_streak = 0
    elif key in arc_B2:
        # Previously frequent: favor frequency by decreasing p (more aggressively under cold streaks)
        ratio = _ceil_div(len(arc_B1), max(1, len(arc_B2)))
        dec = min(ratio, dec_cap, max(0, arc_p))
        arc_p = max(0, arc_p - dec)
        arc_B2.pop(key, None)
        arc_B1.pop(key, None)  # keep ghosts disjoint
        _move_to_mru(arc_T2, key)
        arc_last_ghost_hit_access = now
        arc_last_ghost_hit_side = 'B2'
        arc_ghost_bias_until = now + max(1, C // 8)
        cold_streak = 0
    else:
        # Brand new: insert into T1; under scans, insert at LRU and demote a few T2 LRUs
        cold_streak += 1
        if cold_streak >= (C // 2):
            # Scan-aware probationary insertion and demotion
            _insert_at_lru(arc_T1, key)
            _demote_t2_to_t1(min(2, max(1, C // 16)))
        else:
            _move_to_mru(arc_T1, key)

        # Streaming-aware clamp: during long runs of brand-new keys, bias toward recency progressively
        if C is not None and cold_streak >= C:
            dec = max(1, C // 8)
            arc_p = max(0, arc_p - dec)
            # Prevent unbounded growth of the streak counter to keep adaptation responsive
            if cold_streak >= 2 * C:
                arc_p = max(0, arc_p - dec)
                cold_streak = C

        # Ensure ghosts are disjoint from residents
        arc_B1.pop(key, None)
        arc_B2.pop(key, None)

    _trim_ghosts()
    m_key_timestamp[key] = now


def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global m_key_timestamp
    _ensure_capacity(cache_snapshot)
    k = evicted_obj.key
    # Move evicted resident to corresponding ghost list, keeping ghosts disjoint
    if k in arc_T1:
        arc_T1.pop(k, None)
        _move_to_mru(arc_B1, k)
        arc_B2.pop(k, None)
    elif k in arc_T2:
        arc_T2.pop(k, None)
        _move_to_mru(arc_B2, k)
        arc_B1.pop(k, None)
    else:
        # Unknown membership: prefer B2 if it already exists there, otherwise B1
        if k in arc_B2:
            _move_to_mru(arc_B2, k)
            arc_B1.pop(k, None)
        else:
            _move_to_mru(arc_B1, k)
            arc_B2.pop(k, None)
    # Clean up metadata for evicted item
    m_key_timestamp.pop(k, None)
    _trim_ghosts()

# EVOLVE-BLOCK-END