<NAME>
extended_ghost_and_decay
</NAME>

<DESCRIPTION>
This edit introduces three key improvements to the S3-FIFO-P algorithm to improve hit rates, especially for looping traces and scan resistance:
1.  **Extended Ghost Queue**: Increases the ghost queue capacity to 4x the cache capacity. This allows the algorithm to detect and capture loop patterns that are larger than the cache but within a reasonable working set size (e.g., Trace 14).
2.  **Tenancy Bonus**: When an item is promoted from the ghost queue to the main queue, it is assigned an initial frequency of 2 (instead of 0). This gives "resurrected" items a buffer against immediate eviction or demotion, allowing them to establish their utility in the protected queue.
3.  **Frequency Decay**: Modifies the reinsertion logic in the Main queue to use linear decay (`freq - 1`) instead of resetting to 0. This preserves frequency history for popular items, making the Main queue more robust.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# Constants
_SMALL_RATIO = 0.1

def _check_reset(snapshot):
    global _s3_small, _s3_main, _s3_ghost, _s3_freq, _last_ts
    if snapshot.access_count < _last_ts:
        _s3_small.clear()
        _s3_main.clear()
        _s3_ghost.clear()
        _s3_freq.clear()
    _last_ts = snapshot.access_count

def evict(cache_snapshot, obj):
    '''
    S3-FIFO with Demotion strategy.
    - Small (Probation): FIFO. Hits promote to Main. Cold evicts to Ghost.
    - Main (Protected): FIFO. Hits reinsert. Cold DEMOTES to Small.
    '''
    global _s3_small, _s3_main, _s3_ghost, _s3_freq
    _check_reset(cache_snapshot)

    capacity = cache_snapshot.capacity
    s_target = max(1, int(capacity * _SMALL_RATIO))

    while True:
        # 1. Prefer evicting from Small if it exceeds target OR Main is empty
        if len(_s3_small) > s_target or not _s3_main:
            if not _s3_small:
                # Fallback if both empty (should imply cache empty)
                if cache_snapshot.cache:
                    return next(iter(cache_snapshot.cache))
                return None

            candidate, _ = _s3_small.popitem(last=False) # FIFO head

            # Sync check
            if candidate not in cache_snapshot.cache:
                _s3_freq.pop(candidate, None)
                continue

            freq = _s3_freq.get(candidate, 0)
            if freq > 0:
                # Promotion: Small -> Main
                _s3_main[candidate] = None
                _s3_freq[candidate] = 0
                continue
            else:
                # Eviction: Small -> Ghost -> Out
                _s3_ghost[candidate] = None
                if len(_s3_ghost) > capacity:
                    _s3_ghost.popitem(last=False)
                _s3_freq.pop(candidate, None)
                return candidate

        # 2. Process Main
        else:
            if not _s3_main:
                 continue

            candidate, _ = _s3_main.popitem(last=False)

            if candidate not in cache_snapshot.cache:
                _s3_freq.pop(candidate, None)
                continue

            freq = _s3_freq.get(candidate, 0)
            if freq > 0:
                # Reinsertion: Main -> Main (Second Chance)
                _s3_main[candidate] = None
                _s3_freq[candidate] = 0
                continue
            else:
                # Demotion: Main -> Small
                # Give it one last chance in probation
                _s3_small[candidate] = None
                _s3_freq[candidate] = 0
                continue
=======
# Constants
_SMALL_RATIO = 0.1
_GHOST_RATIO = 4.0

def _check_reset(snapshot):
    global _s3_small, _s3_main, _s3_ghost, _s3_freq, _last_ts
    if snapshot.access_count < _last_ts:
        _s3_small.clear()
        _s3_main.clear()
        _s3_ghost.clear()
        _s3_freq.clear()
    _last_ts = snapshot.access_count

def evict(cache_snapshot, obj):
    '''
    S3-FIFO with Demotion strategy and Extended Ghost.
    - Small (Probation): FIFO. Hits promote to Main. Cold evicts to Ghost.
    - Main (Protected): FIFO. Hits reinsert with Decay. Cold DEMOTES to Small.
    '''
    global _s3_small, _s3_main, _s3_ghost, _s3_freq
    _check_reset(cache_snapshot)

    capacity = cache_snapshot.capacity
    s_target = max(1, int(capacity * _SMALL_RATIO))
    ghost_capacity = int(capacity * _GHOST_RATIO)

    while True:
        # 1. Prefer evicting from Small if it exceeds target OR Main is empty
        if len(_s3_small) > s_target or not _s3_main:
            if not _s3_small:
                # Fallback if both empty (should imply cache empty)
                if cache_snapshot.cache:
                    return next(iter(cache_snapshot.cache))
                return None

            candidate, _ = _s3_small.popitem(last=False) # FIFO head

            # Sync check
            if candidate not in cache_snapshot.cache:
                _s3_freq.pop(candidate, None)
                continue

            freq = _s3_freq.get(candidate, 0)
            if freq > 0:
                # Promotion: Small -> Main
                _s3_main[candidate] = None
                _s3_freq[candidate] = 0
                continue
            else:
                # Eviction: Small -> Ghost -> Out
                _s3_ghost[candidate] = None
                while len(_s3_ghost) > ghost_capacity:
                    _s3_ghost.popitem(last=False)
                _s3_freq.pop(candidate, None)
                return candidate

        # 2. Process Main
        else:
            if not _s3_main:
                 continue

            candidate, _ = _s3_main.popitem(last=False)

            if candidate not in cache_snapshot.cache:
                _s3_freq.pop(candidate, None)
                continue

            freq = _s3_freq.get(candidate, 0)
            if freq > 0:
                # Reinsertion: Main -> Main (Decay)
                _s3_main[candidate] = None
                # Linear decay: freq - 1
                _s3_freq[candidate] = freq - 1
                continue
            else:
                # Demotion: Main -> Small
                # Give it one last chance in probation
                _s3_small[candidate] = None
                _s3_freq[candidate] = 0
                continue
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    global _s3_small, _s3_main, _s3_ghost, _s3_freq
    _check_reset(cache_snapshot)

    key = obj.key
    # Ghost check for quick promotion
    if key in _s3_ghost:
        if key not in _s3_main and key not in _s3_small:
            _s3_main[key] = None
            _s3_freq[key] = 0
        del _s3_ghost[key]
    else:
        # Standard insert to Small
        if key not in _s3_small and key not in _s3_main:
            _s3_small[key] = None
            _s3_freq[key] = 0
=======
def update_after_insert(cache_snapshot, obj):
    global _s3_small, _s3_main, _s3_ghost, _s3_freq
    _check_reset(cache_snapshot)

    key = obj.key
    # Ghost check for quick promotion
    if key in _s3_ghost:
        if key not in _s3_main and key not in _s3_small:
            _s3_main[key] = None
            # Grant tenancy bonus: start with frequency 2 to prevent immediate demotion
            _s3_freq[key] = 2
        del _s3_ghost[key]
    else:
        # Standard insert to Small
        if key not in _s3_small and key not in _s3_main:
            _s3_small[key] = None
            _s3_freq[key] = 0
>>>>>>> REPLACE
</DIFF>