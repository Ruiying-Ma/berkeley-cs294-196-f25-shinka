<NAME>
improved_s3fifo_ghost
</NAME>

<DESCRIPTION>
This update improves the S3-FIFO implementation with three key changes:
1.  **Capacity-Gated Conditional Demotion**: In `evict`, when a victim is selected from the Main (M) queue and is not accessed, it is now demoted to the Small (S) queue *only if* S is within its target capacity. If S is full, the item is evicted directly and added to the Ghost registry. This prevents cold items from polluting the probationary S queue during scan workloads, addressing the 0% hit rate on Trace 14.
2.  **Extended Ghost History**: The Ghost registry capacity is increased from 2x to 4x the cache capacity. This allows the algorithm to detect and capture larger loops that exceed the previous history window, improving performance on loop-heavy traces.
3.  **Tenancy Bonus**: In `update_after_insert`, when an item is promoted from Ghost to Main, it is marked as accessed immediately. This gives it a "second chance" (one full cycle in M) before being eligible for demotion, recognizing that ghost hits indicate high value.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    '''
    Selects a victim using S3-FIFO policy.
    Iterates through S and M queues to find a candidate without an active access bit.
    Promotes/Re-inserts items with access bits.
    '''
    # Target size for the small queue (10% of capacity)
    s_capacity = max(int(cache_snapshot.capacity * 0.1), 1)

    while True:
        # Check S queue first if it exceeds capacity or if M is empty
        if len(s_queue) > s_capacity or (len(s_queue) > 0 and len(m_queue) == 0):
            candidate_key, _ = s_queue.popitem(last=False) # Pop from head (FIFO)

            if candidate_key in accessed_bits:
                # Second chance: Move to M
                accessed_bits.discard(candidate_key)
                m_queue[candidate_key] = None
            else:
                # Victim found in S
                # Add to ghost registry
                ghost_registry[candidate_key] = None
                # Cap ghost size to 2x cache capacity for better history coverage
                if len(ghost_registry) > cache_snapshot.capacity * 2:
                    ghost_registry.popitem(last=False)
                return candidate_key

        else:
            # Check M queue
            if not m_queue:
                # Should not be reached if cache is not empty
                # Fallback to S if M is empty
                if s_queue:
                        k, _ = s_queue.popitem(last=False)
                        return k
                # Extreme fallback
                return next(iter(cache_snapshot.cache))

            candidate_key, _ = m_queue.popitem(last=False) # Pop from head

            if candidate_key in accessed_bits:
                # Second chance: Re-insert at tail of M
                accessed_bits.discard(candidate_key)
                m_queue[candidate_key] = None
            else:
                # Victim found in M
                # Demote to S queue (tail) to give one final chance
                s_queue[candidate_key] = None
                # We haven't found a victim yet, so continue the loop
                continue
=======
def evict(cache_snapshot, obj):
    '''
    Selects a victim using S3-FIFO policy.
    Iterates through S and M queues to find a candidate without an active access bit.
    Promotes/Re-inserts items with access bits.
    '''
    # Target size for the small queue (10% of capacity)
    s_capacity = max(int(cache_snapshot.capacity * 0.1), 1)
    # Ghost registry limit (4x capacity for better long loop detection)
    ghost_limit = cache_snapshot.capacity * 4

    while True:
        # Check S queue first if it exceeds capacity or if M is empty
        if len(s_queue) > s_capacity or (len(s_queue) > 0 and len(m_queue) == 0):
            candidate_key, _ = s_queue.popitem(last=False) # Pop from head (FIFO)

            if candidate_key in accessed_bits:
                # Second chance: Move to M
                accessed_bits.discard(candidate_key)
                m_queue[candidate_key] = None
            else:
                # Victim found in S
                # Add to ghost registry
                ghost_registry[candidate_key] = None
                if len(ghost_registry) > ghost_limit:
                    ghost_registry.popitem(last=False)
                return candidate_key

        else:
            # Check M queue
            if not m_queue:
                # Should not be reached if cache is not empty
                # Fallback to S if M is empty
                if s_queue:
                        k, _ = s_queue.popitem(last=False)
                        return k
                # Extreme fallback
                return next(iter(cache_snapshot.cache))

            candidate_key, _ = m_queue.popitem(last=False) # Pop from head

            if candidate_key in accessed_bits:
                # Second chance: Re-insert at tail of M
                accessed_bits.discard(candidate_key)
                m_queue[candidate_key] = None
            else:
                # Victim found in M
                # Conditional Demotion: Only demote to S if S has space
                if len(s_queue) < s_capacity:
                    s_queue[candidate_key] = None
                    # Continue loop to find another victim
                    continue
                else:
                    # S is full, evict M-victim directly
                    # Record in ghost to capture it if it returns (helps with larger loops/scans)
                    ghost_registry[candidate_key] = None
                    if len(ghost_registry) > ghost_limit:
                        ghost_registry.popitem(last=False)
                    return candidate_key
>>>>>>> REPLACE
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    '''
    Insert new object into S or M based on ghost history.
    '''
    if obj.key in ghost_registry:
        # Promote directly to Main queue
        m_queue[obj.key] = None
        del ghost_registry[obj.key]
    else:
        # Insert into Small queue
        s_queue[obj.key] = None

    # Reset access bit on insert (usually assumed 0 freq initially)
    accessed_bits.discard(obj.key)
=======
def update_after_insert(cache_snapshot, obj):
    '''
    Insert new object into S or M based on ghost history.
    '''
    if obj.key in ghost_registry:
        # Promote directly to Main queue
        m_queue[obj.key] = None
        del ghost_registry[obj.key]
        # Tenancy Bonus: Mark as accessed so it survives at least one eviction cycle in M
        accessed_bits.add(obj.key)
    else:
        # Insert into Small queue
        s_queue[obj.key] = None
        # Reset access bit on insert
        accessed_bits.discard(obj.key)
>>>>>>> REPLACE
</DIFF>