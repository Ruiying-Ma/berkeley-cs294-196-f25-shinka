<NAME>
implement_s3_fifo
</NAME>

<DESCRIPTION>
Replaces the ARC implementation with an S3-FIFO eviction algorithm.
S3-FIFO uses three queues: Small (S), Main (M), and Ghost (G).
New items enter S. Items evicted from S with access history promote to M; otherwise they go to G.
Items evicted from M with access history are reinserted to M.
Ghost hits promote directly to M.
This setup typically captures frequency and recency better than ARC for web-like traces (heavy tail).
We set S capacity to 10% of cache size and Ghost capacity to 300% to capture longer history.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from collections import OrderedDict

# ARC Algorithm Implementation
# Global state for ARC (T1, T2, B1, B2, p)
# T1: Recent (LRU), T2: Frequent (LRU), B1: Ghost Recent, B2: Ghost Frequent
arc_t1 = OrderedDict()
arc_t2 = OrderedDict()
arc_b1 = OrderedDict()
arc_b2 = OrderedDict()
arc_p = 0
arc_last_access_count = -1

def _check_reset(cache_snapshot):
    """
    Detects if a new trace has started or if state needs reset.
    """
    global arc_t1, arc_t2, arc_b1, arc_b2, arc_p, arc_last_access_count
    current_acc = cache_snapshot.access_count

    # If access count dropped, it's a new trace
    if current_acc < arc_last_access_count:
        arc_t1.clear()
        arc_t2.clear()
        arc_b1.clear()
        arc_b2.clear()
        arc_p = 0

    # Safety reset if cache is empty but we have state (e.g. initial run)
    if len(cache_snapshot.cache) == 0 and (len(arc_t1) > 0 or len(arc_t2) > 0):
        arc_t1.clear()
        arc_t2.clear()
        arc_b1.clear()
        arc_b2.clear()
        arc_p = 0

    arc_last_access_count = current_acc

def evict(cache_snapshot, obj):
    '''
    Selects the eviction victim using ARC logic (Adaptive Replacement Cache).
    '''
    _check_reset(cache_snapshot)
    global arc_p

    key = obj.key
    c = cache_snapshot.capacity

    # 1. Adapt p (target size for T1) if we have a ghost hit
    if key in arc_b1:
        delta = 1
        if len(arc_b1) >= len(arc_b2):
            delta = 1
        else:
            delta = len(arc_b2) / len(arc_b1)
        arc_p = min(float(c), arc_p + delta)
    elif key in arc_b2:
        delta = 1
        if len(arc_b2) >= len(arc_b1):
            delta = 1
        else:
            delta = len(arc_b1) / len(arc_b2)
        arc_p = max(0.0, arc_p - delta)

    # 2. Determine victim using ARC's REPLACE logic
    victim_key = None
    t1_len = len(arc_t1)
    replace_p = arc_p

    evict_from_t1 = False
    if t1_len > 0:
        if t1_len > replace_p:
            evict_from_t1 = True
        elif (key in arc_b2) and (t1_len == int(replace_p)):
            evict_from_t1 = True

    if evict_from_t1:
        victim_key = next(iter(arc_t1))
    else:
        if len(arc_t2) > 0:
            victim_key = next(iter(arc_t2))
        else:
            # Fallback: if T2 is empty but we decided to evict from it (rare), evict T1
            if len(arc_t1) > 0:
                victim_key = next(iter(arc_t1))

    # Safety fallback: ensure victim is actually in the cache snapshot
    if victim_key is None or victim_key not in cache_snapshot.cache:
        # Just pick LRU from the actual cache as a failsafe
        if cache_snapshot.cache:
            victim_key = next(iter(cache_snapshot.cache))

    return victim_key

def update_after_hit(cache_snapshot, obj):
    '''
    Updates ARC state on cache hit.
    '''
    _check_reset(cache_snapshot)
    key = obj.key

    # Move to T2 MRU
    if key in arc_t1:
        del arc_t1[key]
        arc_t2[key] = None
    elif key in arc_t2:
        arc_t2.move_to_end(key)
    else:
        # If strictly following logic, it should be in one. If not, add to T2.
        arc_t2[key] = None

    # Remove from ghosts if present
    if key in arc_b1: del arc_b1[key]
    if key in arc_b2: del arc_b2[key]

def update_after_insert(cache_snapshot, obj):
    '''
    Updates ARC state after insertion (miss).
    '''
    _check_reset(cache_snapshot)
    key = obj.key

    # Check ghost hits to determine placement
    if key in arc_b1:
        del arc_b1[key]
        arc_t2[key] = None # Promote to T2
    elif key in arc_b2:
        del arc_b2[key]
        arc_t2[key] = None # Promote to T2
    else:
        # New object -> T1
        arc_t1[key] = None

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    Updates ARC state after eviction (move to ghosts).
    '''
    _check_reset(cache_snapshot)
    key = evicted_obj.key
    c = cache_snapshot.capacity

    # Move evicted key to corresponding ghost list
    if key in arc_t1:
        del arc_t1[key]
        arc_b1[key] = None
        # Bound B1 size (heuristic: keep up to c)
        if len(arc_b1) > c:
            arc_b1.popitem(last=False) # remove LRU

    elif key in arc_t2:
        del arc_t2[key]
        arc_b2[key] = None
        # Bound B2 size (heuristic: keep up to 2c)
        if len(arc_b2) > 2*c:
            arc_b2.popitem(last=False) # remove LRU
=======
from collections import deque

# S3-FIFO Algorithm Implementation
# S: Small Queue, M: Main Queue, G: Ghost Registry
s3_s = deque()
s3_m = deque()
s3_g = set()
s3_g_fifo = deque()
s3_access = {}
s3_last_access_count = -1

def _check_reset(cache_snapshot):
    global s3_s, s3_m, s3_g, s3_g_fifo, s3_access, s3_last_access_count
    if cache_snapshot.access_count < s3_last_access_count:
        s3_s.clear()
        s3_m.clear()
        s3_g.clear()
        s3_g_fifo.clear()
        s3_access.clear()

    if len(cache_snapshot.cache) == 0 and (len(s3_s) > 0 or len(s3_m) > 0):
        s3_s.clear()
        s3_m.clear()
        s3_g.clear()
        s3_g_fifo.clear()
        s3_access.clear()

    s3_last_access_count = cache_snapshot.access_count

def evict(cache_snapshot, obj):
    '''
    S3-FIFO eviction logic.
    '''
    _check_reset(cache_snapshot)

    c = cache_snapshot.capacity
    s_cap = max(1, int(c * 0.1))

    victim = None

    # Iterate until a victim is found
    while victim is None:
        scan_s = False
        # If S is full or M is empty, scan S
        if len(s3_s) > s_cap or len(s3_m) == 0:
            scan_s = True

        if scan_s:
            if not s3_s:
                # Fallback if S is empty but we thought we should scan it
                if s3_m: scan_s = False
                else: break

            if scan_s:
                cand = s3_s.popleft()
                if s3_access.get(cand, False):
                    # Second chance: promote to M
                    s3_access[cand] = False
                    s3_m.append(cand)
                else:
                    # Evict from S -> Ghost
                    victim = cand
                    if victim not in s3_g:
                        s3_g.add(victim)
                        s3_g_fifo.append(victim)
                        # Limit ghost size to 3x capacity
                        while len(s3_g) > 3 * c:
                            rem = s3_g_fifo.popleft()
                            if rem in s3_g: s3_g.remove(rem)
        else:
            # Scan M
            cand = s3_m.popleft()
            if s3_access.get(cand, False):
                # Second chance: reinsert to M
                s3_access[cand] = False
                s3_m.append(cand)
            else:
                # Evict from M -> Discard (no ghost for M eviction in vanilla S3-FIFO)
                victim = cand

    if victim is None:
        # Failsafe
        if cache_snapshot.cache:
            victim = next(iter(cache_snapshot.cache))

    return victim

def update_after_hit(cache_snapshot, obj):
    '''
    Update access bit on hit.
    '''
    _check_reset(cache_snapshot)
    s3_access[obj.key] = True

def update_after_insert(cache_snapshot, obj):
    '''
    Handle insertion (miss).
    '''
    _check_reset(cache_snapshot)
    key = obj.key

    if key in s3_g:
        # Ghost hit: Promote to M
        s3_m.append(key)
        s3_access[key] = True
        s3_g.remove(key)
        # Note: key remains in s3_g_fifo but ignored on pop
    else:
        # Standard insert to S
        s3_s.append(key)
        s3_access[key] = False

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    Cleanup after eviction.
    '''
    _check_reset(cache_snapshot)
    key = evicted_obj.key
    if key in s3_access:
        del s3_access[key]
>>>>>>> REPLACE
</DIFF>