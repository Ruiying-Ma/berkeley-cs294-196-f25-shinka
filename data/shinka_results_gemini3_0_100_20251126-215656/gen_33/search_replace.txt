<NAME>
s3_fifo_demotion
</NAME>

<DESCRIPTION>
Replaces the ARC implementation with an advanced S3-FIFO algorithm.
This new algorithm maintains three queues: Small (FIFO), Main (LRU), and Ghost (FIFO).
New items enter Small. When Small is full (target 10%), items are evicted from Small. If the item was accessed while in Small, it is promoted to Main (Second Chance).
When Main needs eviction (Small is within budget), items are evicted from Main. Crucially, if a Main item has been accessed recently, it is not discarded but demoted back to the Small queue (Probation). This conditional demotion keeps valuable items in the cache longer while allowing cold items to be flushed.
A Ghost queue tracks evicted items to facilitate quick promotion to Main upon re-access, recovering from false negatives in eviction.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from collections import OrderedDict

# ARC Algorithm Implementation
# Global state for ARC (T1, T2, B1, B2, p)
# T1: Recent (LRU), T2: Frequent (LRU), B1: Ghost Recent, B2: Ghost Frequent
arc_t1 = OrderedDict()
arc_t2 = OrderedDict()
arc_b1 = OrderedDict()
arc_b2 = OrderedDict()
arc_p = 0
arc_last_access_count = -1

def _check_reset(cache_snapshot):
    """
    Detects if a new trace has started or if state needs reset.
    """
    global arc_t1, arc_t2, arc_b1, arc_b2, arc_p, arc_last_access_count
    current_acc = cache_snapshot.access_count

    # If access count dropped, it's a new trace
    if current_acc < arc_last_access_count:
        arc_t1.clear()
        arc_t2.clear()
        arc_b1.clear()
        arc_b2.clear()
        arc_p = 0

    # Safety reset if cache is empty but we have state (e.g. initial run)
    if len(cache_snapshot.cache) == 0 and (len(arc_t1) > 0 or len(arc_t2) > 0):
        arc_t1.clear()
        arc_t2.clear()
        arc_b1.clear()
        arc_b2.clear()
        arc_p = 0

    arc_last_access_count = current_acc

def evict(cache_snapshot, obj):
    '''
    Selects the eviction victim using ARC logic (Adaptive Replacement Cache).
    '''
    _check_reset(cache_snapshot)
    global arc_p

    key = obj.key
    c = cache_snapshot.capacity

    # 1. Adapt p (target size for T1) if we have a ghost hit
    if key in arc_b1:
        delta = 1
        if len(arc_b1) >= len(arc_b2):
            delta = 1
        else:
            delta = len(arc_b2) / len(arc_b1)
        arc_p = min(float(c), arc_p + delta)
    elif key in arc_b2:
        delta = 1
        if len(arc_b2) >= len(arc_b1):
            delta = 1
        else:
            delta = len(arc_b1) / len(arc_b2)
        arc_p = max(0.0, arc_p - delta)

    # 2. Determine victim using ARC's REPLACE logic
    victim_key = None
    t1_len = len(arc_t1)
    replace_p = arc_p

    evict_from_t1 = False
    if t1_len > 0:
        if t1_len > replace_p:
            evict_from_t1 = True
        elif (key in arc_b2) and (t1_len == int(replace_p)):
            evict_from_t1 = True

    if evict_from_t1:
        victim_key = next(iter(arc_t1))
    else:
        if len(arc_t2) > 0:
            victim_key = next(iter(arc_t2))
        else:
            # Fallback: if T2 is empty but we decided to evict from it (rare), evict T1
            if len(arc_t1) > 0:
                victim_key = next(iter(arc_t1))

    # Safety fallback: ensure victim is actually in the cache snapshot
    if victim_key is None or victim_key not in cache_snapshot.cache:
        # Just pick LRU from the actual cache as a failsafe
        if cache_snapshot.cache:
            victim_key = next(iter(cache_snapshot.cache))

    return victim_key

def update_after_hit(cache_snapshot, obj):
    '''
    Updates ARC state on cache hit.
    '''
    _check_reset(cache_snapshot)
    key = obj.key

    # Move to T2 MRU
    if key in arc_t1:
        del arc_t1[key]
        arc_t2[key] = None
    elif key in arc_t2:
        arc_t2.move_to_end(key)
    else:
        # If strictly following logic, it should be in one. If not, add to T2.
        arc_t2[key] = None

    # Remove from ghosts if present
    if key in arc_b1: del arc_b1[key]
    if key in arc_b2: del arc_b2[key]

def update_after_insert(cache_snapshot, obj):
    '''
    Updates ARC state after insertion (miss).
    '''
    _check_reset(cache_snapshot)
    key = obj.key

    # Check ghost hits to determine placement
    if key in arc_b1:
        del arc_b1[key]
        arc_t2[key] = None # Promote to T2
    elif key in arc_b2:
        del arc_b2[key]
        arc_t2[key] = None # Promote to T2
    else:
        # New object -> T1
        arc_t1[key] = None

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    Updates ARC state after eviction (move to ghosts).
    '''
    _check_reset(cache_snapshot)
    key = evicted_obj.key
    c = cache_snapshot.capacity

    # Move evicted key to corresponding ghost list
    if key in arc_t1:
        del arc_t1[key]
        arc_b1[key] = None
        # Bound B1 size (heuristic: keep up to c)
        if len(arc_b1) > c:
            arc_b1.popitem(last=False) # remove LRU

    elif key in arc_t2:
        del arc_t2[key]
        arc_b2[key] = None
        # Bound B2 size (heuristic: keep up to 2c)
        if len(arc_b2) > 2*c:
            arc_b2.popitem(last=False) # remove LRU
=======
from collections import OrderedDict

# Advanced S3-FIFO Algorithm
# Implements S3-FIFO with demotion (soft eviction from Main) and ghost queues.
# q_small: FIFO queue for new items (Probation).
# q_main: LRU queue for popular items (Protected).
# q_ghost: FIFO queue for history of evicted items.
# meta_freq: Dictionary tracking access counts for items in cache.

q_small = OrderedDict()
q_main = OrderedDict()
q_ghost = OrderedDict()
meta_freq = {}
last_access_count = -1

def _reset_if_needed(snapshot):
    """Resets state if a new trace is detected."""
    global q_small, q_main, q_ghost, meta_freq, last_access_count
    if snapshot.access_count < last_access_count:
        q_small.clear()
        q_main.clear()
        q_ghost.clear()
        meta_freq.clear()

    # Safety reset if cache is physically empty but we have state
    if not snapshot.cache and (q_small or q_main):
        q_small.clear()
        q_main.clear()
        q_ghost.clear()
        meta_freq.clear()

    last_access_count = snapshot.access_count

def evict(cache_snapshot, obj):
    '''
    Selects a victim using S3-FIFO logic with Main-to-Small demotion.
    '''
    global q_small, q_main, q_ghost, meta_freq
    _reset_if_needed(cache_snapshot)

    capacity = cache_snapshot.capacity
    # Target size for small queue (10% of capacity)
    target_small = max(1, int(capacity * 0.1))

    # We loop to find a victim, processing promotions/demotions along the way.
    # Safety limit to prevent infinite loops (though logic should guarantee termination).
    loop_limit = len(cache_snapshot.cache) * 2
    ops = 0

    while ops < loop_limit:
        ops += 1

        # Decide which queue to evict from
        # If Small is over budget or Main is empty, we must evict from Small.
        # Otherwise, we evict from Main.
        evict_from_small = False
        if len(q_small) > target_small or len(q_main) == 0:
            evict_from_small = True

        if evict_from_small:
            if not q_small:
                # Should only happen if Main is empty too (cache empty?)
                if q_main:
                    # Fallback to Main
                    candidate, _ = q_main.popitem(last=False)
                    q_ghost[candidate] = None
                    meta_freq.pop(candidate, None)
                    return candidate
                # Absolute fallback
                return next(iter(cache_snapshot.cache))

            # FIFO eviction from Small
            candidate, _ = q_small.popitem(last=False)

            # Check for promotion: if accessed while in Small
            freq = meta_freq.get(candidate, 0)
            if freq > 0:
                # Promote to Main
                q_main[candidate] = None
                meta_freq[candidate] = 0 # Reset frequency cost
                continue # Retry eviction
            else:
                # Evict candidate
                q_ghost[candidate] = None
                if len(q_ghost) > capacity:
                    q_ghost.popitem(last=False)
                meta_freq.pop(candidate, None)
                return candidate

        else:
            # Evict from Main (LRU)
            candidate, _ = q_main.popitem(last=False)

            # Check for demotion: if accessed while in Main (freq > 0)
            # This gives "warm" items a second chance in Small
            freq = meta_freq.get(candidate, 0)
            if freq > 0:
                # Demote to Small
                q_small[candidate] = None
                meta_freq[candidate] = 0 # Reset frequency
                continue # Retry eviction
            else:
                # Evict candidate
                q_ghost[candidate] = None
                if len(q_ghost) > capacity:
                    q_ghost.popitem(last=False)
                meta_freq.pop(candidate, None)
                return candidate

    # Fallback if loop limit reached
    if q_small:
        k, _ = q_small.popitem(last=False)
        return k
    return next(iter(cache_snapshot.cache))

def update_after_hit(cache_snapshot, obj):
    '''
    On hit: increment frequency, maintain LRU order for Main.
    '''
    global q_small, q_main, meta_freq
    _reset_if_needed(cache_snapshot)

    key = obj.key
    meta_freq[key] = meta_freq.get(key, 0) + 1

    if key in q_main:
        q_main.move_to_end(key)
    # If in Small, do not move (lazy promotion)

def update_after_insert(cache_snapshot, obj):
    '''
    On insert: Handle Ghost hits or new insertions.
    '''
    global q_small, q_main, q_ghost, meta_freq
    _reset_if_needed(cache_snapshot)

    key = obj.key
    # Start with 0 frequency
    meta_freq[key] = 0

    if key in q_ghost:
        # Ghost Hit: Restore to Main
        del q_ghost[key]
        q_main[key] = None
    else:
        # New Item: Insert to Small
        q_small[key] = None

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    Cleanup internal state.
    '''
    global q_small, q_main, meta_freq
    _reset_if_needed(cache_snapshot)

    key = evicted_obj.key
    # Ensure removal
    q_small.pop(key, None)
    q_main.pop(key, None)
    meta_freq.pop(key, None)
>>>>>>> REPLACE
</DIFF>