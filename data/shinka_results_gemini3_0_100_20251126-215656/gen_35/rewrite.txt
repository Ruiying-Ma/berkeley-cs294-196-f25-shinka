# EVOLVE-BLOCK-START
"""Enhanced Adaptive S3-FIFO with Dual Ghost Queues"""

# Global state
# We use dicts as ordered sets (insertion order preserved)
_s3_small = {}
_s3_main = {}
_s3_ghost_s = {}
_s3_ghost_m = {}
_s3_freq = {}
_last_ts = -1
_s3_ratio = 0.1

def _check_reset(snapshot):
    global _s3_small, _s3_main, _s3_ghost_s, _s3_ghost_m, _s3_freq, _last_ts, _s3_ratio
    if snapshot.access_count < _last_ts:
        _s3_small.clear()
        _s3_main.clear()
        _s3_ghost_s.clear()
        _s3_ghost_m.clear()
        _s3_freq.clear()
        _s3_ratio = 0.1
    _last_ts = snapshot.access_count

def evict(cache_snapshot, obj):
    '''
    Adaptive S3-FIFO with Enhanced Ghost Queues.
    Evicts from Small (Probation) or Main (Protected) based on S3-FIFO logic.
    Uses capacity-based target calculation and larger ghost history.
    '''
    global _s3_small, _s3_main, _s3_freq, _s3_ratio
    _check_reset(cache_snapshot)
    
    # Use capacity for stable target calculation
    capacity = cache_snapshot.capacity
    s_target = max(1, int(capacity * _s3_ratio))
    
    while True:
        # 1. Check Small FIFO
        # Priority to evict from Small if it's over target size, OR if Main is empty.
        check_small = (len(_s3_small) > s_target) or (not _s3_main)
        
        if check_small:
            if not _s3_small:
                # Should not happen if cache not empty, fallback to Main
                if _s3_main:
                    check_small = False
                else:
                    if cache_snapshot.cache:
                        return next(iter(cache_snapshot.cache))
                    return None
            
            if check_small:
                candidate = next(iter(_s3_small))
                
                # Consistency check
                if candidate not in cache_snapshot.cache:
                    _s3_small.pop(candidate, None)
                    _s3_freq.pop(candidate, None)
                    continue
                
                freq = _s3_freq.get(candidate, 0)
                if freq > 0:
                    # Accessed while in Small -> Promote to Main
                    _s3_small.pop(candidate)
                    _s3_main[candidate] = None # Insert at tail (MRU)
                    _s3_freq[candidate] = 0    # Reset frequency
                    continue
                else:
                    # Not visited: Evict from Small
                    return candidate
        
        # 2. Check Main FIFO
        if _s3_main:
            candidate = next(iter(_s3_main))
            
            if candidate not in cache_snapshot.cache:
                _s3_main.pop(candidate, None)
                _s3_freq.pop(candidate, None)
                continue
            
            freq = _s3_freq.get(candidate, 0)
            if freq > 0:
                # Accessed while in Main -> Second Chance (Reinsert)
                _s3_main.pop(candidate)
                _s3_main[candidate] = None # Reinsert at tail
                _s3_freq[candidate] = 0
                continue
            else:
                # Not visited in Main: Evict
                return candidate

def update_after_hit(cache_snapshot, obj):
    global _s3_freq
    _check_reset(cache_snapshot)
    # Frequency capped at 3 to distinguish heavy hitters
    curr = _s3_freq.get(obj.key, 0)
    _s3_freq[obj.key] = min(curr + 1, 3)

def update_after_insert(cache_snapshot, obj):
    global _s3_small, _s3_main, _s3_ghost_s, _s3_ghost_m, _s3_freq, _s3_ratio
    _check_reset(cache_snapshot)
    
    key = obj.key
    delta = 0.02
    
    if key in _s3_ghost_s:
        # Hit in Ghost S -> Small was too small
        _s3_ratio = min(0.9, _s3_ratio + delta)
        # Rescue to Main
        if key not in _s3_main and key not in _s3_small:
            _s3_main[key] = None
            _s3_freq[key] = 0
        _s3_ghost_s.pop(key)
        
    elif key in _s3_ghost_m:
        # Hit in Ghost M -> Main was too small (Small too big)
        _s3_ratio = max(0.01, _s3_ratio - delta)
        # Rescue to Main
        if key not in _s3_main and key not in _s3_small:
            _s3_main[key] = None
            _s3_freq[key] = 0
        _s3_ghost_m.pop(key)
        
    else:
        # New insert -> Small (Probation)
        if key not in _s3_small and key not in _s3_main:
            _s3_small[key] = None
            _s3_freq[key] = 0

def update_after_evict(cache_snapshot, obj, evicted_obj):
    global _s3_small, _s3_main, _s3_ghost_s, _s3_ghost_m, _s3_freq
    _check_reset(cache_snapshot)
    
    key = evicted_obj.key
    # Increase ghost capacity to capture longer loops (2x capacity)
    ghost_limit = cache_snapshot.capacity * 2
    
    if key in _s3_small:
        _s3_small.pop(key)
        _s3_ghost_s[key] = None
        if len(_s3_ghost_s) > ghost_limit:
            _s3_ghost_s.pop(next(iter(_s3_ghost_s)), None)
            
    elif key in _s3_main:
        _s3_main.pop(key)
        _s3_ghost_m[key] = None
        if len(_s3_ghost_m) > ghost_limit:
            _s3_ghost_m.pop(next(iter(_s3_ghost_m)), None)
            
    _s3_freq.pop(key, None)
# EVOLVE-BLOCK-END