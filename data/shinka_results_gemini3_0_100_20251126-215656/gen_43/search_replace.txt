<NAME>
trace_origin_s3_fifo
</NAME>

<DESCRIPTION>
Implements S3-FIFO with Ghost Origin Tracking to improve scan resistance and protect the Main queue.
- Updates `q_small` to store a boolean flag `was_demoted` (True if demoted from Main, False if new).
- Updates `q_ghost` to store the origin of the evicted item (`was_demoted`).
- Modifies `update_after_insert` to handle Ghost hits intelligently:
    - If the ghost originated from Main (`was_demoted=True`), it is restored directly to Main (recovering VIPs).
    - If the ghost originated from Small (`was_demoted=False`), it is re-inserted into Small (Probation). This prevents large looping scans from polluting the Main queue, resolving the thrashing seen in Trace 14 while preserving Main's hit rate for mixed workloads.
- Modifies `evict` to correctly propagate the `was_demoted` flag:
    - Sets `was_demoted=True` when demoting from Main to Small.
    - Preserves `was_demoted` when evicting from Small to Ghost.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# Advanced S3-FIFO Algorithm
# Implements S3-FIFO with demotion (soft eviction from Main) and ghost queues.
# q_small: FIFO queue for new items (Probation).
# q_main: LRU queue for popular items (Protected).
# q_ghost: FIFO queue for history of evicted items.
# meta_freq: Dictionary tracking access counts for items in cache.

q_small = OrderedDict()
q_main = OrderedDict()
q_ghost = OrderedDict()
meta_freq = {}
last_access_count = -1

def _reset_if_needed(snapshot):
    """Resets state if a new trace is detected."""
    global q_small, q_main, q_ghost, meta_freq, last_access_count
    if snapshot.access_count < last_access_count:
        q_small.clear()
        q_main.clear()
        q_ghost.clear()
        meta_freq.clear()

    # Safety reset if cache is physically empty but we have state
    if not snapshot.cache and (q_small or q_main):
        q_small.clear()
        q_main.clear()
        q_ghost.clear()
        meta_freq.clear()

    last_access_count = snapshot.access_count

def evict(cache_snapshot, obj):
    '''
    Selects a victim using S3-FIFO logic with Main-to-Small demotion.
    '''
    global q_small, q_main, q_ghost, meta_freq
    _reset_if_needed(cache_snapshot)

    capacity = cache_snapshot.capacity
    # Target size for small queue (10% of capacity)
    target_small = max(1, int(capacity * 0.1))

    # We loop to find a victim, processing promotions/demotions along the way.
    # Safety limit to prevent infinite loops (though logic should guarantee termination).
    loop_limit = len(cache_snapshot.cache) * 2
    ops = 0

    while ops < loop_limit:
        ops += 1

        # Decide which queue to evict from
        # If Small is over budget or Main is empty, we must evict from Small.
        # Otherwise, we evict from Main.
        evict_from_small = False
        if len(q_small) > target_small or len(q_main) == 0:
            evict_from_small = True

        if evict_from_small:
            if not q_small:
                # Should only happen if Main is empty too (cache empty?)
                if q_main:
                    # Fallback to Main
                    candidate, _ = q_main.popitem(last=False)
                    q_ghost[candidate] = None
                    meta_freq.pop(candidate, None)
                    return candidate
                # Absolute fallback
                return next(iter(cache_snapshot.cache))

            # FIFO eviction from Small
            candidate, _ = q_small.popitem(last=False)

            # Check for promotion: if accessed while in Small
            freq = meta_freq.get(candidate, 0)
            if freq > 0:
                # Promote to Main
                q_main[candidate] = None
                meta_freq[candidate] = 0 # Reset frequency cost
                continue # Retry eviction
            else:
                # Evict candidate
                q_ghost[candidate] = None
                if len(q_ghost) > capacity:
                    q_ghost.popitem(last=False)
                meta_freq.pop(candidate, None)
                return candidate

        else:
            # Evict from Main (LRU)
            candidate, _ = q_main.popitem(last=False)

            # Check for demotion: if accessed while in Main (freq > 0)
            # This gives "warm" items a second chance in Small
            freq = meta_freq.get(candidate, 0)
            if freq > 0:
                # Demote to Small
                q_small[candidate] = None
                meta_freq[candidate] = 0 # Reset frequency
                continue # Retry eviction
            else:
                # Evict candidate
                q_ghost[candidate] = None
                if len(q_ghost) > capacity:
                    q_ghost.popitem(last=False)
                meta_freq.pop(candidate, None)
                return candidate

    # Fallback if loop limit reached
    if q_small:
        k, _ = q_small.popitem(last=False)
        return k
    return next(iter(cache_snapshot.cache))
=======
# Advanced S3-FIFO Algorithm with Ghost Origin Tracking
# q_small: FIFO queue for new/probation items. Values: bool (True if demoted from Main).
# q_main: LRU queue for protected items. Values: None.
# q_ghost: FIFO queue for evicted history. Values: bool (True if evicted from Main or was demoted).
# meta_freq: Dictionary tracking access counts for items in cache.

q_small = OrderedDict()
q_main = OrderedDict()
q_ghost = OrderedDict()
meta_freq = {}
last_access_count = -1

def _reset_if_needed(snapshot):
    """Resets state if a new trace is detected."""
    global q_small, q_main, q_ghost, meta_freq, last_access_count
    if snapshot.access_count < last_access_count:
        q_small.clear()
        q_main.clear()
        q_ghost.clear()
        meta_freq.clear()

    # Safety reset if cache is physically empty but we have state
    if not snapshot.cache and (q_small or q_main):
        q_small.clear()
        q_main.clear()
        q_ghost.clear()
        meta_freq.clear()

    last_access_count = snapshot.access_count

def evict(cache_snapshot, obj):
    '''
    Selects a victim using S3-FIFO logic with Ghost Origin Tracking.
    '''
    global q_small, q_main, q_ghost, meta_freq
    _reset_if_needed(cache_snapshot)

    capacity = cache_snapshot.capacity
    target_small = max(1, int(capacity * 0.1))

    # Loop to find victim
    loop_limit = len(cache_snapshot.cache) * 2
    ops = 0

    while ops < loop_limit:
        ops += 1

        evict_from_small = False
        if len(q_small) > target_small or len(q_main) == 0:
            evict_from_small = True

        if evict_from_small:
            if not q_small:
                if q_main:
                    candidate, _ = q_main.popitem(last=False)
                    q_ghost[candidate] = True # Treated as from Main
                    meta_freq.pop(candidate, None)
                    return candidate
                return next(iter(cache_snapshot.cache))

            candidate, was_demoted = q_small.popitem(last=False)

            freq = meta_freq.get(candidate, 0)
            if freq > 0:
                # Promote to Main
                q_main[candidate] = None
                meta_freq[candidate] = 0
                continue
            else:
                # Evict
                # Pass 'was_demoted' status to ghost
                q_ghost[candidate] = was_demoted
                if len(q_ghost) > capacity:
                    q_ghost.popitem(last=False)
                meta_freq.pop(candidate, None)
                return candidate

        else:
            # Evict from Main
            candidate, _ = q_main.popitem(last=False)

            freq = meta_freq.get(candidate, 0)
            if freq > 0:
                # Demote to Small
                # Mark as demoted from Main (True)
                q_small[candidate] = True
                meta_freq[candidate] = 0
                continue
            else:
                # Evict
                q_ghost[candidate] = True # From Main
                if len(q_ghost) > capacity:
                    q_ghost.popitem(last=False)
                meta_freq.pop(candidate, None)
                return candidate

    if q_small:
        k, _ = q_small.popitem(last=False)
        return k
    return next(iter(cache_snapshot.cache))
>>>>>>> REPLACE
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    '''
    On insert: Handle Ghost hits or new insertions.
    '''
    global q_small, q_main, q_ghost, meta_freq
    _reset_if_needed(cache_snapshot)

    key = obj.key
    # Start with 0 frequency
    meta_freq[key] = 0

    if key in q_ghost:
        # Ghost Hit: Restore to Main
        del q_ghost[key]
        q_main[key] = None
    else:
        # New Item: Insert to Small
        q_small[key] = None
=======
def update_after_insert(cache_snapshot, obj):
    '''
    On insert: Handle Ghost hits based on origin.
    '''
    global q_small, q_main, q_ghost, meta_freq
    _reset_if_needed(cache_snapshot)

    key = obj.key
    meta_freq[key] = 0

    if key in q_ghost:
        was_demoted = q_ghost.pop(key)
        if was_demoted:
            # Was in Main before -> Restore to Main
            q_main[key] = None
        else:
            # Was only in Small -> Restore to Small (Probation)
            # This filters loops from polluting Main
            q_small[key] = False
    else:
        # New Item -> Small
        q_small[key] = False
>>>>>>> REPLACE
</DIFF>