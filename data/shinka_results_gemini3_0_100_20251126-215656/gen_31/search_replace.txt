<NAME>
freq_demote_s3fifo
</NAME>

<DESCRIPTION>
This change improves the Dynamic S3-FIFO algorithm by implementing "Frequency-Based Demotion" and correcting the Ghost Queue routing.
1.  **Frequency Tracking**: Replaces the binary `accessed_bits` with a `freq_map` to track access intensity.
2.  **Explicit Demotion**: Instead of evicting directly from Main, cold items in Main are demoted to the Small queue. This gives them a final probationary pass, improving retention of working sets that briefly cool down.
3.  **Origin Tracking**: A `demoted_set` tracks items moved from Main to Small. This allows the algorithm to distinguish between "early evictions" (Ghost S) and "late evictions" (Ghost M) even when all evictions physically happen from Small. This restores the correct feedback loop for the adaptive sizing (`s_dist`).
4.  **Aging**: Frequencies are reset on promotion/demotion to enforce aging and prevent cache pollution by historically hot but currently cold items.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
from collections import OrderedDict

# Global State
small_q = OrderedDict()       # Probationary queue (FIFO)
main_q = OrderedDict()        # Protected queue (FIFO)
ghost_s = OrderedDict()       # Ghost S (History of S evictions)
ghost_m = OrderedDict()       # Ghost M (History of M evictions)
accessed_bits = set()         # Track hits
s_dist = 0.1                  # Target fraction for S queue
last_access_count = 0         # For detecting trace changes

def check_reset(cache_snapshot):
    """Detects new trace and resets globals."""
    global small_q, main_q, ghost_s, ghost_m, accessed_bits, s_dist, last_access_count

    current_acc = cache_snapshot.access_count
    # Heuristic: access count reset/drop OR cache empty with residual state
    if current_acc < last_access_count or (len(cache_snapshot.cache) <= 1 and len(small_q) > 1):
        small_q.clear()
        main_q.clear()
        ghost_s.clear()
        ghost_m.clear()
        accessed_bits.clear()
        s_dist = 0.1
        last_access_count = 0

    last_access_count = current_acc

def evict(cache_snapshot, obj):
    '''
    Selects a victim using Dynamic S3-FIFO.
    Lazy migration: Moves items between S/M or to Ghost during eviction scan.
    '''
    global s_dist

    capacity = cache_snapshot.capacity
    s_target = max(1, int(capacity * s_dist))
    ghost_limit = max(capacity, int(2 * capacity))

    # Iterate until a victim is found (Scan resistant loop)
    while True:
        # Determine which queue to evict from
        # Prioritize evicting from S if it's over target, or if M is empty
        evict_s = (len(small_q) > s_target) or (len(main_q) == 0)

        if evict_s:
            if not small_q:
                # Should not happen if logic matches cache state, fallback to M
                evict_s = False
            else:
                key, _ = small_q.popitem(last=False) # Head of FIFO

                if key in accessed_bits:
                    # Second Chance: Promote to M
                    accessed_bits.discard(key)
                    main_q[key] = None
                    # We moved item S->M, but cache is still full. Loop continues.
                else:
                    # Victim found
                    ghost_s[key] = None
                    if len(ghost_s) > ghost_limit:
                        ghost_s.popitem(last=False)
                    return key

        if not evict_s:
            if not main_q:
                # Emergency fallback
                return next(iter(cache_snapshot.cache))

            key, _ = main_q.popitem(last=False) # Head of FIFO

            if key in accessed_bits:
                # Second Chance: Reinsert to M Tail
                accessed_bits.discard(key)
                main_q[key] = None
            else:
                # Victim found
                ghost_m[key] = None
                if len(ghost_m) > ghost_limit:
                    ghost_m.popitem(last=False)
                return key

def update_after_hit(cache_snapshot, obj):
    check_reset(cache_snapshot)
    accessed_bits.add(obj.key)

def update_after_insert(cache_snapshot, obj):
    check_reset(cache_snapshot)

    global s_dist
    key = obj.key
    capacity = cache_snapshot.capacity

    # Adaptive sizing delta
    delta = 1.0 / capacity if capacity > 0 else 0.01

    if key in ghost_s:
        # Hit in Ghost S: S was too small. Increase S target.
        s_dist = min(0.9, s_dist + delta)
        # Rescue: promote to M
        main_q[key] = None
        del ghost_s[key]
        accessed_bits.discard(key) # Reset bit on rescue

    elif key in ghost_m:
        # Hit in Ghost M: M was too small. Decrease S target (Grow M).
        s_dist = max(0.01, s_dist - delta)
        # Rescue: promote to M
        main_q[key] = None
        del ghost_m[key]
        accessed_bits.discard(key)

    else:
        # New insert: Insert into S
        small_q[key] = None
        accessed_bits.discard(key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    # Ensure internal state matches cache state
    # (Victim was already popped in evict, but just in case of mismatch)
    key = evicted_obj.key
    accessed_bits.discard(key)
    if key in small_q:
        del small_q[key]
    if key in main_q:
        del main_q[key]
=======
from collections import OrderedDict

# Global State
small_q = OrderedDict()       # Probationary queue (FIFO)
main_q = OrderedDict()        # Protected queue (FIFO)
ghost_s = OrderedDict()       # Ghost S (History of S evictions)
ghost_m = OrderedDict()       # Ghost M (History of M evictions)
freq_map = {}                 # Frequency map for hits
demoted_set = set()           # Tracks items demoted M->S
s_dist = 0.1                  # Target fraction for S queue
last_access_count = 0         # For detecting trace changes

def check_reset(cache_snapshot):
    """Detects new trace and resets globals."""
    global small_q, main_q, ghost_s, ghost_m, freq_map, demoted_set, s_dist, last_access_count

    current_acc = cache_snapshot.access_count
    if current_acc < last_access_count or (len(cache_snapshot.cache) <= 1 and len(small_q) > 1):
        small_q.clear()
        main_q.clear()
        ghost_s.clear()
        ghost_m.clear()
        freq_map.clear()
        demoted_set.clear()
        s_dist = 0.1
        last_access_count = 0

    last_access_count = current_acc

def evict(cache_snapshot, obj):
    '''
    Selects a victim using Frequency-Based S3-FIFO with Demotion.
    - Demotes cold M items to S.
    - Tracks origin of S victims to route to correct Ghost (S or M) for adaptation.
    '''
    global s_dist

    capacity = cache_snapshot.capacity
    s_target = max(1, int(capacity * s_dist))
    ghost_limit = max(capacity, int(2 * capacity))

    while True:
        # Prefer evicting from S if over target or M empty
        evict_s = (len(small_q) > s_target) or (len(main_q) == 0)

        if evict_s:
            if not small_q:
                evict_s = False
            else:
                key, _ = small_q.popitem(last=False)
                cnt = freq_map.get(key, 0)

                if cnt > 0:
                    # Accessed in S -> Promote to Main
                    freq_map[key] = 0
                    main_q[key] = None
                    demoted_set.discard(key) # Now in Main
                else:
                    # Cold in S -> Evict
                    # Check origin for Ghost routing
                    if key in demoted_set:
                        ghost_m[key] = None
                        if len(ghost_m) > ghost_limit:
                            ghost_m.popitem(last=False)
                        demoted_set.discard(key)
                    else:
                        ghost_s[key] = None
                        if len(ghost_s) > ghost_limit:
                            ghost_s.popitem(last=False)
                    return key

        if not evict_s:
            if not main_q:
                return next(iter(cache_snapshot.cache))

            key, _ = main_q.popitem(last=False)
            cnt = freq_map.get(key, 0)

            if cnt > 0:
                # Accessed in M -> Reinsert M
                freq_map[key] = 0
                main_q[key] = None
            else:
                # Cold in M -> Demote to S
                freq_map[key] = 0
                small_q[key] = None
                demoted_set.add(key)
                # Loop continues to find actual victim

def update_after_hit(cache_snapshot, obj):
    check_reset(cache_snapshot)
    curr = freq_map.get(obj.key, 0)
    freq_map[obj.key] = min(curr + 1, 3)

def update_after_insert(cache_snapshot, obj):
    check_reset(cache_snapshot)

    global s_dist
    key = obj.key
    capacity = cache_snapshot.capacity
    freq_map[key] = 0
    demoted_set.discard(key) # New or Rescued

    delta = 1.0 / capacity if capacity > 0 else 0.01

    if key in ghost_s:
        # S too small
        s_dist = min(0.9, s_dist + delta)
        main_q[key] = None
        del ghost_s[key]

    elif key in ghost_m:
        # M too small
        s_dist = max(0.01, s_dist - delta)
        main_q[key] = None
        del ghost_m[key]

    else:
        # New -> Small
        small_q[key] = None

def update_after_evict(cache_snapshot, obj, evicted_obj):
    key = evicted_obj.key
    if key in freq_map:
        del freq_map[key]
    if key in demoted_set:
        demoted_set.discard(key)
    if key in small_q:
        del small_q[key]
    if key in main_q:
        del main_q[key]
>>>>>>> REPLACE
</DIFF>