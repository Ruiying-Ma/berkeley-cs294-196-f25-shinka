# EVOLVE-BLOCK-START
"""
Advanced S3-FIFO (AdvS3FIFO)
Enhancements:
- Conditional Demotion: M->S demotion only when S is not full. Prevents S pollution.
- Expanded Ghost: Ghost registry size set to 4x capacity to catch larger loops.
- Frequency Counters: Uses counters (0-3) for finer granularity.
- Origin Tracking: Implicitly handles M-evicts by adding to Ghost, ensuring quick recovery.
"""

from collections import OrderedDict

# Global State
# s_queue: Small/Probationary Queue
# m_queue: Main/Protected Queue
# ghost_registry: History of evictions (both S and M)
# freq_map: Frequency counter (0-3) for items in cache

s_queue = OrderedDict()
m_queue = OrderedDict()
ghost_registry = OrderedDict()
freq_map = {}

def evict(cache_snapshot, obj):
    '''
    Selects a victim with conditional demotion and strict S3-FIFO logic.
    '''
    capacity = cache_snapshot.capacity
    # S target: 10% of capacity.
    s_target = max(int(capacity * 0.1), 1)
    
    # Ghost limit: 4x capacity (aggressive history)
    ghost_limit = capacity * 4

    while True:
        # Determine which queue to process
        # Prioritize S if it's overflowing OR if M is empty (need to maintain fullness)
        # Note: If M is empty, we MUST evict from S to make space (if S has items).
        clean_s = len(s_queue) > s_target or len(m_queue) == 0
        
        if clean_s:
            if not s_queue:
                # M must be non-empty here if cache is full, so flip to M
                if m_queue:
                    clean_s = False
                else:
                    # Cache is empty? Should not happen in evict.
                    # Or logic error. Fallback.
                    return next(iter(cache_snapshot.cache))

            if clean_s:
                # Process S Queue
                candidate, _ = s_queue.popitem(last=False) # FIFO head
                cnt = freq_map.get(candidate, 0)
                
                if cnt > 0:
                    # Accessed in S -> Promote to M
                    m_queue[candidate] = None
                    freq_map[candidate] = 0 # Reset frequency
                else:
                    # Not accessed -> Evict
                    ghost_registry[candidate] = None
                    if len(ghost_registry) > ghost_limit:
                        ghost_registry.popitem(last=False) # Remove oldest ghost
                    return candidate
        
        if not clean_s:
            # Process M Queue
            candidate, _ = m_queue.popitem(last=False)
            cnt = freq_map.get(candidate, 0)
            
            if cnt > 0:
                # Accessed in M -> Reinsert to M tail (Second Chance)
                m_queue[candidate] = None
                freq_map[candidate] = 0 # Reset frequency
            else:
                # Cold in M. Decide destination.
                # Conditional Demotion: Only if S has space.
                if len(s_queue) < s_target:
                    s_queue[candidate] = None
                    # frequency remains 0
                else:
                    # S is full. Do not demote. Evict directly.
                    # Add to Ghost to rescue if it comes back soon.
                    ghost_registry[candidate] = None
                    if len(ghost_registry) > ghost_limit:
                        ghost_registry.popitem(last=False)
                    return candidate

def update_after_hit(cache_snapshot, obj):
    '''Increment frequency, cap at 3.'''
    key = obj.key
    curr = freq_map.get(key, 0)
    freq_map[key] = min(curr + 1, 3)

def update_after_insert(cache_snapshot, obj):
    '''Insert based on Ghost history.'''
    key = obj.key
    freq_map[key] = 0 # Init frequency
    
    if key in ghost_registry:
        # Ghost hit -> Insert to M (skip probation)
        m_queue[key] = None
        del ghost_registry[key]
    else:
        # New -> Insert to S
        s_queue[key] = None

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''Cleanup metadata.'''
    key = evicted_obj.key
    if key in freq_map:
        del freq_map[key]
    # Ensure removed from queues (already done in evict, but safe practice)
    if key in s_queue:
        del s_queue[key]
    if key in m_queue:
        del m_queue[key]
# EVOLVE-BLOCK-END