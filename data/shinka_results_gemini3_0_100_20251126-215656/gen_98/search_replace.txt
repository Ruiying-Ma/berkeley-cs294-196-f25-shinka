<NAME>
optimize_s3_params
</NAME>

<DESCRIPTION>
Optimizing S3-FIFO-P parameters to handle scan resistance and large loops (Trace 14) while maintaining strong static locality (Trace 28).

Changes:
1.  **Reduce `_SMALL_RATIO` to 0.05 (5%)**: Allocates 95% of cache to the Main queue. This maximizes the protected region for the working set (Trace 28) and increases the churn rate of the Small queue, forcing scan items to pass through quickly without polluting the cache.
2.  **Increase Ghost Capacity to 5x**: Expands the ghost registry to 5x the cache capacity. This allows the algorithm to track evicted items over a much longer horizon, enabling it to catch larger loops and "second chance" hits that would otherwise be missed (improving Trace 14 and others with large loops).
3.  **Increase Frequency Cap to 7**: Raises the maximum frequency in `_s3_freq` to 7. This allows the Main queue to better distinguish between "warm" and "very hot" items, providing a deeper buffer for frequently accessed objects.
4.  **Increase Ghost Promotion Bonus to 3**: When an item is promoted from Ghost to Main, it starts with a frequency of 3 (tenancy bonus). This ensures it survives at least 3 eviction cycles in Main, acknowledging its proven recurrence.

These changes collectively implement a "Scan-Resistant, Loop-Aware" policy where the cache relies on a large metadata history (Ghost) rather than physical cache space (Small) to filter new items.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# Constants
_SMALL_RATIO = 0.1
=======
# Constants
_SMALL_RATIO = 0.05
>>>>>>> REPLACE
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    '''
    S3-FIFO with Demotion strategy.
    - Small (Probation): FIFO. Hits promote to Main. Cold evicts to Ghost.
    - Main (Protected): FIFO. Hits reinsert. Cold DEMOTES to Small.
    '''
    global _s3_small, _s3_main, _s3_ghost, _s3_freq
    _check_reset(cache_snapshot)

    capacity = cache_snapshot.capacity
    s_target = max(1, int(capacity * _SMALL_RATIO))

    while True:
        # 1. Prefer evicting from Small if it exceeds target OR Main is empty
        if len(_s3_small) > s_target or not _s3_main:
            if not _s3_small:
                # Fallback if both empty (should imply cache empty)
                if cache_snapshot.cache:
                    return next(iter(cache_snapshot.cache))
                return None

            candidate, _ = _s3_small.popitem(last=False) # FIFO head

            # Sync check
            if candidate not in cache_snapshot.cache:
                _s3_freq.pop(candidate, None)
                continue

            freq = _s3_freq.get(candidate, 0)
            if freq > 0:
                # Promotion: Small -> Main
                _s3_main[candidate] = None
                _s3_freq[candidate] = 0
                continue
            else:
                # Eviction: Small -> Ghost -> Out
                _s3_ghost[candidate] = None
                # Expanded ghost capacity (2x) for better loop detection
                if len(_s3_ghost) > capacity * 2:
                    _s3_ghost.popitem(last=False)
                _s3_freq.pop(candidate, None)
                return candidate

        # 2. Process Main
        else:
            if not _s3_main:
                 continue

            candidate, _ = _s3_main.popitem(last=False)

            if candidate not in cache_snapshot.cache:
                _s3_freq.pop(candidate, None)
                continue

            freq = _s3_freq.get(candidate, 0)
            if freq > 0:
                # Reinsertion: Main -> Main (Decay)
                _s3_main[candidate] = None
                _s3_freq[candidate] = freq - 1
                continue
            else:
                # Demotion: Main -> Small
                # Give it one last chance in probation
                _s3_small[candidate] = None
                _s3_freq[candidate] = 0
                continue
=======
def evict(cache_snapshot, obj):
    '''
    S3-FIFO with Demotion strategy.
    - Small (Probation): FIFO. Hits promote to Main. Cold evicts to Ghost.
    - Main (Protected): FIFO. Hits reinsert. Cold DEMOTES to Small.
    '''
    global _s3_small, _s3_main, _s3_ghost, _s3_freq
    _check_reset(cache_snapshot)

    capacity = cache_snapshot.capacity
    s_target = max(1, int(capacity * _SMALL_RATIO))

    while True:
        # 1. Prefer evicting from Small if it exceeds target OR Main is empty
        if len(_s3_small) > s_target or not _s3_main:
            if not _s3_small:
                # Fallback if both empty (should imply cache empty)
                if cache_snapshot.cache:
                    return next(iter(cache_snapshot.cache))
                return None

            candidate, _ = _s3_small.popitem(last=False) # FIFO head

            # Sync check
            if candidate not in cache_snapshot.cache:
                _s3_freq.pop(candidate, None)
                continue

            freq = _s3_freq.get(candidate, 0)
            if freq > 0:
                # Promotion: Small -> Main
                _s3_main[candidate] = None
                _s3_freq[candidate] = 0
                continue
            else:
                # Eviction: Small -> Ghost -> Out
                _s3_ghost[candidate] = None
                # Expanded ghost capacity (5x) for better loop detection
                if len(_s3_ghost) > capacity * 5:
                    _s3_ghost.popitem(last=False)
                _s3_freq.pop(candidate, None)
                return candidate

        # 2. Process Main
        else:
            if not _s3_main:
                 continue

            candidate, _ = _s3_main.popitem(last=False)

            if candidate not in cache_snapshot.cache:
                _s3_freq.pop(candidate, None)
                continue

            freq = _s3_freq.get(candidate, 0)
            if freq > 0:
                # Reinsertion: Main -> Main (Decay)
                _s3_main[candidate] = None
                _s3_freq[candidate] = freq - 1
                continue
            else:
                # Demotion: Main -> Small
                # Give it one last chance in probation
                _s3_small[candidate] = None
                _s3_freq[candidate] = 0
                continue
>>>>>>> REPLACE
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    global _s3_freq
    _check_reset(cache_snapshot)
    curr = _s3_freq.get(obj.key, 0)
    # Cap frequency higher to support Decay strategy
    _s3_freq[obj.key] = min(curr + 1, 5)

def update_after_insert(cache_snapshot, obj):
    global _s3_small, _s3_main, _s3_ghost, _s3_freq
    _check_reset(cache_snapshot)

    key = obj.key
    # Ghost check for quick promotion
    if key in _s3_ghost:
        if key not in _s3_main and key not in _s3_small:
            _s3_main[key] = None
            # Tenancy bonus: give it some buffer in Main
            _s3_freq[key] = 2
        del _s3_ghost[key]
    else:
        # Standard insert to Small
        if key not in _s3_small and key not in _s3_main:
            _s3_small[key] = None
            _s3_freq[key] = 0
=======
def update_after_hit(cache_snapshot, obj):
    global _s3_freq
    _check_reset(cache_snapshot)
    curr = _s3_freq.get(obj.key, 0)
    # Cap frequency higher to support Decay strategy
    _s3_freq[obj.key] = min(curr + 1, 7)

def update_after_insert(cache_snapshot, obj):
    global _s3_small, _s3_main, _s3_ghost, _s3_freq
    _check_reset(cache_snapshot)

    key = obj.key
    # Ghost check for quick promotion
    if key in _s3_ghost:
        if key not in _s3_main and key not in _s3_small:
            _s3_main[key] = None
            # Tenancy bonus: give it some buffer in Main
            _s3_freq[key] = 3
        del _s3_ghost[key]
    else:
        # Standard insert to Small
        if key not in _s3_small and key not in _s3_main:
            _s3_small[key] = None
            _s3_freq[key] = 0
>>>>>>> REPLACE
</DIFF>