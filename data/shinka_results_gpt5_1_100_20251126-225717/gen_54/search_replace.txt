<NAME>
slru_tinylfu_guard_ghost_bias
</NAME>

<DESCRIPTION>
I introduce three synergistic improvements aimed at reducing miss rates across diverse workloads:

1) Ghost-guided victim biasing and smarter sampling in evict:
   - When the incoming key has a protected ghost (B2), we prefer evicting from probation; when it has a probation ghost (B1), we prefer evicting from protected. This preserves likely-to-be-reused hot items.
   - Candidate tuples include a “desired segment mismatch” term, ensuring we select victims from the preferred segment first, while still honoring the admission guard that avoids evicting hotter items than the incoming object.
   - Sampling sizes adapt with mode and segment imbalance and are bounded to reduce noise.

2) Earlier and more robust promotions on hit:
   - Outside scans, promote from probation to protected on either second touch, minimal LFU hotness (score ≥ 1), or a recent ghost (B1/B2) signal, improving retention of emerging hot keys.
   - During scans, maintain two-touch gating to remain scan-resistant.
   - Slightly expand the protected fraction on clearly hot promotions.

3) Ghost-aware admission and TinyLFU-based admission guard at insert:
   - If the key has a recent protected ghost, re-admit directly into protected unconditionally and bias toward protected.
   - If a B1 ghost is seen, we bias to recency (probation) and give a small frequency bump.
   - Use the last victim’s score for admission guarding: if the incoming object is colder than the recent victim, place it at probation LRU (cheap admission) so it will be culled quickly if pressure continues. Outside scans, cold admissions go to probation MRU unless the guard triggers.
   - Cleanup ghost entries on re-admit to keep ghost sizes meaningful.

Overall, these changes keep the existing SLRU+TinyLFU structure but refine promotion/admission policy and victim selection with better ghost feedback, leading to lower pollution and stronger retention of truly hot items.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    # Keep metadata consistent and properly segmented before choosing a victim
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track key for scan detection unique density
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    # Clean up stale entries (if any)
    for k in list(_probation.keys()):
        if k not in cache_snapshot.cache:
            _probation.pop(k, None)
            _key_seg.pop(k, None)
    for k in list(_protected.keys()):
        if k not in cache_snapshot.cache:
            _protected.pop(k, None)
            _key_seg.pop(k, None)

    # If metadata is empty, fallback
    if not cache_snapshot.cache:
        return None

    # Adaptive sampling sizes
    prob_sample = _BASE_PROB_SAMPLE
    prot_sample = _BASE_PROT_SAMPLE
    if _scan_mode:
        prob_sample += 1
        prot_sample = max(1, prot_sample - 1)
    if len(_probation) > len(_protected) + 2:
        prob_sample += 1
    if len(_protected) > len(_probation) + 2:
        prot_sample += 1

    # Incoming-aware admission guard: avoid evicting hotter items if possible
    incoming_score = _score(obj.key)

    # Build candidate tuples from both segments' LRU sides
    candidates = []
    # Probation candidates
    pkeys = _sample_lru_keys(_probation, prob_sample)
    for idx, pk in enumerate(pkeys):
        if pk in cache_snapshot.cache:
            s = _score(pk)
            hotter = 1 if (_ADMISSION_GUARD and s > incoming_score) else 0
            segpref = 0  # probation preferred
            candidates.append((hotter, s, segpref, idx, pk))
    # Protected candidates
    tkeys = _sample_lru_keys(_protected, prot_sample)
    for idx, tk in enumerate(tkeys):
        if tk in cache_snapshot.cache:
            s = _score(tk)
            hotter = 1 if (_ADMISSION_GUARD and s > incoming_score) else 0
            segpref = 1  # protected less preferred
            candidates.append((hotter, s, segpref, idx, tk))

    if not candidates:
        # Fallback: pick any key from cache if metadata got desynced
        return next(iter(cache_snapshot.cache.keys()))

    # Choose coldest by (hotter_than_incoming, score, segment preference, recency)
    best = min(candidates)
    candid_obj_key = best[4]
    victim_from_protected = (_key_seg.get(candid_obj_key) == 'prot')

    # Adaptive tuning: if we are forced to evict from protected, reduce its target fraction slightly
    if victim_from_protected:
        _decrease_protected()

    return candid_obj_key
=======
def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    # Keep metadata consistent and properly segmented before choosing a victim
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track key for scan detection unique density
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    # Clean up stale entries (if any)
    for k in list(_probation.keys()):
        if k not in cache_snapshot.cache:
            _probation.pop(k, None)
            _key_seg.pop(k, None)
    for k in list(_protected.keys()):
        if k not in cache_snapshot.cache:
            _protected.pop(k, None)
            _key_seg.pop(k, None)

    # If metadata is empty, fallback
    if not cache_snapshot.cache:
        return None

    # Ghost-guided desired eviction segment
    desired_seg = None
    if obj.key in _ghost_protected and len(_probation) > 0:
        desired_seg = 'prob'   # keep protected for likely hot reuses
    elif obj.key in _ghost_probation and len(_protected) > 0:
        desired_seg = 'prot'   # favor recency by evicting from protected

    # Adaptive sampling sizes (capped and mode-aware)
    prob_sample = _BASE_PROB_SAMPLE
    prot_sample = _BASE_PROT_SAMPLE
    if _scan_mode:
        prob_sample += 1
        prot_sample = max(1, prot_sample - 1)
    if len(_probation) > len(_protected) + 2:
        prob_sample += 1
    if len(_protected) > len(_probation) + 2:
        prot_sample += 1
    # Bound samples to reduce noise and overhead
    prob_sample = max(1, min(6, prob_sample + (1 if desired_seg == 'prob' else 0)))
    prot_sample = max(1, min(5, prot_sample + (1 if desired_seg == 'prot' else 0)))

    # Incoming-aware admission guard: avoid evicting hotter items if possible
    incoming_score = _score(obj.key)

    # Build candidate tuples from both segments' LRU sides
    candidates = []
    # Probation candidates
    pkeys = _sample_lru_keys(_probation, prob_sample)
    for idx, pk in enumerate(pkeys):
        if pk in cache_snapshot.cache:
            s = _score(pk)
            hotter = 1 if (_ADMISSION_GUARD and s > incoming_score) else 0
            segpref = 0  # probation preferred
            mismatch = 0 if (desired_seg is None or desired_seg == 'prob') else 1
            candidates.append((hotter, mismatch, s, segpref, idx, pk))
    # Protected candidates
    tkeys = _sample_lru_keys(_protected, prot_sample)
    for idx, tk in enumerate(tkeys):
        if tk in cache_snapshot.cache:
            s = _score(tk)
            hotter = 1 if (_ADMISSION_GUARD and s > incoming_score) else 0
            segpref = 1  # protected less preferred
            mismatch = 0 if (desired_seg is None or desired_seg == 'prot') else 1
            candidates.append((hotter, mismatch, s, segpref, idx, tk))

    if not candidates:
        # Fallback: pick any key from cache if metadata got desynced
        return next(iter(cache_snapshot.cache.keys()))

    # Choose coldest by (hotter_than_incoming, desired-segment mismatch, score, segment preference, recency)
    best = min(candidates)
    candid_obj_key = best[5]
    victim_from_protected = (_key_seg.get(candid_obj_key) == 'prot')

    # Adaptive tuning: if we are forced to evict from protected, reduce its target fraction slightly
    if victim_from_protected:
        _decrease_protected()

    return candid_obj_key
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)

    if seg == 'prob':
        last = _touched_once.get(k)
        promote = False
        if _scan_mode:
            # Two-touch gating under scans: require two hits within a short window
            if last is not None and (_epoch - last) <= 1:
                promote = True
            else:
                _touched_once[k] = _epoch
        else:
            # Outside scans: two-touch OR clearly hot by frequency OR recent protected ghost
            hot_freq = (_score(k) >= 2)
            gpe = _ghost_protected.get(k)
            recent_b2 = (gpe is not None) and (_epoch - gpe <= 3)
            if last is not None or hot_freq or recent_b2:
                promote = True
            else:
                _touched_once[k] = _epoch

        if promote:
            _touched_once.pop(k, None)
            _probation.pop(k, None)
            _protected[k] = None  # MRU
            _key_seg[k] = 'prot'
            # Only expand protected on truly hot promotions
            if not _scan_mode and _score(k) >= 2:
                _increase_protected()
        else:
            # Refresh to MRU of probation
            if k in _probation:
                _probation.move_to_end(k, last=True)
            else:
                _probation[k] = None

    elif seg == 'prot':
        # Refresh recency in protected
        if k in _protected:
            _protected.move_to_end(k, last=True)
        else:
            # If somehow missing from the structure, reinsert into protected
            _protected[k] = None
            _key_seg[k] = 'prot'
        # Clear any stale two-touch marker
        _touched_once.pop(k, None)
    else:
        # Unknown key (shouldn't happen on hit). Refresh probation; do not auto-promote.
        _probation[k] = None
        _key_seg[k] = 'prob'
        _probation.move_to_end(k, last=True)

    _rebalance(cache_snapshot)
=======
def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)

    if seg == 'prob':
        last = _touched_once.get(k)
        promote = False
        if _scan_mode:
            # Two-touch gating under scans: require two hits within a short window
            if last is not None and (_epoch - last) <= 1:
                promote = True
            else:
                _touched_once[k] = _epoch
        else:
            # Outside scans: second touch OR minimal hotness OR recent ghost evidence
            hot_freq = (_score(k) >= 1)
            gpe = _ghost_protected.get(k)
            recent_b2 = (gpe is not None) and (_epoch - gpe <= 4)
            gbe = _ghost_probation.get(k)
            recent_b1 = (gbe is not None) and (_epoch - gbe <= 2)
            if last is not None or hot_freq or recent_b2 or recent_b1:
                promote = True
            else:
                _touched_once[k] = _epoch

        if promote:
            _touched_once.pop(k, None)
            _probation.pop(k, None)
            _protected[k] = None  # MRU
            _key_seg[k] = 'prot'
            # Expand protected slightly on clearly hot promotions
            if not _scan_mode and (_score(k) >= 1 or recent_b2):
                _increase_protected()
        else:
            # Refresh to MRU of probation
            if k in _probation:
                _probation.move_to_end(k, last=True)
            else:
                _probation[k] = None

    elif seg == 'prot':
        # Refresh recency in protected
        if k in _protected:
            _protected.move_to_end(k, last=True)
        else:
            # If somehow missing from the structure, reinsert into protected
            _protected[k] = None
            _key_seg[k] = 'prot'
        # Clear any stale two-touch marker
        _touched_once.pop(k, None)
    else:
        # Unknown key (shouldn't happen on hit). Refresh probation; do not auto-promote.
        _probation[k] = None
        _key_seg[k] = 'prob'
        _probation.move_to_end(k, last=True)

    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide segment placement using ghost history (segment-aware)
    g_prot_epoch = _ghost_protected.get(k)
    g_prob_epoch = _ghost_probation.get(k)
    recent_prot_ghost = (g_prot_epoch is not None) and (_epoch - g_prot_epoch <= 2)
    recent_prob_ghost = (g_prob_epoch is not None) and (_epoch - g_prob_epoch <= 2)
    incoming_score = _score(k)

    # Reset any existing placement
    if _key_seg.get(k) == 'prot':
        _protected.pop(k, None)
    else:
        _probation.pop(k, None)

    if _scan_mode:
        # Scan resistance: insert at probation LRU to minimize pollution,
        # require two-touch before promotion via update_after_hit.
        _probation[k] = None
        _probation.move_to_end(k, last=False)  # LRU side
        _key_seg[k] = 'prob'
    else:
        if recent_prot_ghost and incoming_score >= 2:
            # Re-admit into protected due to recent protected ghost and clear hotness
            _protected[k] = None
            _key_seg[k] = 'prot'
            _increase_protected()
        else:
            # Default admission into probation MRU
            _probation[k] = None
            _key_seg[k] = 'prob'
            _probation.move_to_end(k, last=True)
            if recent_prob_ghost:
                # A B1-like hit suggests we need more recency; bias slightly
                _decrease_protected()
                _inc(k)

    _rebalance(cache_snapshot)
=======
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide segment placement using ghost history (segment-aware)
    g_prot_epoch = _ghost_protected.get(k)
    g_prob_epoch = _ghost_probation.get(k)
    recent_prot_ghost = (g_prot_epoch is not None) and (_epoch - g_prot_epoch <= 3)
    recent_prob_ghost = (g_prob_epoch is not None) and (_epoch - g_prob_epoch <= 3)
    incoming_score = _score(k)

    # Reset any existing placement
    if _key_seg.get(k) == 'prot':
        _protected.pop(k, None)
    else:
        _probation.pop(k, None)

    # Admission guard: if incoming is colder than last victim, place at probation LRU
    guard_reject = False
    try:
        if _ADMISSION_GUARD and _last_victim_score > 0:
            boost = incoming_score + (1 if recent_prot_ghost else 0) + (1 if recent_prob_ghost else 0)
            if boost < _last_victim_score:
                guard_reject = True
    except Exception:
        guard_reject = False

    if _scan_mode:
        # Scan resistance: insert at probation LRU to minimize pollution,
        # require two-touch before promotion via update_after_hit.
        _probation[k] = None
        _probation.move_to_end(k, last=False)  # LRU side
        _key_seg[k] = 'prob'
    else:
        if recent_prot_ghost:
            # Re-admit into protected due to recent protected ghost
            _protected[k] = None
            _key_seg[k] = 'prot'
            _increase_protected()
            # Consume ghost entry
            _ghost_protected.pop(k, None)
        else:
            # Default admission into probation with position based on guard
            _probation[k] = None
            _key_seg[k] = 'prob'
            if guard_reject:
                _probation.move_to_end(k, last=False)  # LRU placement to shed cold items quickly
            else:
                _probation.move_to_end(k, last=True)   # MRU placement
            if recent_prob_ghost:
                # A B1-like hit suggests we need more recency; bias slightly and bump a bit of frequency
                _decrease_protected()
                _inc(k)
                _ghost_probation.pop(k, None)

    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    # Record into ghost according to the segment it was evicted from
    k = evicted_obj.key
    seg = _key_seg.get(k, None)
    # Store last victim score for potential future enhancements
    global _last_victim_score, _evict_prob_cnt, _evict_prot_cnt
    _last_victim_score = _score(k)

    if seg == 'prob':
        _ghost_probation[k] = _epoch
        _probation.pop(k, None)
        _evict_prob_cnt += 1
    elif seg == 'prot':
        _ghost_protected[k] = _epoch
        _protected.pop(k, None)
        _evict_prot_cnt += 1

    # Clean any stale two-touch markers
    _touched_once.pop(k, None)

    _key_seg.pop(k, None)

    # Trim ghost histories to bounded size
    limit = max(1, _GHOST_LIMIT_MULT * max(cache_snapshot.capacity, 1))
    while len(_ghost_probation) > limit:
        _ghost_probation.popitem(last=False)
    while len(_ghost_protected) > limit:
        _ghost_protected.popitem(last=False)

    # Adaptive protected tuning: if we evicted from probation but the incoming object is hotter,
    # increase protected to preserve hot items better.
    try:
        if seg == 'prob' and _score(obj.key) > _last_victim_score:
            _increase_protected()
    except Exception:
        pass

    # Eviction-mix adaptation over a short window
    try:
        total = _evict_prob_cnt + _evict_prot_cnt
        window = max(8, min(int(max(cache_snapshot.capacity, 1)), 128))
        if total >= window:
            if _evict_prot_cnt > _evict_prob_cnt:
                _decrease_protected()
            elif _evict_prob_cnt > _evict_prot_cnt:
                _increase_protected()
            _evict_prot_cnt = 0
            _evict_prob_cnt = 0
    except Exception:
        # Be conservative if anything goes wrong
        _evict_prot_cnt = 0
        _evict_prob_cnt = 0

    # After an eviction, ensure protected segment still respects target (it might shrink due to target change)
    _rebalance(cache_snapshot)
=======
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    # Record into ghost according to the segment it was evicted from
    k = evicted_obj.key
    seg = _key_seg.get(k, None)
    # Store last victim score for admission guard decisions
    global _last_victim_score, _evict_prob_cnt, _evict_prot_cnt
    _last_victim_score = _score(k)

    if seg == 'prob':
        _ghost_probation[k] = _epoch
        _probation.pop(k, None)
        _evict_prob_cnt += 1
    elif seg == 'prot':
        _ghost_protected[k] = _epoch
        _protected.pop(k, None)
        _evict_prot_cnt += 1
    else:
        # If unknown to metadata, classify as probation for ghost purposes
        _ghost_probation[k] = _epoch

    # Clean any stale two-touch markers
    _touched_once.pop(k, None)

    _key_seg.pop(k, None)

    # Trim ghost histories to bounded size
    limit = max(1, _GHOST_LIMIT_MULT * max(cache_snapshot.capacity, 1))
    while len(_ghost_probation) > limit:
        _ghost_probation.popitem(last=False)
    while len(_ghost_protected) > limit:
        _ghost_protected.popitem(last=False)

    # Adaptive protected tuning: if we evicted from probation but the incoming object is hotter,
    # increase protected to preserve hot items better.
    try:
        if seg == 'prob' and _score(obj.key) > _last_victim_score:
            _increase_protected()
    except Exception:
        pass

    # Eviction-mix adaptation over a short window
    try:
        total = _evict_prob_cnt + _evict_prot_cnt
        window = max(8, min(int(max(cache_snapshot.capacity, 1)), 128))
        if total >= window:
            if _evict_prot_cnt > _evict_prob_cnt:
                _decrease_protected()
            elif _evict_prob_cnt > _evict_prot_cnt:
                _increase_protected()
            _evict_prot_cnt = 0
            _evict_prob_cnt = 0
    except Exception:
        # Be conservative if anything goes wrong
        _evict_prot_cnt = 0
        _evict_prob_cnt = 0

    # After an eviction, ensure protected segment still respects target (it might shrink due to target change)
    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>