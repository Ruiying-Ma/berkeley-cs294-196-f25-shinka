<NAME>
twotouch_guard_and_balanced_protected
</NAME>

<DESCRIPTION>
I introduce a conservative two-touch promotion policy outside scan mode, reduce the default protected fraction, and make sampling and admission more balanced. The goals are:
- Avoid premature promotions that overfill protected and harm recency workloads.
- Strengthen scan resistance by gating promotions and inserting scans at probationâ€™s LRU.
- Improve victim choice by sampling more from protected when it dominates and biasing against evicting items hotter than the incoming object.
- Make admission simpler and less punitive: default to probation MRU, only place directly into protected when strongly indicated (fresh B2 ghost and hot), and remove the over-aggressive LRU placement based on last victim score which hurt recency traces.

These changes should reduce miss rates across diverse workloads by combining SLRU with lightweight TinyLFU-style admission and a 2Q-like two-touch gating. The protected fraction now starts lower (0.6) and adapts within [0.1, 0.9], preventing over-protection while still allowing adaptation.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
_PROTECTED_FRAC = 0.8        # target fraction of cache to allocate to protected segment
_ADAPT_STEP = 0.02           # step used to adjust protected fraction within [0.05, 0.95]
=======
_PROTECTED_FRAC = 0.6        # target fraction of cache to allocate to protected segment
_ADAPT_STEP = 0.02           # step used to adjust protected fraction within [0.1, 0.9]
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def _increase_protected():
    global _PROTECTED_FRAC
    _PROTECTED_FRAC = min(0.95, _PROTECTED_FRAC + _ADAPT_STEP)
=======
def _increase_protected():
    global _PROTECTED_FRAC
    _PROTECTED_FRAC = min(0.90, _PROTECTED_FRAC + _ADAPT_STEP)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def _decrease_protected():
    global _PROTECTED_FRAC
    _PROTECTED_FRAC = max(0.05, _PROTECTED_FRAC - _ADAPT_STEP)
=======
def _decrease_protected():
    global _PROTECTED_FRAC
    _PROTECTED_FRAC = max(0.10, _PROTECTED_FRAC - _ADAPT_STEP)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    # Keep metadata consistent and properly segmented before choosing a victim
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track key for scan detection unique density
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    # Clean up stale entries (if any)
    for k in list(_probation.keys()):
        if k not in cache_snapshot.cache:
            _probation.pop(k, None)
            _key_seg.pop(k, None)
    for k in list(_protected.keys()):
        if k not in cache_snapshot.cache:
            _protected.pop(k, None)
            _key_seg.pop(k, None)

    # If metadata is empty, fallback
    if not cache_snapshot.cache:
        return None

    # Adaptive sampling sizes
    prob_sample = _BASE_PROB_SAMPLE
    prot_sample = _BASE_PROT_SAMPLE
    if _scan_mode:
        prob_sample += 1
        prot_sample = max(1, prot_sample - 1)
    if len(_probation) > len(_protected) + 2:
        prob_sample += 1

    # Incoming-aware admission guard: avoid evicting hotter items if possible
    incoming_score = _score(obj.key)

    # Build candidate tuples from both segments' LRU sides
    candidates = []
    # Probation candidates
    pkeys = _sample_lru_keys(_probation, prob_sample)
    for idx, pk in enumerate(pkeys):
        if pk in cache_snapshot.cache:
            s = _score(pk)
            hotter = 1 if (_ADMISSION_GUARD and s > incoming_score) else 0
            segpref = 0  # probation preferred
            candidates.append((hotter, s, segpref, idx, pk))
    # Protected candidates
    tkeys = _sample_lru_keys(_protected, prot_sample)
    for idx, tk in enumerate(tkeys):
        if tk in cache_snapshot.cache:
            s = _score(tk)
            hotter = 1 if (_ADMISSION_GUARD and s > incoming_score) else 0
            segpref = 1  # protected less preferred
            candidates.append((hotter, s, segpref, idx, tk))

    if not candidates:
        # Fallback: pick any key from cache if metadata got desynced
        return next(iter(cache_snapshot.cache.keys()))

    # Choose coldest by (hotter_than_incoming, score, segment preference, recency)
    best = min(candidates)
    candid_obj_key = best[4]
    victim_from_protected = (_key_seg.get(candid_obj_key) == 'prot')

    # Adaptive tuning: if we are forced to evict from protected, reduce its target fraction slightly
    if victim_from_protected:
        _decrease_protected()

    return candid_obj_key
=======
def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    # Keep metadata consistent and properly segmented before choosing a victim
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track key for scan detection unique density
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    # Clean up stale entries (if any)
    for k in list(_probation.keys()):
        if k not in cache_snapshot.cache:
            _probation.pop(k, None)
            _key_seg.pop(k, None)
    for k in list(_protected.keys()):
        if k not in cache_snapshot.cache:
            _protected.pop(k, None)
            _key_seg.pop(k, None)

    # If metadata is empty, fallback
    if not cache_snapshot.cache:
        return None

    # Adaptive sampling sizes
    prob_sample = _BASE_PROB_SAMPLE
    prot_sample = _BASE_PROT_SAMPLE
    if _scan_mode:
        prob_sample += 1
        prot_sample = max(1, prot_sample - 1)
    if len(_probation) > len(_protected) + 2:
        prob_sample += 1
    if len(_protected) > len(_probation) + 2:
        prot_sample += 1

    # Incoming-aware admission guard: avoid evicting hotter items if possible
    incoming_score = _score(obj.key)

    # Build candidate tuples from both segments' LRU sides
    candidates = []
    # Probation candidates
    pkeys = _sample_lru_keys(_probation, prob_sample)
    for idx, pk in enumerate(pkeys):
        if pk in cache_snapshot.cache:
            s = _score(pk)
            hotter = 1 if (_ADMISSION_GUARD and s > incoming_score) else 0
            segpref = 0  # probation preferred
            candidates.append((hotter, s, segpref, idx, pk))
    # Protected candidates
    tkeys = _sample_lru_keys(_protected, prot_sample)
    for idx, tk in enumerate(tkeys):
        if tk in cache_snapshot.cache:
            s = _score(tk)
            hotter = 1 if (_ADMISSION_GUARD and s > incoming_score) else 0
            segpref = 1  # protected less preferred
            candidates.append((hotter, s, segpref, idx, tk))

    if not candidates:
        # Fallback: pick any key from cache if metadata got desynced
        return next(iter(cache_snapshot.cache.keys()))

    # Choose coldest by (hotter_than_incoming, score, segment preference, recency)
    best = min(candidates)
    candid_obj_key = best[4]
    victim_from_protected = (_key_seg.get(candid_obj_key) == 'prot')

    # Adaptive tuning: if we are forced to evict from protected, reduce its target fraction slightly
    if victim_from_protected:
        _decrease_protected()

    return candid_obj_key
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)

    if seg == 'prob':
        if _scan_mode:
            # Two-touch gating under scans: first hit refreshes probation,
            # second hit within a short epoch window promotes to protected.
            last = _touched_once.get(k)
            if last is not None and (_epoch - last) <= 1:
                _touched_once.pop(k, None)
                _probation.pop(k, None)
                _protected[k] = None  # MRU
                _key_seg[k] = 'prot'
            else:
                _touched_once[k] = _epoch
                # Refresh to MRU of probation
                if k in _probation:
                    _probation.move_to_end(k, last=True)
                else:
                    _probation[k] = None
                # Avoid immediate expansion of protected during scans
        else:
            # Promote to protected on first hit
            _probation.pop(k, None)
            _protected[k] = None  # inserted at MRU
            _key_seg[k] = 'prot'
            _increase_protected()  # hits in probation signal benefit from a larger protected segment
    elif seg == 'prot':
        # Refresh recency in protected
        if k in _protected:
            _protected.move_to_end(k, last=True)
        else:
            # If somehow missing from the structure, reinsert into protected
            _protected[k] = None
            _key_seg[k] = 'prot'
        # Clear any stale two-touch marker
        _touched_once.pop(k, None)
    else:
        # Unknown key (shouldn't happen on hit).
        # In scan mode, keep in probation with refresh; otherwise, promote.
        if _scan_mode:
            _probation[k] = None
            _key_seg[k] = 'prob'
            _probation.move_to_end(k, last=True)
        else:
            _probation[k] = None
            _key_seg[k] = 'prob'
            _probation.pop(k, None)
            _protected[k] = None
            _key_seg[k] = 'prot'
            _increase_protected()

    _rebalance(cache_snapshot)
=======
def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)

    if seg == 'prob':
        last = _touched_once.get(k)
        promote = False
        if _scan_mode:
            # Two-touch gating under scans: require two hits within a short window
            if last is not None and (_epoch - last) <= 1:
                promote = True
            else:
                _touched_once[k] = _epoch
        else:
            # Outside scans: two-touch OR clearly hot by frequency OR recent protected ghost
            hot_freq = (_score(k) >= 2)
            gpe = _ghost_protected.get(k)
            recent_b2 = (gpe is not None) and (_epoch - gpe <= 3)
            if last is not None or hot_freq or recent_b2:
                promote = True
            else:
                _touched_once[k] = _epoch

        if promote:
            _touched_once.pop(k, None)
            _probation.pop(k, None)
            _protected[k] = None  # MRU
            _key_seg[k] = 'prot'
            # Only expand protected on truly hot promotions
            if not _scan_mode and _score(k) >= 2:
                _increase_protected()
        else:
            # Refresh to MRU of probation
            if k in _probation:
                _probation.move_to_end(k, last=True)
            else:
                _probation[k] = None

    elif seg == 'prot':
        # Refresh recency in protected
        if k in _protected:
            _protected.move_to_end(k, last=True)
        else:
            # If somehow missing from the structure, reinsert into protected
            _protected[k] = None
            _key_seg[k] = 'prot'
        # Clear any stale two-touch marker
        _touched_once.pop(k, None)
    else:
        # Unknown key (shouldn't happen on hit). Refresh probation; do not auto-promote.
        _probation[k] = None
        _key_seg[k] = 'prob'
        _probation.move_to_end(k, last=True)

    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide segment placement using ghost history (segment-aware)
    g_prot_epoch = _ghost_protected.get(k)
    g_prob_epoch = _ghost_probation.get(k)
    recent_prot_ghost = (g_prot_epoch is not None) and (_epoch - g_prot_epoch <= 2)
    recent_prob_ghost = (g_prob_epoch is not None) and (_epoch - g_prob_epoch <= 2)
    incoming_score = _score(k)

    # Reset any existing placement
    if _key_seg.get(k) == 'prot':
        _protected.pop(k, None)
    else:
        _probation.pop(k, None)

    if _scan_mode:
        # Scan resistance: insert at probation LRU to minimize pollution,
        # require two-touch before promotion via update_after_hit.
        _probation[k] = None
        _probation.move_to_end(k, last=False)  # LRU side
        _key_seg[k] = 'prob'
    else:
        if recent_prot_ghost:
            # Re-admit into protected due to recent protected ghost hit
            _protected[k] = None
            _key_seg[k] = 'prot'
            _increase_protected()
        elif recent_prob_ghost:
            # A B1-like hit suggests we need more recency; bias towards probation and shrink protected a bit
            _decrease_protected()
            _probation[k] = None
            _key_seg[k] = 'prob'
            _probation.move_to_end(k, last=True)  # MRU in probation
            _inc(k)
        else:
            # Admission guard: if incoming is not hotter than last victim, insert cold at probation LRU
            if _ADMISSION_GUARD and incoming_score <= _last_victim_score:
                _probation[k] = None
                _key_seg[k] = 'prob'
                _probation.move_to_end(k, last=False)  # LRU side (deprioritize)
            elif incoming_score >= 2:
                # Strongly hot objects can be admitted protected
                _protected[k] = None
                _key_seg[k] = 'prot'
                _increase_protected()
            else:
                # Default: probation MRU
                _probation[k] = None
                _key_seg[k] = 'prob'
                _probation.move_to_end(k, last=True)

    _rebalance(cache_snapshot)
=======
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide segment placement using ghost history (segment-aware)
    g_prot_epoch = _ghost_protected.get(k)
    g_prob_epoch = _ghost_probation.get(k)
    recent_prot_ghost = (g_prot_epoch is not None) and (_epoch - g_prot_epoch <= 2)
    recent_prob_ghost = (g_prob_epoch is not None) and (_epoch - g_prob_epoch <= 2)
    incoming_score = _score(k)

    # Reset any existing placement
    if _key_seg.get(k) == 'prot':
        _protected.pop(k, None)
    else:
        _probation.pop(k, None)

    if _scan_mode:
        # Scan resistance: insert at probation LRU to minimize pollution,
        # require two-touch before promotion via update_after_hit.
        _probation[k] = None
        _probation.move_to_end(k, last=False)  # LRU side
        _key_seg[k] = 'prob'
    else:
        if recent_prot_ghost and incoming_score >= 2:
            # Re-admit into protected due to recent protected ghost and clear hotness
            _protected[k] = None
            _key_seg[k] = 'prot'
            _increase_protected()
        else:
            # Default admission into probation MRU
            _probation[k] = None
            _key_seg[k] = 'prob'
            _probation.move_to_end(k, last=True)
            if recent_prob_ghost:
                # A B1-like hit suggests we need more recency; bias slightly
                _decrease_protected()
                _inc(k)

    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>