<NAME>
two_touch_freshness_and_protected_sampling
</NAME>

<DESCRIPTION>
I introduce three synergistic improvements to reduce miss rate by better aligning promotions/demotions with observed reuse and by avoiding harmful evictions during scans:

1) Time-bounded two-touch promotion guided by freshness: I add a _first_touch_ts map and change update_after_hit and update_after_insert so that items from probation (T1) are promoted to protected (T2) only when they receive a second touch within a freshness window (proportional to cache capacity) during poor-locality/scan or when T1 is over target. If the second touch comes too late, the first-touch is reset and the item stays in T1 MRU. This curbs scan pollution and respects reuse distance.

2) Protected demotion via sampled LRFU with a small T2 floor: In _demote_protected_if_needed, instead of strict LRU demotion, I sample the first LRU entries from T2 and demote the coldest by (freq asc, timestamp asc). I also keep a small floor for T2 size, avoiding over-drainage under p swings. This preserves genuinely hot items in T2.

3) Safer eviction during scan/guard and stronger scan bias: In evict, cross-segment overrides are disabled during active scans or guard periods, and I avoid evicting from T2 when it is tiny. In update_after_insert, I also slightly strengthen the p decrease during scans/poor locality. For ghost readmission, I scale frequency seeding by freshness w and seed window timestamps for probation entries.

These changes make the algorithm more robust against scans while keeping hot working sets strongly protected, improving hit rates across mixed workloads.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# Fallback timestamp ledger and lightweight frequency
m_key_timestamp = dict()        # key -> last access time (for tie-breaking)
_freq = dict()                  # key -> small counter (saturating)
_last_age_tick = 0
=======
# Fallback timestamp ledger and lightweight frequency
m_key_timestamp = dict()        # key -> last access time (for tie-breaking)
_freq = dict()                  # key -> small counter (saturating)
_last_age_tick = 0
# Track when a key first touched/probation touch to enforce time-bounded two-touch
_first_touch_ts = dict()
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def _demote_protected_if_needed(cache_snapshot, avoid_key=None):
    """Keep T2 size within ARC target by demoting LRU entries to T1 MRU."""
    _ensure_capacity(cache_snapshot)
    t1_target = int(round(_p_target))
    t2_target = max(_cap_est - t1_target, 0)
    while len(_T2_protected) > t2_target:
        # LRU of T2
        lru = None
        for k in _lru_iter(_T2_protected):
            if k != avoid_key and k in cache_snapshot.cache:
                lru = k
                break
        if lru is None:
            break
        _T2_protected.pop(lru, None)
        _T1_probation[lru] = True  # demoted MRU in T1
=======
def _demote_protected_if_needed(cache_snapshot, avoid_key=None):
    """Keep T2 size within ARC target by demoting sampled cold entries to T1 MRU with a small T2 floor."""
    _ensure_capacity(cache_snapshot)
    cap = max(1, _cap_est)
    t1_target = int(round(_p_target))
    t2_target = max(_cap_est - t1_target, 0)
    # Keep a small protected floor so T2 doesn't drain completely on transient p swings
    floor_t2 = max(0, int(0.1 * cap))
    if t2_target < floor_t2:
        t2_target = floor_t2
    while len(_T2_protected) > t2_target:
        # Sample first few LRU entries and demote the coldest by (freq asc, timestamp asc)
        sample_n = 4
        cand = None
        best_sc = None
        cnt = 0
        for k in _lru_iter(_T2_protected):
            if k == avoid_key or k not in cache_snapshot.cache:
                continue
            sc = _score_key(k)
            if best_sc is None or sc < best_sc:
                best_sc = sc
                cand = k
            cnt += 1
            if cnt >= sample_n:
                break
        if cand is None:
            break
        _T2_protected.pop(cand, None)
        _T1_probation[cand] = True  # demoted MRU in T1
        # Start two-touch timer on demotion so it must prove itself again soon
        _first_touch_ts[cand] = cache_snapshot.access_count
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    '''
    Evict using ARC replace with dynamic sampling and scan bias:
    - Prefer T1 when |T1| > p or when upcoming key is in B2 and |T1| == p.
    - During scan window, always prefer T1 if non-empty.
    - Cross-segment override: pick the globally colder candidate by (freq, age) when reasonable.
    '''
    _ensure_capacity(cache_snapshot)

    t1_size = len(_T1_probation)
    t2_size = len(_T2_protected)
    x_in_b2 = (obj is not None) and (obj.key in _B2_ghost)
    choose_t1 = (t1_size >= 1) and ((x_in_b2 and t1_size == int(round(_p_target))) or (t1_size > _p_target))

    # Scan bias: keep evictions in probation when scanning
    if cache_snapshot.access_count <= _scan_until and t1_size > 0:
        choose_t1 = True

    # Adaptive sampling sizes based on pressure and scan
    cap = max(1, _cap_est)
    t1_pressure = (t1_size > _p_target + 0.1 * cap) or (cache_snapshot.access_count <= _scan_until)
    t2_pressure = (t2_size > (cap - int(round(_p_target)))) or False

    T1_SAMPLE = 1 if t1_pressure else 2
    if cache_snapshot.access_count <= _scan_until:
        T1_SAMPLE = 1
    T2_SAMPLE = 5 if t2_pressure else 3
    if _hit_ewma < 0.2:
        T2_SAMPLE = max(2, T2_SAMPLE - 1)

    # Sample candidates from both segments
    cand_t1 = _pick_from(_T1_probation, T1_SAMPLE, cache_snapshot) if t1_size > 0 else None
    cand_t2 = _pick_from(_T2_protected, T2_SAMPLE, cache_snapshot) if t2_size > 0 else None

    # Initial choice by ARC
    if choose_t1:
        victim_key = cand_t1 if cand_t1 is not None else cand_t2
    else:
        victim_key = cand_t2 if cand_t2 is not None else cand_t1

    # Cross-segment override: prefer globally colder by (freq asc, timestamp asc)
    if cand_t1 is not None and cand_t2 is not None:
        sc1 = _score_key(cand_t1)
        sc2 = _score_key(cand_t2)
        min_seg = max(1, int(0.3 * cap))
        # If ARC chose T1 but T2 candidate is strictly colder overall, and T2 has enough items, override
        if choose_t1 and (sc2 < sc1) and (len(_T2_protected) > min_seg):
            victim_key = cand_t2
        # If ARC chose T2 but T1 candidate is strictly colder overall, and T1 has enough items, override
        elif (not choose_t1) and (sc1 < sc2) and (len(_T1_probation) > min_seg):
            victim_key = cand_t1
        else:
            # Fall back to frequency-gap rule (margin may be zero)
            f1, f2 = sc1[0], sc2[0]
            if choose_t1 and (f2 + _CROSS_EVICT_FREQ_MARGIN < f1) and (len(_T2_protected) > min_seg):
                victim_key = cand_t2
            elif (not choose_t1) and (f1 + _CROSS_EVICT_FREQ_MARGIN < f2) and (len(_T1_probation) > min_seg):
                victim_key = cand_t1

    if victim_key is None:
        victim_key = _fallback_choose(cache_snapshot)
    return victim_key
=======
def evict(cache_snapshot, obj):
    '''
    Evict using ARC replace with dynamic sampling and scan/guard bias:
    - Prefer T1 when |T1| > p or when upcoming key is in B2 and |T1| == p.
    - During scan/guard window, always prefer T1 if non-empty and avoid cross-segment overrides.
    - Cross-segment override: pick the globally colder candidate by (freq, age) when reasonable.
    - Avoid evicting from a tiny protected set (keep a small protected floor).
    '''
    _ensure_capacity(cache_snapshot)

    t1_size = len(_T1_probation)
    t2_size = len(_T2_protected)
    x_in_b2 = (obj is not None) and (obj.key in _B2_ghost)
    p_int = int(round(_p_target))
    choose_t1 = (t1_size >= 1) and ((x_in_b2 and t1_size == p_int) or (t1_size > _p_target))

    cap = max(1, _cap_est)
    in_scan = cache_snapshot.access_count <= _scan_until
    in_guard = cache_snapshot.access_count <= _guard_until

    # Scan/guard bias: keep evictions in probation when scanning
    if (in_scan or in_guard) and t1_size > 0:
        choose_t1 = True

    # Avoid evicting from a tiny protected set
    prot_floor = int(0.1 * cap)
    if (not choose_t1) and t2_size <= prot_floor and t1_size > 0:
        choose_t1 = True

    # Adaptive sampling sizes based on pressure and scan
    t1_pressure = (t1_size > _p_target + 0.1 * cap) or in_scan
    t2_pressure = (t2_size > (cap - int(round(_p_target)))) or False

    T1_SAMPLE = 1 if t1_pressure else 2
    if in_scan:
        T1_SAMPLE = 1
    T2_SAMPLE = 5 if t2_pressure else 3
    if _hit_ewma < 0.2:
        T2_SAMPLE = max(2, T2_SAMPLE - 1)

    # Sample candidates from both segments
    cand_t1 = _pick_from(_T1_probation, T1_SAMPLE, cache_snapshot) if t1_size > 0 else None
    cand_t2 = _pick_from(_T2_protected, T2_SAMPLE, cache_snapshot) if t2_size > 0 else None

    # Initial choice by ARC
    if choose_t1:
        victim_key = cand_t1 if cand_t1 is not None else cand_t2
    else:
        victim_key = cand_t2 if cand_t2 is not None else cand_t1

    # Cross-segment override: prefer globally colder by (freq asc, timestamp asc), but not during scan/guard
    if (not in_scan) and (not in_guard) and cand_t1 is not None and cand_t2 is not None:
        sc1 = _score_key(cand_t1)
        sc2 = _score_key(cand_t2)
        min_seg = max(1, int(0.3 * cap))
        if choose_t1 and (sc2 < sc1) and (len(_T2_protected) > min_seg):
            victim_key = cand_t2
        elif (not choose_t1) and (sc1 < sc2) and (len(_T1_probation) > min_seg):
            victim_key = cand_t1
        else:
            f1, f2 = sc1[0], sc2[0]
            if choose_t1 and (f2 + _CROSS_EVICT_FREQ_MARGIN < f1) and (len(_T2_protected) > min_seg):
                victim_key = cand_t2
            elif (not choose_t1) and (f1 + _CROSS_EVICT_FREQ_MARGIN < f2) and (len(_T1_probation) > min_seg):
                victim_key = cand_t1

    if victim_key is None:
        victim_key = _fallback_choose(cache_snapshot)
    return victim_key
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    '''
    On hit:
    - Update EWMA and age frequencies.
    - Increment frequency (saturating).
    - Two-touch promotion from T1 when locality is poor (scan or low hit EWMA) or T1 is over target.
    - Otherwise: first hit in T1 promotes to T2.
    - Keep T2 within its ARC target via demotion.
    - Remove any ghost entries for this key.
    '''
    _ensure_capacity(cache_snapshot)
    _maybe_age(cache_snapshot)
    _update_activity(True, cache_snapshot)

    key = obj.key
    now = cache_snapshot.access_count
    m_key_timestamp[key] = now
    _freq[key] = min(_FREQ_MAX, _freq.get(key, 0) + 1)

    in_scan = now <= _scan_until
    t1_over = len(_T1_probation) > int(round(_p_target))
    poor_locality = (_hit_ewma < 0.2)

    if key in _T2_protected:
        _T2_protected.move_to_end(key, last=True)
    elif key in _T1_probation:
        require_two_touch = in_scan or t1_over or poor_locality
        if require_two_touch and _freq.get(key, 0) < 2:
            # Keep in T1 and move to MRU until proven by second touch
            _T1_probation.move_to_end(key, last=True)
        else:
            # Promote to protected
            _T1_probation.pop(key, None)
            _T2_protected[key] = True
    else:
        # Metadata miss: treat as hot and place in T2
        _T2_protected[key] = True

    _demote_protected_if_needed(cache_snapshot, avoid_key=key)

    # Ghost cleanup
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
=======
def update_after_hit(cache_snapshot, obj):
    '''
    On hit:
    - Update EWMA and age frequencies.
    - Increment frequency (saturating).
    - Two-touch promotion from T1 is time-bounded when locality is poor/scan or T1 is over target.
    - Otherwise: first hit in T1 promotes to T2.
    - Keep T2 within its ARC target via demotion.
    - Remove any ghost entries for this key.
    '''
    _ensure_capacity(cache_snapshot)
    _maybe_age(cache_snapshot)
    _update_activity(True, cache_snapshot)

    key = obj.key
    now = cache_snapshot.access_count
    prev_ts = m_key_timestamp.get(key, None)
    m_key_timestamp[key] = now
    _freq[key] = min(_FREQ_MAX, _freq.get(key, 0) + 1)

    fresh_window = max(1, int(_FRESH_WINDOW_RATIO * _cap_est))
    in_scan = now <= _scan_until
    t1_over = len(_T1_probation) > int(round(_p_target))
    poor_locality = (_hit_ewma < 0.2)
    require_two_touch = in_scan or t1_over or poor_locality

    if key in _T2_protected:
        _T2_protected.move_to_end(key, last=True)
        _first_touch_ts.pop(key, None)
    elif key in _T1_probation:
        if require_two_touch:
            first_ts = _first_touch_ts.get(key, None)
            if first_ts is not None and (now - first_ts) <= fresh_window:
                # Promote to protected on timely second touch
                _T1_probation.pop(key, None)
                _T2_protected[key] = True
                _first_touch_ts.pop(key, None)
            else:
                # Start/reset two-touch window and keep in T1 MRU
                _first_touch_ts[key] = now
                _T1_probation.move_to_end(key, last=True)
        else:
            # Immediate promotion in high-locality phases
            _T1_probation.pop(key, None)
            _T2_protected[key] = True
            _first_touch_ts.pop(key, None)
    else:
        # Metadata miss: treat as hot and place in T2
        _T2_protected[key] = True
        _first_touch_ts.pop(key, None)

    _demote_protected_if_needed(cache_snapshot, avoid_key=key)

    # Ghost cleanup
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    '''
    On miss and insert:
    - Update EWMA and age frequencies.
    - If key in ghosts: momentum-adjust p; fresh ghosts re-admit to T2 (seed freq), stale to T1.
    - Else: insert to T1; during guard/scan or poor locality, place at T1 LRU; gently lower p in these phases (with cooldown).
    '''
    _ensure_capacity(cache_snapshot)
    _maybe_age(cache_snapshot)
    _update_activity(False, cache_snapshot)

    key = obj.key
    now = cache_snapshot.access_count
    m_key_timestamp[key] = now

    in_b1 = key in _B1_ghost
    in_b2 = key in _B2_ghost

    fresh_window = max(1, int(_FRESH_WINDOW_RATIO * _cap_est))

    if in_b1 or in_b2:
        # Compute step based on opposing ghost sizes
        if in_b1:
            step = max(1.0, float(len(_B2_ghost)) / max(1.0, float(len(_B1_ghost))))
            ev_ts = _B1_ghost.get(key, None)
            age = (now - ev_ts) if isinstance(ev_ts, int) else (fresh_window + 1)
            fresh = age <= fresh_window
            _adjust_p(+1, step, now, freshness_scale=(1.2 if fresh else 1.0), force=True)
            _B1_ghost.pop(key, None)
            if fresh:
                # Admit to T2 as recently valuable
                _T2_protected[key] = True
                _freq[key] = max(3, min(_FREQ_MAX, _freq.get(key, 0) + 2))
                _demote_protected_if_needed(cache_snapshot, avoid_key=key)
            else:
                _T1_probation[key] = True
                _freq[key] = _freq.get(key, 0)
        else:
            step = max(1.0, float(len(_B1_ghost)) / max(1.0, float(len(_B2_ghost))))
            ev_ts = _B2_ghost.get(key, None)
            age = (now - ev_ts) if isinstance(ev_ts, int) else (fresh_window + 1)
            fresh = age <= fresh_window
            _adjust_p(-1, step, now, freshness_scale=(1.2 if fresh else 1.0), force=True)
            _B2_ghost.pop(key, None)
            if fresh:
                _T2_protected[key] = True
                _freq[key] = max(3, min(_FREQ_MAX, _freq.get(key, 0) + 2))
                _demote_protected_if_needed(cache_snapshot, avoid_key=key)
            else:
                _T1_probation[key] = True
                _freq[key] = _freq.get(key, 0)
    else:
        # New key: insert into T1
        _T1_probation[key] = True
        _freq[key] = _freq.get(key, 0)
        # Guard, scan and poor-locality handling: bias newcomer colder
        t1_over = len(_T1_probation) > int(round(_p_target))
        poor_locality = (_hit_ewma < 0.2)
        if (_last_victim_strength >= _VICTIM_GUARD_THRESH) or (now <= _scan_until) or poor_locality or t1_over:
            _T1_probation.move_to_end(key, last=False)
            # Gently lower p in scan or poor-locality phases to keep pressure in T1 (cooldowned)
            if (now <= _scan_until) or poor_locality:
                _adjust_p(-1, max(1.0, 0.05 * float(_cap_est)), now, force=False)

    # Avoid duplicates across structures
    if key in _T1_probation and key in _T2_protected:
        _T1_probation.pop(key, None)
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
=======
def update_after_insert(cache_snapshot, obj):
    '''
    On miss and insert:
    - Update EWMA and age frequencies.
    - If key in ghosts: momentum-adjust p; fresh ghosts re-admit to T2 (seed freq with freshness), stale to T1.
    - Else: insert to T1; during guard/scan or poor locality, place at T1 LRU; gently lower p in these phases (with cooldown).
    '''
    _ensure_capacity(cache_snapshot)
    _maybe_age(cache_snapshot)
    _update_activity(False, cache_snapshot)

    key = obj.key
    now = cache_snapshot.access_count
    m_key_timestamp[key] = now

    in_b1 = key in _B1_ghost
    in_b2 = key in _B2_ghost

    fresh_window = max(1, int(_FRESH_WINDOW_RATIO * _cap_est))

    if in_b1 or in_b2:
        # Compute step based on opposing ghost sizes
        if in_b1:
            step = max(1.0, float(len(_B2_ghost)) / max(1.0, float(len(_B1_ghost))))
            ev_ts = _B1_ghost.get(key, None)
            age = (now - ev_ts) if isinstance(ev_ts, int) else (fresh_window + 1)
            w = max(0.0, 1.0 - (age / float(fresh_window)))
            fresh = age <= fresh_window
            _adjust_p(+1, step, now, freshness_scale=(1.2 if fresh else 1.0), force=True)
            _B1_ghost.pop(key, None)
            if fresh:
                # Admit to T2 as recently valuable
                _T2_protected[key] = True
                _freq[key] = max(_freq.get(key, 0), min(_FREQ_MAX, 1 + int(round(4.0 * w))))
                _demote_protected_if_needed(cache_snapshot, avoid_key=key)
            else:
                _T1_probation[key] = True
                _first_touch_ts[key] = now
                _freq[key] = _freq.get(key, 0)
        else:
            step = max(1.0, float(len(_B1_ghost)) / max(1.0, float(len(_B2_ghost))))
            ev_ts = _B2_ghost.get(key, None)
            age = (now - ev_ts) if isinstance(ev_ts, int) else (fresh_window + 1)
            w = max(0.0, 1.0 - (age / float(fresh_window)))
            fresh = age <= fresh_window
            _adjust_p(-1, step, now, freshness_scale=(1.2 if fresh else 1.0), force=True)
            _B2_ghost.pop(key, None)
            if fresh:
                _T2_protected[key] = True
                _freq[key] = max(_freq.get(key, 0), min(_FREQ_MAX, 1 + int(round(4.0 * w))))
                _demote_protected_if_needed(cache_snapshot, avoid_key=key)
            else:
                _T1_probation[key] = True
                _first_touch_ts[key] = now
                _freq[key] = _freq.get(key, 0)
    else:
        # New key: insert into T1
        _T1_probation[key] = True
        _first_touch_ts[key] = now
        _freq[key] = _freq.get(key, 0)
        # Guard, scan and poor-locality handling: bias newcomer colder
        t1_over = len(_T1_probation) > int(round(_p_target))
        poor_locality = (_hit_ewma < 0.2)
        if (_last_victim_strength >= _VICTIM_GUARD_THRESH) or (now <= _scan_until) or poor_locality or t1_over:
            _T1_probation.move_to_end(key, last=False)
            # Gently lower p in scan or poor-locality phases to keep pressure in T1 (cooldowned)
            if (now <= _scan_until) or poor_locality:
                _adjust_p(-1, max(1.0, 0.08 * float(_cap_est)), now, force=False)

    # Avoid duplicates across structures
    if key in _T1_probation and key in _T2_protected:
        _T1_probation.pop(key, None)
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    After eviction:
    - Remove from resident segment and put into the appropriate ghost with timestamp.
    - Track victim strength and set a short admission guard when a strong T2 victim is evicted.
    - Clean frequency and timestamp entries.
    '''
    _ensure_capacity(cache_snapshot)
    key = evicted_obj.key
    now = cache_snapshot.access_count

    was_t1 = key in _T1_probation
    was_t2 = key in _T2_protected

    fval = _freq.get(key, 0)
    strength = float(fval) + (2.0 if was_t2 else 0.0)
    global _last_victim_strength, _guard_until
    _last_victim_strength = strength

    if was_t1:
        _T1_probation.pop(key, None)
        _B1_ghost[key] = now
    elif was_t2:
        _T2_protected.pop(key, None)
        _B2_ghost[key] = now
        if fval >= 2:
            _guard_until = now + max(1, _cap_est // 2)
    else:
        # Unknown residency; default to B1 ghost
        _B1_ghost[key] = now

    m_key_timestamp.pop(key, None)
    _freq.pop(key, None)
    _ghost_trim()
=======
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    After eviction:
    - Remove from resident segment and put into the appropriate ghost with timestamp.
    - Track victim strength and set a short admission guard when a strong T2 victim is evicted.
    - Clean frequency and timestamp entries.
    '''
    _ensure_capacity(cache_snapshot)
    key = evicted_obj.key
    now = cache_snapshot.access_count

    was_t1 = key in _T1_probation
    was_t2 = key in _T2_protected

    fval = _freq.get(key, 0)
    strength = float(fval) + (2.0 if was_t2 else 0.0)
    global _last_victim_strength, _guard_until
    _last_victim_strength = strength

    if was_t1:
        _T1_probation.pop(key, None)
        _B1_ghost[key] = now
    elif was_t2:
        _T2_protected.pop(key, None)
        _B2_ghost[key] = now
        if fval >= 2:
            _guard_until = now + max(1, _cap_est // 3)
    else:
        # Unknown residency; default to B1 ghost
        _B1_ghost[key] = now

    m_key_timestamp.pop(key, None)
    _first_touch_ts.pop(key, None)
    _freq.pop(key, None)
    _ghost_trim()
>>>>>>> REPLACE

</DIFF>