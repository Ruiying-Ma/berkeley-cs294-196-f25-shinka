<NAME>
demotion_aging_guard_arc
</NAME>

<DESCRIPTION>
We improve the ARC+SLRU policy by adding three synergistic mechanisms:
1) Frequency aging: introduce periodic halving of per-key frequencies to avoid stale bias; with a small saturating cap (FREQ_MAX=7).
2) Protected size enforcement: demote protected (T2) LRU entries back to probation (T1) when T2 exceeds its ARC target (cap âˆ’ round(p)); this stabilizes the replace decision and prevents protected bloat.
3) Guard window against scans: when a strong protected victim is evicted, open a short guard window during which new items are inserted at T1 LRU, curbing scan pollution. Admission guard also respects the last victim strength.

We update update_after_hit and update_after_insert to perform aging and to enforce T2 target via demotion. We update update_after_evict to set the guard window. These changes reduce miss rate by maintaining a healthy balance of recency/frequency, avoiding locking-in stale items, and damping scan pollution without heavy overhead.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# Lightweight per-key frequency counter (hit count)
_freq = dict()  # key -> int

# Admission guard based on last victim "strength"
_last_victim_strength = 0.0
_VICTIM_GUARD_THRESH = 2.0  # if last victim was strong, down-seed next newcomer
=======
# Lightweight per-key frequency counter (hit count)
_freq = dict()  # key -> int
_last_age_tick = 0          # last access_count when we aged frequencies
_FREQUENCY_MAX = 7          # saturating cap for per-key frequency

# Admission guard based on last victim "strength"
_last_victim_strength = 0.0
_VICTIM_GUARD_THRESH = 2.0  # if last victim was strong, down-seed next newcomer
_guard_until = 0            # time-bounded guard to resist scans after strong protected evictions
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def _ghost_trim():
    """Limit ghost lists to capacity each (ARC-style bound)."""
    global _B1_ghost, _B2_ghost
    # Trim oldest entries beyond capacity
    while len(_B1_ghost) > _cap_est:
        _B1_ghost.popitem(last=False)
    while len(_B2_ghost) > _cap_est:
        _B2_ghost.popitem(last=False)

def _fallback_choose(cache_snapshot):
=======
def _ghost_trim():
    """Limit ghost lists to capacity each (ARC-style bound)."""
    global _B1_ghost, _B2_ghost
    # Trim oldest entries beyond capacity
    while len(_B1_ghost) > _cap_est:
        _B1_ghost.popitem(last=False)
    while len(_B2_ghost) > _cap_est:
        _B2_ghost.popitem(last=False)

def _get_targets(cache_snapshot):
    """Compute ARC targets from p: T1 target = round(p), T2 target = cap - T1 target."""
    _ensure_capacity(cache_snapshot)
    t1_target = int(round(_p_target))
    t2_target = max(_cap_est - t1_target, 0)
    return t1_target, t2_target

def _demote_protected_if_needed(cache_snapshot, avoid_key=None):
    """Ensure protected size does not exceed its ARC target by demoting LRU to T1."""
    _, t2_target = _get_targets(cache_snapshot)
    # Demote until within target
    while len(_T2_protected) > t2_target:
        # Pick LRU from protected that is present in cache and is not avoid_key
        lru = None
        for k in _T2_protected.keys():
            if k == avoid_key:
                continue
            if k in cache_snapshot.cache:
                lru = k
                break
        if lru is None:
            break
        _T2_protected.pop(lru, None)
        _T1_probation[lru] = True  # demoted to probation MRU

def _maybe_age(cache_snapshot):
    """Periodically age frequencies to avoid stale bias."""
    global _last_age_tick
    _ensure_capacity(cache_snapshot)
    now = cache_snapshot.access_count
    if now - _last_age_tick >= max(1, _cap_est):
        for k in list(_freq.keys()):
            newf = _freq.get(k, 0) // 2
            if newf <= 0:
                _freq.pop(k, None)
            else:
                _freq[k] = newf
        _last_age_tick = now

def _fallback_choose(cache_snapshot):
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    '''
    Update metadata after cache hit.
    - If hit in probation (T1), promote to protected (T2).
    - If hit in protected, refresh recency.
    - Maintain fallback timestamp map and per-key frequency.
    '''
    _ensure_capacity(cache_snapshot)
    key = obj.key
    # Update fallback LRU timestamp
    m_key_timestamp[key] = cache_snapshot.access_count
    # Increment frequency counter
    _freq[key] = _freq.get(key, 0) + 1

    # If the key exists in our segments, update positions
    if key in _T2_protected:
        # Refresh to MRU
        _T2_protected.move_to_end(key, last=True)
    elif key in _T1_probation:
        # Promote from probation to protected
        _T1_probation.pop(key, None)
        _T2_protected[key] = True  # insert as MRU
    else:
        # Metadata miss: cache has it but we don't; treat as frequent and add to protected
        _T2_protected[key] = True
    # Touch ghosts cleanup if any stale
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
=======
def update_after_hit(cache_snapshot, obj):
    '''
    Update metadata after cache hit.
    - If hit in probation (T1), promote to protected (T2).
    - If hit in protected, refresh recency.
    - Maintain fallback timestamp map and per-key frequency (aged, saturating).
    - Keep protected within its ARC target via demotion.
    '''
    _ensure_capacity(cache_snapshot)
    _maybe_age(cache_snapshot)
    key = obj.key
    now = cache_snapshot.access_count
    # Update fallback LRU timestamp
    m_key_timestamp[key] = now
    # Increment frequency counter (saturating)
    _freq[key] = min(_FREQUENCY_MAX, _freq.get(key, 0) + 1)

    # If the key exists in our segments, update positions
    if key in _T2_protected:
        # Refresh to MRU
        _T2_protected.move_to_end(key, last=True)
    elif key in _T1_probation:
        # Promote from probation to protected
        _T1_probation.pop(key, None)
        _T2_protected[key] = True  # insert as MRU
    else:
        # Metadata miss: cache has it but we don't; treat as frequent and add to protected
        _T2_protected[key] = True

    # Enforce protected target by demoting its LRU if needed
    _demote_protected_if_needed(cache_snapshot, avoid_key=key)

    # Touch ghosts cleanup if any stale
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    '''
    Update metadata on insertion (cache miss path).
    - If the key is in ghost lists, adjust p (ARC adaptation) and insert into protected.
    - Otherwise insert into probation as MRU, unless guarded by a strong last victim (insert at LRU).
    - Maintain fallback timestamp map and seed frequency.
    '''
    _ensure_capacity(cache_snapshot)
    key = obj.key
    m_key_timestamp[key] = cache_snapshot.access_count

    in_b1 = key in _B1_ghost
    in_b2 = key in _B2_ghost

    if in_b1 or in_b2:
        # ARC adaptation of p (smooth float-based steps)
        global _p_target
        if in_b1:
            # Favor recency: increase p
            inc = max(1.0, float(len(_B2_ghost)) / max(1.0, float(len(_B1_ghost))))
            _p_target = min(float(_cap_est), _p_target + float(inc))
            _B1_ghost.pop(key, None)
        else:
            # Favor frequency: decrease p
            dec = max(1.0, float(len(_B1_ghost)) / max(1.0, float(len(_B2_ghost))))
            _p_target = max(0.0, _p_target - float(dec))
            _B2_ghost.pop(key, None)
        # Insert into protected (seen before, effectively 2nd touch)
        if key in _T1_probation:
            _T1_probation.pop(key, None)
        _T2_protected[key] = True
        # Seed frequency as at least 2 for re-referenced keys
        _freq[key] = max(_freq.get(key, 0) + 1, 2)
    else:
        # New to cache and ghosts: insert into probation (T1)
        if key in _T2_protected:
            # Rare desync; ensure consistency (shouldn't happen on miss)
            _T2_protected.move_to_end(key, last=True)
        else:
            _T1_probation[key] = True
            # Admission guard: if last victim was strong, place newcomer at LRU so it's evicted quickly
            if _last_victim_strength >= _VICTIM_GUARD_THRESH:
                _T1_probation.move_to_end(key, last=False)
        # Seed minimal frequency for new items
        _freq[key] = _freq.get(key, 0)

    # Avoid duplicates across structures
    if key in _T1_probation and key in _T2_protected:
        _T1_probation.pop(key, None)
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
=======
def update_after_insert(cache_snapshot, obj):
    '''
    Update metadata on insertion (cache miss path).
    - If the key is in ghost lists, adjust p (ARC adaptation) and insert into protected.
    - Otherwise insert into probation as MRU; if guarded, place at LRU to resist scans.
    - Maintain fallback timestamp map, age/saturate frequency, and enforce protected target.
    '''
    _ensure_capacity(cache_snapshot)
    _maybe_age(cache_snapshot)
    key = obj.key
    now = cache_snapshot.access_count
    m_key_timestamp[key] = now

    in_b1 = key in _B1_ghost
    in_b2 = key in _B2_ghost

    if in_b1 or in_b2:
        # ARC adaptation of p (smooth float-based steps)
        global _p_target
        if in_b1:
            # Favor recency: increase p
            inc = max(1.0, float(len(_B2_ghost)) / max(1.0, float(len(_B1_ghost))))
            _p_target = min(float(_cap_est), _p_target + float(inc))
            _B1_ghost.pop(key, None)
        else:
            # Favor frequency: decrease p
            dec = max(1.0, float(len(_B1_ghost)) / max(1.0, float(len(_B2_ghost))))
            _p_target = max(0.0, _p_target - float(dec))
            _B2_ghost.pop(key, None)
        # Insert into protected (seen before, effectively 2nd touch)
        if key in _T1_probation:
            _T1_probation.pop(key, None)
        _T2_protected[key] = True
        # Seed frequency as at least 2 for re-referenced keys (saturating)
        _freq[key] = min(_FREQUENCY_MAX, max(_freq.get(key, 0) + 1, 2))

        # Keep protected within its target by demoting its LRU if necessary
        _demote_protected_if_needed(cache_snapshot, avoid_key=key)
    else:
        # New to cache and ghosts: insert into probation (T1)
        if key in _T2_protected:
            # Rare desync; ensure consistency (shouldn't happen on miss)
            _T2_protected.move_to_end(key, last=True)
        else:
            _T1_probation[key] = True
            # Admission guard: if last victim was strong or within guard window, bias newcomer cold
            if (_last_victim_strength >= _VICTIM_GUARD_THRESH) or (now <= _guard_until):
                _T1_probation.move_to_end(key, last=False)
        # Seed minimal frequency for new items
        _freq[key] = min(_FREQUENCY_MAX, _freq.get(key, 0))

    # Avoid duplicates across structures
    if key in _T1_probation and key in _T2_protected:
        _T1_probation.pop(key, None)
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    Update metadata after eviction.
    - Remove victim from its resident segment.
    - Add to corresponding ghost list (B1 if from probation, B2 if from protected).
    - Track last victim strength for admission guard.
    - Trim ghost lists to capacity and clean timestamps/frequency.
    '''
    _ensure_capacity(cache_snapshot)
    victim_key = evicted_obj.key

    was_t1 = victim_key in _T1_probation
    was_t2 = victim_key in _T2_protected

    # Track strength of the evicted item before removing counters
    base_strength = float(_freq.get(victim_key, 0))
    if was_t2:
        base_strength += 2.0  # extra credit for protected residency
    global _last_victim_strength
    _last_victim_strength = base_strength

    # Remove from resident segments and add to ghosts
    if was_t1:
        _T1_probation.pop(victim_key, None)
        _B1_ghost[victim_key] = True  # insert as MRU
    elif was_t2:
        _T2_protected.pop(victim_key, None)
        _B2_ghost[victim_key] = True  # insert as MRU
    else:
        # Unknown location; put in B1 by default
        _B1_ghost[victim_key] = True

    # Remove fallback timestamp and frequency for evicted key
    if victim_key in m_key_timestamp:
        m_key_timestamp.pop(victim_key, None)
    if victim_key in _freq:
        _freq.pop(victim_key, None)

    # If inserting obj is accidentally in ghosts, let insert handle cleanup next
    _ghost_trim()
=======
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    Update metadata after eviction.
    - Remove victim from its resident segment.
    - Add to corresponding ghost list (B1 if from probation, B2 if from protected).
    - Track last victim strength and open a short guard window if a strong protected item was evicted.
    - Trim ghost lists to capacity and clean timestamps/frequency.
    '''
    _ensure_capacity(cache_snapshot)
    victim_key = evicted_obj.key
    now = cache_snapshot.access_count

    was_t1 = victim_key in _T1_probation
    was_t2 = victim_key in _T2_protected

    # Track strength of the evicted item before removing counters
    base_strength = float(_freq.get(victim_key, 0))
    if was_t2:
        base_strength += 2.0  # extra credit for protected residency
    global _last_victim_strength, _guard_until
    _last_victim_strength = base_strength

    # Remove from resident segments and add to ghosts
    if was_t1:
        _T1_probation.pop(victim_key, None)
        _B1_ghost[victim_key] = True  # insert as MRU
    elif was_t2:
        _T2_protected.pop(victim_key, None)
        _B2_ghost[victim_key] = True  # insert as MRU
        # If we had to evict a strong protected item, enable a short guard window
        if _freq.get(victim_key, 0) >= 2:
            _guard_until = now + max(1, _cap_est // 2)
    else:
        # Unknown location; put in B1 by default
        _B1_ghost[victim_key] = True

    # Remove fallback timestamp and frequency for evicted key
    if victim_key in m_key_timestamp:
        m_key_timestamp.pop(victim_key, None)
    if victim_key in _freq:
        _freq.pop(victim_key, None)

    # If inserting obj is accidentally in ghosts, let insert handle cleanup next
    _ghost_trim()
>>>>>>> REPLACE

</DIFF>