<NAME>
arc_ghost_bias_and_protected_immunity
</NAME>

<DESCRIPTION>
I reintroduce ARC-style ghost directional bias into evict() so the victim segment is chosen adaptively based on whether the incoming key was recently evicted from recency (B1) or protected (B2), with a freshness-weighted signal. This improves replacement decisions under changing locality. I also add a short immunity window for freshly promoted-to-protected keys, preventing them from immediate eviction (ping-pong) and reducing thrash.

Concretely:
- Add a small “no_evict_until” map and IMMUNITY_EPOCHS. When a key is promoted/admitted to protected, it gains short-term immunity from eviction.
- In evict(), skip protected candidates that are still immune; if ghost signals indicate we should free space from a specific segment, honor that first with a small sample and minimum-score victim.
- In update_after_hit() and update_after_insert(), when a key is promoted to protected, set its immunity expiry so it isn’t instantly evicted.
- In update_after_evict(), clear immunity for the evicted victim.

This keeps hot/promoted items stable long enough to pay dividends while remaining scan-resistant and responsive via ghost-driven adaptation. The changes are minimal and integrated with the existing metadata and decay logic.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# Stats to adapt protected in corner cases
_evict_prob_cnt = 0
_evict_prot_cnt = 0

# Freshness window (in epochs) derived from ghost reuse distances
_fresh_epoch_win = 1
=======
# Stats to adapt protected in corner cases
_evict_prob_cnt = 0
_evict_prot_cnt = 0

# Freshness window (in epochs) derived from ghost reuse distances
_fresh_epoch_win = 1
# Immunity for freshly protected keys to prevent ping-pong demotions/evictions
_no_evict_until = {}     # key -> epoch when immunity expires
_IMMUNITY_EPOCHS = 1
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    """
    Choose an eviction victim key to make space for obj.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track unique for scan detection
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    if not cache_snapshot.cache:
        return None

    incoming_score = _score(obj.key)
    hot_thr = _hot_thr(cache_snapshot)

    # Strong scan guard: evict from probation first, then window; avoid protected
    if _scan_mode:
        # Probation LRU preferred in scans to keep T2 intact
        for k in _sample_lru_keys(_prob, 1):
            if k in cache_snapshot.cache:
                return k
        # Then window LRU
        for k in _sample_lru_keys(_win, 1):
            if k in cache_snapshot.cache:
                return k
        # Fall back to protected LRU if no alternative
        for k in _sample_lru_keys(_prot, 1):
            if k in cache_snapshot.cache:
                return k

    candidates = []
    # Gather LRU-side samples from segments
    for idx, k in enumerate(_sample_lru_keys(_win, _S_WIN)):
        if k in cache_snapshot.cache:
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 0  # window preferred
            candidates.append((hotter, shield, s, seg_rank, idx, k))
    for idx, k in enumerate(_sample_lru_keys(_prob, _S_PROB)):
        if k in cache_snapshot.cache:
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 1
            candidates.append((hotter, shield, s, seg_rank, idx, k))
    for idx, k in enumerate(_sample_lru_keys(_prot, _S_PROT)):
        if k in cache_snapshot.cache:
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 2  # protected least preferred
            candidates.append((hotter, shield, s, seg_rank, idx, k))

    if not candidates:
        # fallback
        return next(iter(cache_snapshot.cache.keys()))

    # Prefer victims from window/probation when available; otherwise allow protected
    non_prot = [c for c in candidates if c[3] < 2]
    pool = non_prot if non_prot else candidates

    # Select by: not hotter than incoming, not shielded hot, low score, prefer window/prob, older index
    hotter, shield, s, seg_rank, idx, victim = min(pool)
    if _key_seg.get(victim) == 'prot':
        global _evict_prot_cnt
        _evict_prot_cnt += 1
    else:
        global _evict_prob_cnt
        _evict_prob_cnt += 1
    return victim
=======
def evict(cache_snapshot, obj):
    """
    Choose an eviction victim key to make space for obj.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track unique for scan detection
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    if not cache_snapshot.cache:
        return None

    incoming_score = _score(obj.key)
    hot_thr = _hot_thr(cache_snapshot)

    # Strong scan guard: evict from probation first, then window; avoid protected
    if _scan_mode:
        # Probation LRU preferred in scans to keep T2 intact
        for k in _sample_lru_keys(_prob, 1):
            if k in cache_snapshot.cache:
                return k
        # Then window LRU
        for k in _sample_lru_keys(_win, 1):
            if k in cache_snapshot.cache:
                return k
        # Fall back to protected LRU if no alternative
        for k in _sample_lru_keys(_prot, 1):
            if k in cache_snapshot.cache:
                return k

    # ARC-style directional replacement based on ghost hits (freshness-weighted)
    try:
        g1 = _B1.get(obj.key)
        g2 = _B2.get(obj.key)
        touch_win = max(1, int(_fresh_epoch_win))
        w1 = max(0.0, 1.0 - (float(_epoch - g1) / float(touch_win))) if g1 is not None else 0.0
        w2 = max(0.0, 1.0 - (float(_epoch - g2) / float(touch_win))) if g2 is not None else 0.0

        # Fresh B1 signal -> free from protected first (skip immunity), pick coldest among a few
        if w1 >= 0.5 and _prot:
            sample = _sample_lru_keys(_prot, max(1, _S_PROT + 1))
            best = None
            best_t = None  # (score, idx)
            for idx, k in enumerate(sample):
                if k in cache_snapshot.cache and _no_evict_until.get(k, -1) <= _epoch:
                    t = (_score(k), idx)
                    if best_t is None or t < best_t:
                        best_t = t
                        best = k
            if best is not None:
                global _evict_prot_cnt
                _evict_prot_cnt += 1
                return best

        # Fresh B2 signal -> free from recency side (probation then window)
        if w2 >= 0.5 and (_prob or _win):
            for k in _sample_lru_keys(_prob, max(1, _S_PROB)):
                if k in cache_snapshot.cache:
                    global _evict_prob_cnt
                    _evict_prob_cnt += 1
                    return k
            for k in _sample_lru_keys(_win, max(1, _S_WIN)):
                if k in cache_snapshot.cache:
                    _evict_prob_cnt += 1
                    return k
    except Exception:
        pass

    candidates = []
    # Gather LRU-side samples from segments
    for idx, k in enumerate(_sample_lru_keys(_win, _S_WIN)):
        if k in cache_snapshot.cache:
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 0  # window preferred
            candidates.append((hotter, shield, s, seg_rank, idx, k))
    for idx, k in enumerate(_sample_lru_keys(_prob, _S_PROB)):
        if k in cache_snapshot.cache:
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 1
            candidates.append((hotter, shield, s, seg_rank, idx, k))
    for idx, k in enumerate(_sample_lru_keys(_prot, _S_PROT)):
        if k in cache_snapshot.cache:
            # Skip freshly protected items with active immunity
            if _no_evict_until.get(k, -1) > _epoch:
                continue
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 2  # protected least preferred
            candidates.append((hotter, shield, s, seg_rank, idx, k))

    if not candidates:
        # If immunity filtered out all protected candidates, fall back to strict LRU across segments
        for od in (_prob, _win, _prot):
            for k in _sample_lru_keys(od, 1):
                if k in cache_snapshot.cache:
                    return k
        # ultimate fallback
        return next(iter(cache_snapshot.cache.keys()))

    # Prefer victims from window/probation when available; otherwise allow protected
    non_prot = [c for c in candidates if c[3] < 2]
    pool = non_prot if non_prot else candidates

    # Select by: not hotter than incoming, not shielded hot, low score, prefer window/prob, older index
    hotter, shield, s, seg_rank, idx, victim = min(pool)
    if _key_seg.get(victim) == 'prot':
        global _evict_prot_cnt
        _evict_prot_cnt += 1
    else:
        global _evict_prob_cnt
        _evict_prob_cnt += 1
    return victim
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    """
    Update metadata after a cache hit.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)
    hot_thr = _hot_thr(cache_snapshot)
    # Time-bounded two-touch window in epochs
    touch_win = max(1, int(_fresh_epoch_win))

    if seg == 'win':
        last = _two_touch.get(k)
        if last is not None and (_epoch - last) <= touch_win:
            _two_touch.pop(k, None)
            _place(k, 'prot', mru=True)  # two-touch promotion
        else:
            # late second touch resets frequency to a minimal seed
            _two_touch[k] = _epoch
            _freq[k] = (max(1, _score(k)), _epoch)
            # refresh within window
            if k in _win:
                _win.move_to_end(k, last=True)
            else:
                _place(k, 'win', mru=True)
    elif seg == 'prob':
        if _scan_mode:
            # require two-touch in probation during scans
            last = _two_touch.get(k)
            if last is not None and (_epoch - last) <= touch_win:
                _two_touch.pop(k, None)
                _place(k, 'prot', mru=True)
            else:
                _two_touch[k] = _epoch
                if k in _prob:
                    _prob.move_to_end(k, last=True)
        else:
            # Outside scans: promote if hot enough or two-touch within window
            if _score(k) >= hot_thr:
                _place(k, 'prot', mru=True)
            else:
                last = _two_touch.get(k)
                if last is not None and (_epoch - last) <= touch_win:
                    _two_touch.pop(k, None)
                    _place(k, 'prot', mru=True)
                else:
                    # late second touch: reset to a small seed and keep in probation MRU
                    _two_touch[k] = _epoch
                    _freq[k] = (max(1, _score(k)), _epoch)
                    if k in _prob:
                        _prob.move_to_end(k, last=True)
                    else:
                        _place(k, 'prob', mru=True)
    elif seg == 'prot':
        # refresh protected
        if k in _prot:
            _prot.move_to_end(k, last=True)
        else:
            _place(k, 'prot', mru=True)
        _two_touch.pop(k, None)
    else:
        # unknown key: place to window
        _place(k, 'win', mru=True)

    _rebalance(cache_snapshot)
=======
def update_after_hit(cache_snapshot, obj):
    """
    Update metadata after a cache hit.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)
    hot_thr = _hot_thr(cache_snapshot)
    # Time-bounded two-touch window in epochs
    touch_win = max(1, int(_fresh_epoch_win))
    # Immunity window for newly protected entries
    imm_ext = max(1, min(2, int(_fresh_epoch_win)))

    if seg == 'win':
        last = _two_touch.get(k)
        if last is not None and (_epoch - last) <= touch_win:
            _two_touch.pop(k, None)
            _place(k, 'prot', mru=True)  # two-touch promotion
            _no_evict_until[k] = _epoch + imm_ext
        else:
            # late second touch resets frequency to a minimal seed
            _two_touch[k] = _epoch
            _freq[k] = (max(1, _score(k)), _epoch)
            # refresh within window
            if k in _win:
                _win.move_to_end(k, last=True)
            else:
                _place(k, 'win', mru=True)
    elif seg == 'prob':
        if _scan_mode:
            # require two-touch in probation during scans
            last = _two_touch.get(k)
            if last is not None and (_epoch - last) <= touch_win:
                _two_touch.pop(k, None)
                _place(k, 'prot', mru=True)
                _no_evict_until[k] = _epoch + imm_ext
            else:
                _two_touch[k] = _epoch
                if k in _prob:
                    _prob.move_to_end(k, last=True)
        else:
            # Outside scans: promote if hot enough or two-touch within window
            if _score(k) >= hot_thr:
                _place(k, 'prot', mru=True)
                _no_evict_until[k] = _epoch + imm_ext
            else:
                last = _two_touch.get(k)
                if last is not None and (_epoch - last) <= touch_win:
                    _two_touch.pop(k, None)
                    _place(k, 'prot', mru=True)
                    _no_evict_until[k] = _epoch + imm_ext
                else:
                    # late second touch: reset to a small seed and keep in probation MRU
                    _two_touch[k] = _epoch
                    _freq[k] = (max(1, _score(k)), _epoch)
                    if k in _prob:
                        _prob.move_to_end(k, last=True)
                    else:
                        _place(k, 'prob', mru=True)
    elif seg == 'prot':
        # refresh protected
        if k in _prot:
            _prot.move_to_end(k, last=True)
        else:
            _place(k, 'prot', mru=True)
        _two_touch.pop(k, None)
        # Do not extend immunity on every hit to avoid over-shielding
    else:
        # unknown key: place to window
        _place(k, 'win', mru=True)

    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    """
    Update metadata right after inserting a new object.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide placement with ghost awareness and freshness weighting
    g1 = _B1.get(k)
    g2 = _B2.get(k)
    age1 = (_epoch - g1) if g1 is not None else None
    age2 = (_epoch - g2) if g2 is not None else None
    touch_win = max(1, int(_fresh_epoch_win))

    w1 = max(0.0, 1.0 - (float(age1) / float(touch_win))) if age1 is not None else 0.0
    w2 = max(0.0, 1.0 - (float(age2) / float(touch_win))) if age2 is not None else 0.0

    # Seed frequency on readmission
    if w1 > 0 or w2 > 0:
        seed = 1 + int(round(4.0 * max(w1, w2)))
        c, e = _freq.get(k, (0, _epoch))
        _freq[k] = (max(c, seed), _epoch)

    incoming_score = _score(k)

    if _scan_mode:
        # Strong scan resistance: keep scans in window LRU so window absorbs churn
        _place(k, 'win', mru=False)
    else:
        if g2 is not None:
            # Protected ghost readmission: freshness-weighted
            if w2 >= 0.5:
                _place(k, 'prot', mru=True)
            else:
                _place(k, 'prob', mru=True)
        elif g1 is not None:
            # Recency ghost readmission
            if w1 >= 0.5:
                _place(k, 'prot', mru=True)
            else:
                _place(k, 'prob', mru=True)
        else:
            # Tiny admission guard: if colder than last victim, insert at window LRU; else window MRU
            if incoming_score < _last_victim_score:
                _place(k, 'win', mru=False)
            else:
                _place(k, 'win', mru=True)

    _rebalance(cache_snapshot)
=======
def update_after_insert(cache_snapshot, obj):
    """
    Update metadata right after inserting a new object.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide placement with ghost awareness and freshness weighting
    g1 = _B1.get(k)
    g2 = _B2.get(k)
    age1 = (_epoch - g1) if g1 is not None else None
    age2 = (_epoch - g2) if g2 is not None else None
    touch_win = max(1, int(_fresh_epoch_win))

    w1 = max(0.0, 1.0 - (float(age1) / float(touch_win))) if age1 is not None else 0.0
    w2 = max(0.0, 1.0 - (float(age2) / float(touch_win))) if age2 is not None else 0.0

    # Seed frequency on readmission
    if w1 > 0 or w2 > 0:
        seed = 1 + int(round(4.0 * max(w1, w2)))
        c, e = _freq.get(k, (0, _epoch))
        _freq[k] = (max(c, seed), _epoch)

    incoming_score = _score(k)
    imm_ext = max(1, min(2, int(_fresh_epoch_win)))

    if _scan_mode:
        # Strong scan resistance: keep scans in window LRU so window absorbs churn
        _place(k, 'win', mru=False)
    else:
        if g2 is not None:
            # Protected ghost readmission: freshness-weighted
            if w2 >= 0.5:
                _place(k, 'prot', mru=True)
                _no_evict_until[k] = _epoch + imm_ext
            else:
                _place(k, 'prob', mru=True)
        elif g1 is not None:
            # Recency ghost readmission
            if w1 >= 0.5:
                _place(k, 'prot', mru=True)
                _no_evict_until[k] = _epoch + imm_ext
            else:
                _place(k, 'prob', mru=True)
        else:
            # Tiny admission guard: if colder than last victim, insert at window LRU; else window MRU
            if incoming_score < _last_victim_score:
                _place(k, 'win', mru=False)
            else:
                _place(k, 'win', mru=True)

    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_evict(cache_snapshot, obj, evicted_obj):
    """
    Update metadata after evicting a victim.
    """
    _maybe_age(cache_snapshot)

    victim_key = evicted_obj.key
    seg = _key_seg.get(victim_key, None)

    # record victim score for admission guidance (if used later)
    global _last_victim_score
    _last_victim_score = _score(victim_key)

    # Ghost recording
    if seg == 'prot':
        _B2[victim_key] = _epoch
        _prot.pop(victim_key, None)
        global _evict_prot_cnt
        _evict_prot_cnt += 1
    else:
        # Treat window/prob evictions as B1
        _B1[victim_key] = _epoch
        _win.pop(victim_key, None)
        _prob.pop(victim_key, None)
        global _evict_prob_cnt
        _evict_prob_cnt += 1

    _two_touch.pop(victim_key, None)
    _key_seg.pop(victim_key, None)

    # Ghost bound
    limit = max(1, _GHOST_LIMIT_MULT * max(cache_snapshot.capacity, 1))
    while len(_B1) > limit:
        _B1.popitem(last=False)
    while len(_B2) > limit:
        _B2.popitem(last=False)

    # ARC-like dynamic window tuning based on incoming object's presence in ghosts, freshness-weighted
    try:
        key_in = obj.key
        step = _ADAPT_STEP
        touch_win = max(1, int(_fresh_epoch_win))
        if key_in in _B1:
            age = max(0, _epoch - _B1.get(key_in, _epoch))
            w = max(0.0, 1.0 - (age / float(touch_win)))
            mult = (1.0 + 2.0 * w) * (0.5 if _scan_mode else 1.0)  # damp during scans
            _adj = step * mult
            # increase window
            global _WIN_FRAC
            _WIN_FRAC = min(_MAX_WIN, _WIN_FRAC + _adj)
        elif key_in in _B2:
            age = max(0, _epoch - _B2.get(key_in, _epoch))
            w = max(0.0, 1.0 - (age / float(touch_win)))
            mult = (1.0 + 2.0 * w) * (1.2 if _scan_mode else 1.0)  # amplify decrease during scans
            _adj = step * mult
            _WIN_FRAC = max(_MIN_WIN, _WIN_FRAC - _adj)
    except Exception:
        pass

    # Occasional mix-based nudge to protected ratio to avoid prolonged protected evictions
    try:
        total = _evict_prob_cnt + _evict_prot_cnt
        window = max(8, min(int(max(cache_snapshot.capacity, 1)), 128))
        if total >= window:
            if _evict_prot_cnt > _evict_prob_cnt:
                # reduce protected pressure by slightly lowering PROT share
                global _PROT_FRAC
                _PROT_FRAC = max(0.50, _PROT_FRAC - 0.02)
            elif _evict_prob_cnt > _evict_prot_cnt:
                _PROT_FRAC = min(0.85, _PROT_FRAC + 0.02)
            _evict_prot_cnt = 0
            _evict_prob_cnt = 0
    except Exception:
        _evict_prot_cnt = 0
        _evict_prob_cnt = 0

    _rebalance(cache_snapshot)
=======
def update_after_evict(cache_snapshot, obj, evicted_obj):
    """
    Update metadata after evicting a victim.
    """
    _maybe_age(cache_snapshot)

    victim_key = evicted_obj.key
    seg = _key_seg.get(victim_key, None)

    # record victim score for admission guidance (if used later)
    global _last_victim_score
    _last_victim_score = _score(victim_key)

    # Ghost recording
    if seg == 'prot':
        _B2[victim_key] = _epoch
        _prot.pop(victim_key, None)
        global _evict_prot_cnt
        _evict_prot_cnt += 1
    else:
        # Treat window/prob evictions as B1
        _B1[victim_key] = _epoch
        _win.pop(victim_key, None)
        _prob.pop(victim_key, None)
        global _evict_prob_cnt
        _evict_prob_cnt += 1

    # Clear auxiliary metadata
    _two_touch.pop(victim_key, None)
    _no_evict_until.pop(victim_key, None)
    _key_seg.pop(victim_key, None)

    # Ghost bound
    limit = max(1, _GHOST_LIMIT_MULT * max(cache_snapshot.capacity, 1))
    while len(_B1) > limit:
        _B1.popitem(last=False)
    while len(_B2) > limit:
        _B2.popitem(last=False)

    # ARC-like dynamic window tuning based on incoming object's presence in ghosts, freshness-weighted
    try:
        key_in = obj.key
        step = _ADAPT_STEP
        touch_win = max(1, int(_fresh_epoch_win))
        if key_in in _B1:
            age = max(0, _epoch - _B1.get(key_in, _epoch))
            w = max(0.0, 1.0 - (age / float(touch_win)))
            mult = (1.0 + 2.0 * w) * (0.5 if _scan_mode else 1.0)  # damp during scans
            _adj = step * mult
            # increase window
            global _WIN_FRAC
            _WIN_FRAC = min(_MAX_WIN, _WIN_FRAC + _adj)
        elif key_in in _B2:
            age = max(0, _epoch - _B2.get(key_in, _epoch))
            w = max(0.0, 1.0 - (age / float(touch_win)))
            mult = (1.0 + 2.0 * w) * (1.2 if _scan_mode else 1.0)  # amplify decrease during scans
            _adj = step * mult
            _WIN_FRAC = max(_MIN_WIN, _WIN_FRAC - _adj)
    except Exception:
        pass

    # Occasional mix-based nudge to protected ratio to avoid prolonged protected evictions
    try:
        total = _evict_prob_cnt + _evict_prot_cnt
        window = max(8, min(int(max(cache_snapshot.capacity, 1)), 128))
        if total >= window:
            if _evict_prot_cnt > _evict_prob_cnt:
                # reduce protected pressure by slightly lowering PROT share
                global _PROT_FRAC
                _PROT_FRAC = max(0.50, _PROT_FRAC - 0.02)
            elif _evict_prob_cnt > _evict_prot_cnt:
                _PROT_FRAC = min(0.85, _PROT_FRAC + 0.02)
            _evict_prot_cnt = 0
            _evict_prob_cnt = 0
    except Exception:
        _evict_prot_cnt = 0
        _evict_prob_cnt = 0

    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>