<NAME>
ghost_directed_evict_with_protected_immunity
</NAME>

<DESCRIPTION>
I introduce two complementary improvements to reduce miss rates:

1) Ghost-directed replacement in evict: When the incoming key appears in recent ghosts, we bias replacement toward the opposite segment (ARC-style). Fresh B1 (recency) ghosts push eviction from protected; fresh B2 ghosts push eviction from probation/window. This targets space where pressure is most likely to help re-reference and reduces wrong-segment victims.

2) Protected immunity window: On promotions to protected (T2) or fresh ghost readmissions admitted to T2, we grant a short demotion/eviction immunity tied to the dynamically learned ghost freshness window. Demotion respects this immunity using a sampled LRFU demoter that avoids immune entries and prefers genuinely cold tails. Eviction sampling also avoids immune protected keys when alternatives are available. This stabilizes hot items against premature churn, improving hit rates especially during phase changes.

Additionally, I:
- Slightly increase sampling breadth (S_PROB, S_PROT) for better victim selection quality.
- Use the ghost-driven freshness window in two-touch and immunity duration.
- Keep scan resistance logic intact, preferring probation/window victims during scans.

These changes align with well-known effects from ARC/SLRU/TinyLFU hybrids: avoid thrashing hot protected content, steer replacement using ghost feedback, and promote with a grace period to lock in locality. The code changes are minimal and consistent with existing metadata.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# Sampling parameters for victim selection
_S_WIN = 2
_S_PROB = 4
_S_PROT = 2

# Stats to adapt protected in corner cases
_evict_prob_cnt = 0
_evict_prot_cnt = 0

# Freshness window (in epochs) derived from ghost reuse distances
_fresh_epoch_win = 1
=======
# Sampling parameters for victim selection
_S_WIN = 2
_S_PROB = 6
_S_PROT = 3

# Stats to adapt protected in corner cases
_evict_prob_cnt = 0
_evict_prot_cnt = 0

# Demotion immunity for recently promoted/readmitted protected entries
_no_demote_until = {}   # key -> epoch threshold; while _epoch < threshold, avoid demoting/evicting from protected

# Freshness window (in epochs) derived from ghost reuse distances
_fresh_epoch_win = 1
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def _safe_remove_from_all(k):
    _win.pop(k, None)
    _prob.pop(k, None)
    _prot.pop(k, None)
    _key_seg.pop(k, None)
    _two_touch.pop(k, None)
=======
def _safe_remove_from_all(k):
    _win.pop(k, None)
    _prob.pop(k, None)
    _prot.pop(k, None)
    _key_seg.pop(k, None)
    _two_touch.pop(k, None)
    _no_demote_until.pop(k, None)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def _demote_protected_once():
    """Demote the coldest among first few LRU entries from protected to probation."""
    if not _prot:
        return False
    # Sample first few from protected LRU side
    sample = []
    it = iter(_prot.keys())
    for idx in range(4):
        try:
            k = next(it)
            sample.append((k, idx))
        except StopIteration:
            break
    if not sample:
        return False
    # Choose coldest by (score asc, older first)
    cand = min((( _score(k), idx, k) for (k, idx) in sample))
    _, _, victim = cand
    # Demote victim to probation MRU
    _prot.pop(victim, None)
    _prob[victim] = None
    _key_seg[victim] = 'prob'
    return True
=======
def _demote_protected_once():
    """Demote the coldest among first few LRU entries from protected to probation, honoring immunity."""
    if not _prot:
        return False
    # Sample first few from protected LRU side
    sample = []
    it = iter(_prot.keys())
    for idx in range(5):
        try:
            k = next(it)
            sample.append((k, idx))
        except StopIteration:
            break
    if not sample:
        return False
    # Choose by (immune_flag, score asc, older first)
    best = None
    best_t = None
    for (k, idx) in sample:
        immune_flag = 1 if _no_demote_until.get(k, 0) > _epoch else 0
        t = (immune_flag, _score(k), idx, k)
        if best_t is None or t < best_t:
            best_t = t
            best = k
    victim = best
    # Demote victim to probation MRU
    if victim is None:
        return False
    _prot.pop(victim, None)
    _prob[victim] = None
    _key_seg[victim] = 'prob'
    # Clear any immunity on demotion
    _no_demote_until.pop(victim, None)
    return True
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    """
    Choose an eviction victim key to make space for obj.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track unique for scan detection
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    if not cache_snapshot.cache:
        return None

    incoming_score = _score(obj.key)
    hot_thr = _hot_thr(cache_snapshot)

    # Strong scan guard: evict from probation first, then window; avoid protected
    if _scan_mode:
        # Probation LRU preferred in scans to keep T2 intact
        for k in _sample_lru_keys(_prob, 1):
            if k in cache_snapshot.cache:
                return k
        # Then window LRU
        for k in _sample_lru_keys(_win, 1):
            if k in cache_snapshot.cache:
                return k
        # Fall back to protected LRU if no alternative
        for k in _sample_lru_keys(_prot, 1):
            if k in cache_snapshot.cache:
                return k

    candidates = []
    # Gather LRU-side samples from segments
    for idx, k in enumerate(_sample_lru_keys(_win, _S_WIN)):
        if k in cache_snapshot.cache:
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 0  # window preferred
            candidates.append((hotter, shield, s, seg_rank, idx, k))
    for idx, k in enumerate(_sample_lru_keys(_prob, _S_PROB)):
        if k in cache_snapshot.cache:
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 1
            candidates.append((hotter, shield, s, seg_rank, idx, k))
    for idx, k in enumerate(_sample_lru_keys(_prot, _S_PROT)):
        if k in cache_snapshot.cache:
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 2  # protected least preferred
            candidates.append((hotter, shield, s, seg_rank, idx, k))

    if not candidates:
        # fallback
        return next(iter(cache_snapshot.cache.keys()))

    # Prefer victims from window/probation when available; otherwise allow protected
    non_prot = [c for c in candidates if c[3] < 2]
    pool = non_prot if non_prot else candidates

    # Select by: not hotter than incoming, not shielded hot, low score, prefer window/prob, older index
    hotter, shield, s, seg_rank, idx, victim = min(pool)
    if _key_seg.get(victim) == 'prot':
        global _evict_prot_cnt
        _evict_prot_cnt += 1
    else:
        global _evict_prob_cnt
        _evict_prob_cnt += 1
    return victim
=======
def evict(cache_snapshot, obj):
    """
    Choose an eviction victim key to make space for obj.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track unique for scan detection
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    if not cache_snapshot.cache:
        return None

    incoming_score = _score(obj.key)
    hot_thr = _hot_thr(cache_snapshot)

    # Strong scan guard: evict from probation first, then window; avoid protected
    if _scan_mode:
        # Probation LRU preferred in scans to keep T2 intact
        for k in _sample_lru_keys(_prob, 1):
            if k in cache_snapshot.cache:
                return k
        # Then window LRU
        for k in _sample_lru_keys(_win, 1):
            if k in cache_snapshot.cache:
                return k
        # Fall back to protected LRU if no alternative
        for k in _sample_lru_keys(_prot, 1):
            if k in cache_snapshot.cache:
                return k

    # ARC-style directional replacement: if the incoming key is in ghosts and fresh,
    # bias eviction toward the opposite segment (like ARC's replacement decision).
    try:
        g1 = _B1.get(obj.key)
        g2 = _B2.get(obj.key)
        touch_win = max(1, int(_fresh_epoch_win))
        w1 = max(0.0, 1.0 - (float(_epoch - g1) / float(touch_win))) if g1 is not None else 0.0
        w2 = max(0.0, 1.0 - (float(_epoch - g2) / float(touch_win))) if g2 is not None else 0.0

        # Fresh B1 signal -> free space from protected (T2) first
        if w1 >= 0.5 and _prot:
            sample = _sample_lru_keys(_prot, max(1, _S_PROT + 1))
            best = None
            best_t = None  # (immune_flag, score, idx)
            for idx, k in enumerate(sample):
                if k in cache_snapshot.cache:
                    immune_flag = 1 if _no_demote_until.get(k, 0) > _epoch else 0
                    t = (immune_flag, _score(k), idx)
                    if best_t is None or t < best_t:
                        best_t = t
                        best = k
            if best is not None and best_t[0] == 0:  # avoid evicting immune if possible
                return best

        # Fresh B2 signal -> free space from recency side (probation, then window)
        if w2 >= 0.5 and (_prob or _win):
            for k in _sample_lru_keys(_prob, max(1, _S_PROB)):
                if k in cache_snapshot.cache:
                    return k
            for k in _sample_lru_keys(_win, max(1, _S_WIN)):
                if k in cache_snapshot.cache:
                    return k
    except Exception:
        pass

    candidates = []
    # Gather LRU-side samples from segments
    for idx, k in enumerate(_sample_lru_keys(_win, _S_WIN)):
        if k in cache_snapshot.cache:
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 0  # window preferred
            candidates.append((hotter, shield, s, seg_rank, idx, k))
    for idx, k in enumerate(_sample_lru_keys(_prob, _S_PROB)):
        if k in cache_snapshot.cache:
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 1
            candidates.append((hotter, shield, s, seg_rank, idx, k))
    prot_candidates = []
    for idx, k in enumerate(_sample_lru_keys(_prot, _S_PROT)):
        if k in cache_snapshot.cache:
            s = _score(k)
            hotter = 1 if s > incoming_score else 0
            shield = 1 if s >= hot_thr else 0
            seg_rank = 2  # protected least preferred
            prot_candidates.append((hotter, shield, s, seg_rank, idx, k))

    if not candidates and not prot_candidates:
        # fallback
        return next(iter(cache_snapshot.cache.keys()))

    # Prefer victims from window/probation when available; otherwise allow protected
    non_prot = [c for c in candidates if c[3] < 2]
    # Best non-prot by standard ordering
    best_np = None
    if non_prot:
        best_np = min(non_prot)

    # Compute best protected with immunity penalty (avoid if immune)
    best_p = None
    best_p_tuple = None  # (hotter, shield, s_eff, seg_rank, idx, k)
    for (hotter, shield, s, seg_rank, idx, k) in prot_candidates:
        immune = _no_demote_until.get(k, 0) > _epoch
        s_eff = s + (1000 if immune else 0)  # heavy penalty if immune
        t = (hotter, shield, s_eff, seg_rank, idx, k)
        if best_p_tuple is None or t < best_p_tuple:
            best_p_tuple = t
            best_p = k

    if best_np is None and best_p is not None:
        return best_p

    if best_np is not None and best_p_tuple is not None:
        # Cross-segment override: if protected candidate is much colder than best non-prot, take it
        np_hotter, np_shield, np_s, _, _, np_k = best_np
        p_hotter, p_shield, p_s_eff, _, _, p_k = best_p_tuple
        if (p_hotter == 0 and p_shield == 0 and (p_s_eff + 0) <= (np_s - 2)):
            return p_k
        else:
            return np_k

    # Fallback to whichever exists
    if best_np is not None:
        return best_np[5]
    if best_p_tuple is not None:
        return best_p_tuple[5]
    # As last resort
    return next(iter(cache_snapshot.cache.keys()))
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    """
    Update metadata after a cache hit.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)
    hot_thr = _hot_thr(cache_snapshot)
    # Time-bounded two-touch window in epochs
    touch_win = max(1, int(_fresh_epoch_win))

    if seg == 'win':
        last = _two_touch.get(k)
        if last is not None and (_epoch - last) <= touch_win:
            _two_touch.pop(k, None)
            _place(k, 'prot', mru=True)  # two-touch promotion
        else:
            # late second touch resets frequency to a minimal seed
            _two_touch[k] = _epoch
            _freq[k] = (max(1, _score(k)), _epoch)
            # refresh within window
            if k in _win:
                _win.move_to_end(k, last=True)
            else:
                _place(k, 'win', mru=True)
    elif seg == 'prob':
        if _scan_mode:
            # require two-touch in probation during scans
            last = _two_touch.get(k)
            if last is not None and (_epoch - last) <= touch_win:
                _two_touch.pop(k, None)
                _place(k, 'prot', mru=True)
            else:
                _two_touch[k] = _epoch
                if k in _prob:
                    _prob.move_to_end(k, last=True)
        else:
            # Outside scans: promote if hot enough or two-touch within window
            if _score(k) >= hot_thr:
                _place(k, 'prot', mru=True)
            else:
                last = _two_touch.get(k)
                if last is not None and (_epoch - last) <= touch_win:
                    _two_touch.pop(k, None)
                    _place(k, 'prot', mru=True)
                else:
                    # late second touch: reset to a small seed and keep in probation MRU
                    _two_touch[k] = _epoch
                    _freq[k] = (max(1, _score(k)), _epoch)
                    if k in _prob:
                        _prob.move_to_end(k, last=True)
                    else:
                        _place(k, 'prob', mru=True)
    elif seg == 'prot':
        # refresh protected
        if k in _prot:
            _prot.move_to_end(k, last=True)
        else:
            _place(k, 'prot', mru=True)
        _two_touch.pop(k, None)
    else:
        # unknown key: place to window
        _place(k, 'win', mru=True)

    _rebalance(cache_snapshot)
=======
def update_after_hit(cache_snapshot, obj):
    """
    Update metadata after a cache hit.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)
    hot_thr = _hot_thr(cache_snapshot)
    # Time-bounded two-touch window in epochs
    touch_win = max(1, int(_fresh_epoch_win))

    if seg == 'win':
        last = _two_touch.get(k)
        if last is not None and (_epoch - last) <= touch_win:
            _two_touch.pop(k, None)
            _place(k, 'prot', mru=True)  # two-touch promotion
            _no_demote_until[k] = max(_no_demote_until.get(k, 0), _epoch + touch_win)
        else:
            # late second touch resets frequency to a minimal seed
            _two_touch[k] = _epoch
            _freq[k] = (max(1, _score(k)), _epoch)
            # refresh within window
            if k in _win:
                _win.move_to_end(k, last=True)
            else:
                _place(k, 'win', mru=True)
    elif seg == 'prob':
        if _scan_mode:
            # require two-touch in probation during scans
            last = _two_touch.get(k)
            if last is not None and (_epoch - last) <= touch_win:
                _two_touch.pop(k, None)
                _place(k, 'prot', mru=True)
                _no_demote_until[k] = max(_no_demote_until.get(k, 0), _epoch + touch_win)
            else:
                _two_touch[k] = _epoch
                if k in _prob:
                    _prob.move_to_end(k, last=True)
        else:
            # Outside scans: promote if hot enough or two-touch within window
            if _score(k) >= hot_thr:
                _place(k, 'prot', mru=True)
                _no_demote_until[k] = max(_no_demote_until.get(k, 0), _epoch + touch_win)
            else:
                last = _two_touch.get(k)
                if last is not None and (_epoch - last) <= touch_win:
                    _two_touch.pop(k, None)
                    _place(k, 'prot', mru=True)
                    _no_demote_until[k] = max(_no_demote_until.get(k, 0), _epoch + touch_win)
                else:
                    # late second touch: reset to a small seed and keep in probation MRU
                    _two_touch[k] = _epoch
                    _freq[k] = (max(1, _score(k)), _epoch)
                    if k in _prob:
                        _prob.move_to_end(k, last=True)
                    else:
                        _place(k, 'prob', mru=True)
    elif seg == 'prot':
        # refresh protected
        if k in _prot:
            _prot.move_to_end(k, last=True)
        else:
            _place(k, 'prot', mru=True)
        _two_touch.pop(k, None)
    else:
        # unknown key: place to window
        _place(k, 'win', mru=True)

    _rebalance(cache_snapshot)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    """
    Update metadata right after inserting a new object.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide placement with ghost awareness and freshness weighting
    g1 = _B1.get(k)
    g2 = _B2.get(k)
    age1 = (_epoch - g1) if g1 is not None else None
    age2 = (_epoch - g2) if g2 is not None else None
    touch_win = max(1, int(_fresh_epoch_win))

    w1 = max(0.0, 1.0 - (float(age1) / float(touch_win))) if age1 is not None else 0.0
    w2 = max(0.0, 1.0 - (float(age2) / float(touch_win))) if age2 is not None else 0.0

    # Seed frequency on readmission
    if w1 > 0 or w2 > 0:
        seed = 1 + int(round(4.0 * max(w1, w2)))
        c, e = _freq.get(k, (0, _epoch))
        _freq[k] = (max(c, seed), _epoch)

    incoming_score = _score(k)

    if _scan_mode:
        # Strong scan resistance: keep scans in window LRU so window absorbs churn
        _place(k, 'win', mru=False)
    else:
        if g2 is not None:
            # Protected ghost readmission: freshness-weighted
            if w2 >= 0.5:
                _place(k, 'prot', mru=True)
            else:
                _place(k, 'prob', mru=True)
        elif g1 is not None:
            # Recency ghost readmission
            if w1 >= 0.5:
                _place(k, 'prot', mru=True)
            else:
                _place(k, 'prob', mru=True)
        else:
            # Tiny admission guard: if colder than last victim, insert at window LRU; else window MRU
            if incoming_score < _last_victim_score:
                _place(k, 'win', mru=False)
            else:
                _place(k, 'win', mru=True)

    _rebalance(cache_snapshot)
=======
def update_after_insert(cache_snapshot, obj):
    """
    Update metadata right after inserting a new object.
    """
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide placement with ghost awareness and freshness weighting
    g1 = _B1.get(k)
    g2 = _B2.get(k)
    age1 = (_epoch - g1) if g1 is not None else None
    age2 = (_epoch - g2) if g2 is not None else None
    touch_win = max(1, int(_fresh_epoch_win))

    w1 = max(0.0, 1.0 - (float(age1) / float(touch_win))) if age1 is not None else 0.0
    w2 = max(0.0, 1.0 - (float(age2) / float(touch_win))) if age2 is not None else 0.0

    # Seed frequency on readmission
    if w1 > 0 or w2 > 0:
        seed = 1 + int(round(4.0 * max(w1, w2)))
        c, e = _freq.get(k, (0, _epoch))
        _freq[k] = (max(c, seed), _epoch)

    incoming_score = _score(k)

    if _scan_mode:
        # Strong scan resistance: keep scans in window LRU so window absorbs churn
        _place(k, 'win', mru=False)
    else:
        if g2 is not None:
            # Protected ghost readmission: freshness-weighted
            if w2 >= 0.5:
                _place(k, 'prot', mru=True)
                _no_demote_until[k] = max(_no_demote_until.get(k, 0), _epoch + touch_win)
            else:
                _place(k, 'prob', mru=True)
        elif g1 is not None:
            # Recency ghost readmission
            if w1 >= 0.5:
                _place(k, 'prot', mru=True)
                _no_demote_until[k] = max(_no_demote_until.get(k, 0), _epoch + touch_win)
            else:
                _place(k, 'prob', mru=True)
        else:
            # Tiny admission guard: if colder than last victim, insert at window LRU; else window MRU
            if incoming_score < _last_victim_score:
                _place(k, 'win', mru=False)
            else:
                _place(k, 'win', mru=True)

    _rebalance(cache_snapshot)
>>>>>>> REPLACE
</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_evict(cache_snapshot, obj, evicted_obj):
    """
    Update metadata after evicting a victim.
    """
    _maybe_age(cache_snapshot)

    victim_key = evicted_obj.key
    seg = _key_seg.get(victim_key, None)

    # record victim score for admission guidance (if used later)
    global _last_victim_score
    _last_victim_score = _score(victim_key)

    # Ghost recording
    if seg == 'prot':
        _B2[victim_key] = _epoch
        _prot.pop(victim_key, None)
        global _evict_prot_cnt
        _evict_prot_cnt += 1
    else:
        # Treat window/prob evictions as B1
        _B1[victim_key] = _epoch
        _win.pop(victim_key, None)
        _prob.pop(victim_key, None)
        global _evict_prob_cnt
        _evict_prob_cnt += 1

    _two_touch.pop(victim_key, None)
    _key_seg.pop(victim_key, None)

    # Ghost bound
    limit = max(1, _GHOST_LIMIT_MULT * max(cache_snapshot.capacity, 1))
    while len(_B1) > limit:
        _B1.popitem(last=False)
    while len(_B2) > limit:
        _B2.popitem(last=False)

    # ARC-like dynamic window tuning based on incoming object's presence in ghosts, freshness-weighted
    try:
        key_in = obj.key
        step = _ADAPT_STEP
        touch_win = max(1, int(_fresh_epoch_win))
        if key_in in _B1:
            age = max(0, _epoch - _B1.get(key_in, _epoch))
            w = max(0.0, 1.0 - (age / float(touch_win)))
            mult = (1.0 + 2.0 * w) * (0.5 if _scan_mode else 1.0)  # damp during scans
            _adj = step * mult
            # increase window
            global _WIN_FRAC
            _WIN_FRAC = min(_MAX_WIN, _WIN_FRAC + _adj)
        elif key_in in _B2:
            age = max(0, _epoch - _B2.get(key_in, _epoch))
            w = max(0.0, 1.0 - (age / float(touch_win)))
            mult = (1.0 + 2.0 * w) * (1.2 if _scan_mode else 1.0)  # amplify decrease during scans
            _adj = step * mult
            _WIN_FRAC = max(_MIN_WIN, _WIN_FRAC - _adj)
    except Exception:
        pass

    # Occasional mix-based nudge to protected ratio to avoid prolonged protected evictions
    try:
        total = _evict_prob_cnt + _evict_prot_cnt
        window = max(8, min(int(max(cache_snapshot.capacity, 1)), 128))
        if total >= window:
            if _evict_prot_cnt > _evict_prob_cnt:
                # reduce protected pressure by slightly lowering PROT share
                global _PROT_FRAC
                _PROT_FRAC = max(0.50, _PROT_FRAC - 0.02)
            elif _evict_prob_cnt > _evict_prot_cnt:
                _PROT_FRAC = min(0.85, _PROT_FRAC + 0.02)
            _evict_prot_cnt = 0
            _evict_prob_cnt = 0
    except Exception:
        _evict_prot_cnt = 0
        _evict_prob_cnt = 0

    _rebalance(cache_snapshot)
=======
def update_after_evict(cache_snapshot, obj, evicted_obj):
    """
    Update metadata after evicting a victim.
    """
    _maybe_age(cache_snapshot)

    victim_key = evicted_obj.key
    seg = _key_seg.get(victim_key, None)

    # record victim score for admission guidance (if used later)
    global _last_victim_score
    _last_victim_score = _score(victim_key)

    # Ghost recording
    if seg == 'prot':
        _B2[victim_key] = _epoch
        _prot.pop(victim_key, None)
        global _evict_prot_cnt
        _evict_prot_cnt += 1
    else:
        # Treat window/prob evictions as B1
        _B1[victim_key] = _epoch
        _win.pop(victim_key, None)
        _prob.pop(victim_key, None)
        global _evict_prob_cnt
        _evict_prob_cnt += 1

    _two_touch.pop(victim_key, None)
    _key_seg.pop(victim_key, None)
    _no_demote_until.pop(victim_key, None)

    # Ghost bound
    limit = max(1, _GHOST_LIMIT_MULT * max(cache_snapshot.capacity, 1))
    while len(_B1) > limit:
        _B1.popitem(last=False)
    while len(_B2) > limit:
        _B2.popitem(last=False)

    # ARC-like dynamic window tuning based on incoming object's presence in ghosts, freshness-weighted
    try:
        key_in = obj.key
        step = _ADAPT_STEP
        touch_win = max(1, int(_fresh_epoch_win))
        if key_in in _B1:
            age = max(0, _epoch - _B1.get(key_in, _epoch))
            w = max(0.0, 1.0 - (age / float(touch_win)))
            mult = (1.0 + 2.0 * w) * (0.5 if _scan_mode else 1.0)  # damp during scans
            _adj = step * mult
            # increase window
            global _WIN_FRAC
            _WIN_FRAC = min(_MAX_WIN, _WIN_FRAC + _adj)
        elif key_in in _B2:
            age = max(0, _epoch - _B2.get(key_in, _epoch))
            w = max(0.0, 1.0 - (age / float(touch_win)))
            mult = (1.0 + 2.0 * w) * (1.2 if _scan_mode else 1.0)  # amplify decrease during scans
            _adj = step * mult
            _WIN_FRAC = max(_MIN_WIN, _WIN_FRAC - _adj)
    except Exception:
        pass

    # Occasional mix-based nudge to protected ratio to avoid prolonged protected evictions
    try:
        total = _evict_prob_cnt + _evict_prot_cnt
        window = max(8, min(int(max(cache_snapshot.capacity, 1)), 128))
        if total >= window:
            if _evict_prot_cnt > _evict_prob_cnt:
                # reduce protected pressure by slightly lowering PROT share
                global _PROT_FRAC
                _PROT_FRAC = max(0.50, _PROT_FRAC - 0.02)
            elif _evict_prob_cnt > _evict_prot_cnt:
                _PROT_FRAC = min(0.85, _PROT_FRAC + 0.02)
            _evict_prot_cnt = 0
            _evict_prob_cnt = 0
    except Exception:
        _evict_prot_cnt = 0
        _evict_prob_cnt = 0

    _rebalance(cache_snapshot)
>>>>>>> REPLACE
</DIFF>