<NAME>
slru_quota_two_touch_promotion
</NAME>

<DESCRIPTION>
I introduce a simple yet effective enhancement to the current Segmented LRU (2Q-like) policy by adding:
- A protected segment quota tied to cache capacity (SLRU style).
- Conditional two-touch promotion when the protected segment is at or above its target, to resist scans and avoid overprotection.
- Demotion of protected entries when exceeding the target to keep a healthy probation space.

Rationale:
The current implementation promotes on the first hit and always evicts from probation first. This can cause overgrowth of protected, starving probation and leading to poor adaptability under scans or phase changes. By capping protected to ~50% of capacity and requiring two hits for promotion when protected is “full,” we better balance recency and frequency while preserving simplicity and low overhead. This approach avoids the complexity that previously degraded performance while addressing the key weakness of overprotection seen in 2Q variants.

Changes:
- Add m_target_protected and m_last_capacity with an initializer.
- Track probation hit counts (m_probation_hits) to support two-touch promotion under pressure.
- Enforce the protected quota via demotion when needed.
- Adjust eviction to trim protected when it exceeds the target; otherwise evict from probation first.

These targeted changes should reduce cache pollution during scans and better maintain hot sets, thereby improving miss rate across mixed workloads.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""

# Segmented LRU (2Q-like): probationary (recent) and protected (frequent) segments.
# - Newly inserted objects go to probationary.
# - On first hit, they are promoted to protected.
# - Evict from probationary first to resist scans; if empty, evict from protected.
m_ts = dict()             # key -> last access timestamp
m_probation = set()       # keys seen once (recently inserted)
m_protected = set()       # keys with demonstrated reuse (promoted on hit)

def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    global m_ts, m_probation, m_protected

    keys_in_cache = set(cache_snapshot.cache.keys())

    # Keep metadata consistent with actual cache content
    if m_probation:
        m_probation.intersection_update(keys_in_cache)
    if m_protected:
        m_protected.intersection_update(keys_in_cache)
    if m_ts:
        for k in list(m_ts.keys()):
            if k not in keys_in_cache:
                m_ts.pop(k, None)
                m_probation.discard(k)
                m_protected.discard(k)

    def oldest_key(candidates):
        # Return the key with the smallest timestamp among candidates
        return min(candidates, key=lambda k: m_ts.get(k, -1))

    probation_candidates = m_probation & keys_in_cache
    protected_candidates = m_protected & keys_in_cache

    # Prefer evicting from probationary segment to avoid polluting protected items
    if probation_candidates:
        return oldest_key(probation_candidates)
    if protected_candidates:
        return oldest_key(protected_candidates)

    # Fallback: evict the globally oldest if segmentation hasn't been set yet
    if keys_in_cache:
        return oldest_key(keys_in_cache)
    return None

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global m_ts, m_probation, m_protected
    now = cache_snapshot.access_count
    key = obj.key

    # Ensure timestamp exists
    if key not in m_ts:
        m_ts[key] = now

    # Promote on first hit; otherwise remain/update in protected
    if key in m_probation:
        m_probation.discard(key)
        m_protected.add(key)
    elif key not in m_protected:
        # If metadata was missing, treat as protected to avoid premature eviction
        m_protected.add(key)

    # Update recency timestamp
    m_ts[key] = now

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global m_ts, m_probation, m_protected
    now = cache_snapshot.access_count
    key = obj.key

    # New insert starts in probationary segment
    m_ts[key] = now
    m_protected.discard(key)
    m_probation.add(key)

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global m_ts, m_probation, m_protected
    evk = evicted_obj.key
    # Remove all metadata for the evicted object
    m_ts.pop(evk, None)
    m_probation.discard(evk)
    m_protected.discard(evk)
=======
"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""

# Segmented LRU (2Q-like) with a protected quota (SLRU-style) and conditional two-touch promotion:
# - Newly inserted objects go to probationary.
# - Promote to protected on hit; if protected is at/over target, require two touches to promote.
# - Demote protected LRU when protected exceeds target to keep a healthy probation space.
# - Evict: if protected exceeds target, evict protected LRU; else evict probation LRU first.
m_ts = dict()                  # key -> last access timestamp
m_probation = set()            # keys seen once (recently inserted)
m_protected = set()            # keys with demonstrated reuse (promoted on hit)

# Protected quota control
m_target_protected = None      # target number of protected entries
m_last_capacity = None         # last observed capacity (to re-init when changed)
m_probation_hits = dict()      # key -> hit count while in probation (for two-touch when needed)

def _init_targets(cache_snapshot):
    global m_target_protected, m_last_capacity
    cap = cache_snapshot.capacity or max(len(cache_snapshot.cache), 1)
    if m_target_protected is None or m_last_capacity != cap:
        m_target_protected = max(1, int(0.5 * cap))  # start balanced (50% protected)
        m_last_capacity = cap

def _oldest_key(candidates):
    # Return the key with the smallest timestamp among candidates
    return min(candidates, key=lambda k: m_ts.get(k, -1))

def _enforce_protected_quota():
    # Demote LRU from protected to probation until target is met
    while m_target_protected is not None and len(m_protected) > m_target_protected:
        demote_key = _oldest_key(m_protected)
        m_protected.discard(demote_key)
        m_probation.add(demote_key)
        m_probation_hits.setdefault(demote_key, 0)

def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    global m_ts, m_probation, m_protected
    _init_targets(cache_snapshot)

    keys_in_cache = set(cache_snapshot.cache.keys())

    # Keep metadata consistent with actual cache content
    if m_probation:
        m_probation.intersection_update(keys_in_cache)
    if m_protected:
        m_protected.intersection_update(keys_in_cache)
    if m_ts:
        for k in list(m_ts.keys()):
            if k not in keys_in_cache:
                m_ts.pop(k, None)
                m_probation.discard(k)
                m_protected.discard(k)
                m_probation_hits.pop(k, None)

    probation_candidates = m_probation & keys_in_cache
    protected_candidates = m_protected & keys_in_cache

    # If protected is oversized vs target, evict its oldest to reduce over-protection.
    if protected_candidates and m_target_protected is not None and len(m_protected) > m_target_protected:
        return _oldest_key(protected_candidates)
    # Prefer evicting from probationary segment to avoid polluting protected items
    if probation_candidates:
        return _oldest_key(probation_candidates)
    if protected_candidates:
        return _oldest_key(protected_candidates)

    # Fallback: evict the globally oldest if segmentation hasn't been set yet
    if keys_in_cache:
        return _oldest_key(keys_in_cache)
    return None

def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    global m_ts, m_probation, m_protected, m_probation_hits
    _init_targets(cache_snapshot)
    now = cache_snapshot.access_count
    key = obj.key

    # Ensure timestamp exists
    if key not in m_ts:
        m_ts[key] = now

    # Conditional promotion: if protected is at/over target, require two touches in probation
    if key in m_probation:
        m_probation_hits[key] = m_probation_hits.get(key, 0) + 1
        needs_two = (m_target_protected is not None and len(m_protected) >= m_target_protected)
        if (not needs_two) or (m_probation_hits[key] >= 2):
            m_probation.discard(key)
            m_protected.add(key)
            m_probation_hits.pop(key, None)
            # Enforce quota in case we exceeded it due to promotion
            _enforce_protected_quota()
    elif key not in m_protected:
        # If metadata was missing, treat as protected to avoid premature eviction
        m_protected.add(key)
        _enforce_protected_quota()

    # Update recency timestamp
    m_ts[key] = now

def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    global m_ts, m_probation, m_protected, m_probation_hits
    _init_targets(cache_snapshot)
    now = cache_snapshot.access_count
    key = obj.key

    # New insert starts in probationary segment
    m_ts[key] = now
    m_protected.discard(key)
    m_probation.add(key)
    m_probation_hits[key] = 0

def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    global m_ts, m_probation, m_protected, m_probation_hits
    evk = evicted_obj.key
    # Remove all metadata for the evicted object
    m_ts.pop(evk, None)
    m_probation.discard(evk)
    m_protected.discard(evk)
    m_probation_hits.pop(evk, None)
>>>>>>> REPLACE

</DIFF>