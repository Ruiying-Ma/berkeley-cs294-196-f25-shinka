<NAME>
arc_guided_segment_choice_and_admission_guard
</NAME>

<DESCRIPTION>
I introduce ARC-inspired segment selection in eviction and admission guard improvements to reduce pollution, alongside a composite heat metric that blends decayed frequency with recency differently per segment. Specifically:

- Eviction now chooses a primary segment to evict from guided by ghost signals (B1/B2) and current protected target, then samples more from the primary segment. This biases evictions towards the segment that best matches the incoming object's reuse signal, as in ARC.
- Candidate ranking uses a composite "heat" = frequency + recency_weight * recency_rank, with stronger recency emphasis in probation and stronger frequency emphasis in protected, instead of relying primarily on frequency. We still avoid evicting items hotter than the incoming object (TinyLFU-like admission guard).
- update_after_insert implements an admission guard vs the last victim: if the incoming score is notably below the last victim, insert at probation LRU to prevent polluting recency. We also clear ghosts upon readmission and keep ARC-like protected/recency bias on ghost feedback.
- update_after_hit refines promotion: outside scan mode we lower the hotness threshold on small caches and keep two-touch gating; promotions can slightly increase the protected fraction only for clearly hot items.
- update_after_evict now handles unknown segment metadata robustly, registers ghosts accordingly, and reacts to the incoming object's ghost type to promptly bias the protected fraction.

These changes preserve the existing SLRU/TinyLFU/ghost design, add ARC-guided decision making, and strengthen pollution controlâ€”expected to reduce miss rate across mixed workloads, especially under scans and bursty reuse.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# Admission guard and adaptation helpers
# We bias eviction choice to avoid evicting items hotter than the incoming object (TinyLFU-like).
# Additionally, adapt protected fraction based on eviction mix over a small window.
_ADMISSION_GUARD = True
_evict_prob_cnt = 0
_evict_prot_cnt = 0
=======
# Admission guard and adaptation helpers
# We bias eviction choice to avoid evicting items hotter than the incoming object (TinyLFU-like).
# Additionally, adapt protected fraction based on eviction mix over a small window.
_ADMISSION_GUARD = True
_evict_prob_cnt = 0
_evict_prot_cnt = 0

# Recency weights for composite heat (lower = more frequency emphasis)
_REC_W_PROB = 0.5
_REC_W_PROT = 0.25
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    # Keep metadata consistent and properly segmented before choosing a victim
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track key for scan detection unique density
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    # Clean up stale entries (if any)
    for k in list(_probation.keys()):
        if k not in cache_snapshot.cache:
            _probation.pop(k, None)
            _key_seg.pop(k, None)
    for k in list(_protected.keys()):
        if k not in cache_snapshot.cache:
            _protected.pop(k, None)
            _key_seg.pop(k, None)

    # If metadata is empty, fallback
    if not cache_snapshot.cache:
        return None

    # Adaptive sampling sizes
    prob_sample = _BASE_PROB_SAMPLE
    prot_sample = _BASE_PROT_SAMPLE
    if _scan_mode:
        prob_sample += 1
        prot_sample = max(1, prot_sample - 1)
    if len(_probation) > len(_protected) + 2:
        prob_sample += 1
    if len(_protected) > len(_probation) + 2:
        prot_sample += 1

    # Incoming-aware admission guard: avoid evicting hotter items if possible
    incoming_score = _score(obj.key)

    # Build candidate tuples from both segments' LRU sides
    candidates = []
    # Probation candidates
    pkeys = _sample_lru_keys(_probation, prob_sample)
    for idx, pk in enumerate(pkeys):
        if pk in cache_snapshot.cache:
            s = _score(pk)
            hotter = 1 if (_ADMISSION_GUARD and s > incoming_score) else 0
            segpref = 0  # probation preferred
            candidates.append((hotter, s, segpref, idx, pk))
    # Protected candidates
    tkeys = _sample_lru_keys(_protected, prot_sample)
    for idx, tk in enumerate(tkeys):
        if tk in cache_snapshot.cache:
            s = _score(tk)
            hotter = 1 if (_ADMISSION_GUARD and s > incoming_score) else 0
            segpref = 1  # protected less preferred
            candidates.append((hotter, s, segpref, idx, tk))

    if not candidates:
        # Fallback: pick any key from cache if metadata got desynced
        return next(iter(cache_snapshot.cache.keys()))

    # Choose coldest by (hotter_than_incoming, score, segment preference, recency)
    best = min(candidates)
    candid_obj_key = best[4]
    victim_from_protected = (_key_seg.get(candid_obj_key) == 'prot')

    # Adaptive tuning: if we are forced to evict from protected, reduce its target fraction slightly
    if victim_from_protected:
        _decrease_protected()

    return candid_obj_key
=======
def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    # Keep metadata consistent and properly segmented before choosing a victim
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track key for scan detection unique density
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    # Clean up stale entries (if any)
    for k in list(_probation.keys()):
        if k not in cache_snapshot.cache:
            _probation.pop(k, None)
            _key_seg.pop(k, None)
    for k in list(_protected.keys()):
        if k not in cache_snapshot.cache:
            _protected.pop(k, None)
            _key_seg.pop(k, None)

    # If metadata is empty, fallback
    if not cache_snapshot.cache:
        return None

    total = len(cache_snapshot.cache)
    target_prot = max(1, int(total * _PROTECTED_FRAC))

    # Adaptive sampling sizes
    prob_sample = _BASE_PROB_SAMPLE
    prot_sample = _BASE_PROT_SAMPLE
    if _scan_mode:
        prob_sample += 1
        prot_sample = max(1, prot_sample - 1)
    if len(_probation) > len(_protected) + 2:
        prob_sample += 1
    if len(_protected) > len(_probation) + 2:
        prot_sample += 1

    # ARC-like ghost-guided segment choice
    b2_hit = obj.key in _ghost_protected
    b1_hit = obj.key in _ghost_probation
    if b2_hit and len(_probation) > 0:
        primary_seg = 'prob'
        # favor frequency when seeing B2 ghost
        _increase_protected()
    elif b1_hit and len(_protected) > 0:
        primary_seg = 'prot'
        # favor recency when seeing B1 ghost
        _decrease_protected()
    else:
        # Choose the segment that is currently over its target
        if len(_protected) > target_prot and len(_protected) > 0:
            primary_seg = 'prot'
        else:
            primary_seg = 'prob'

    # Incoming-aware admission guard: avoid evicting hotter items if possible
    incoming_score = _score(obj.key)

    # Build candidate tuples from both segments' LRU sides, preferring primary segment
    candidates = []

    def add_candidates(seg_name, primary_flag, n_sample):
        if seg_name == 'prob':
            keys = _sample_lru_keys(_probation, n_sample)
            rec_w = _REC_W_PROB
            segpref = 0
        else:
            keys = _sample_lru_keys(_protected, n_sample)
            rec_w = _REC_W_PROT
            segpref = 1
        for idx, key in enumerate(keys):
            if key in cache_snapshot.cache:
                s = _score(key)
                hotter = 1 if (_ADMISSION_GUARD and s > incoming_score) else 0
                metric = s + rec_w * idx
                # Sort by: avoid hotter victims, prefer primary segment, then lowest composite heat, then recency
                candidates.append((hotter, 0 if primary_flag else 1, metric, idx, key))

    if primary_seg == 'prob':
        add_candidates('prob', True, prob_sample + 1)
        add_candidates('prot', False, max(1, prot_sample - 1))
    else:
        add_candidates('prot', True, prot_sample + 1)
        add_candidates('prob', False, max(1, prob_sample - 1))

    if not candidates:
        # Fallback: pick any key from cache if metadata got desynced
        return next(iter(cache_snapshot.cache.keys()))

    best = min(candidates)
    candid_obj_key = best[4]
    victim_from_protected = (_key_seg.get(candid_obj_key) == 'prot')

    # Adaptive tuning: if we are forced to evict from protected, reduce its target fraction slightly
    if victim_from_protected:
        _decrease_protected()

    return candid_obj_key
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)

    if seg == 'prob':
        last = _touched_once.get(k)
        promote = False
        if _scan_mode:
            # Two-touch gating under scans: require two hits within a short window
            if last is not None and (_epoch - last) <= 1:
                promote = True
            else:
                _touched_once[k] = _epoch
        else:
            # Outside scans: two-touch OR clearly hot by frequency OR recent protected ghost
            hot_freq = (_score(k) >= 2)
            gpe = _ghost_protected.get(k)
            recent_b2 = (gpe is not None) and (_epoch - gpe <= 3)
            if last is not None or hot_freq or recent_b2:
                promote = True
            else:
                _touched_once[k] = _epoch

        if promote:
            _touched_once.pop(k, None)
            _probation.pop(k, None)
            _protected[k] = None  # MRU
            _key_seg[k] = 'prot'
            # Only expand protected on truly hot promotions
            if not _scan_mode and _score(k) >= 2:
                _increase_protected()
        else:
            # Refresh to MRU of probation
            if k in _probation:
                _probation.move_to_end(k, last=True)
            else:
                _probation[k] = None

    elif seg == 'prot':
        # Refresh recency in protected
        if k in _protected:
            _protected.move_to_end(k, last=True)
        else:
            # If somehow missing from the structure, reinsert into protected
            _protected[k] = None
            _key_seg[k] = 'prot'
        # Clear any stale two-touch marker
        _touched_once.pop(k, None)
    else:
        # Unknown key (shouldn't happen on hit). Refresh probation; do not auto-promote.
        _probation[k] = None
        _key_seg[k] = 'prob'
        _probation.move_to_end(k, last=True)

    _rebalance(cache_snapshot)
=======
def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)

    if seg == 'prob':
        last = _touched_once.get(k)
        promote = False
        if _scan_mode:
            # Two-touch gating under scans: require two hits within a short window
            if last is not None and (_epoch - last) <= 1:
                promote = True
            else:
                _touched_once[k] = _epoch
        else:
            # Outside scans: two-touch OR clearly hot by frequency OR recent protected ghost
            cap = max(cache_snapshot.capacity, 1)
            hot_freq = (_score(k) >= (1 if cap <= 64 else 2))
            gpe = _ghost_protected.get(k)
            recent_b2 = (gpe is not None) and (_epoch - gpe <= 3)
            if last is not None or hot_freq or recent_b2:
                promote = True
            else:
                _touched_once[k] = _epoch

        if promote:
            _touched_once.pop(k, None)
            _probation.pop(k, None)
            _protected[k] = None  # MRU
            _key_seg[k] = 'prot'
            # Only expand protected on truly hot promotions
            if not _scan_mode and _score(k) >= 2:
                _increase_protected()
        else:
            # Refresh to MRU of probation
            if k in _probation:
                _probation.move_to_end(k, last=True)
            else:
                _probation[k] = None

    elif seg == 'prot':
        # Refresh recency in protected
        if k in _protected:
            _protected.move_to_end(k, last=True)
        else:
            # If somehow missing from the structure, reinsert into protected
            _protected[k] = None
            _key_seg[k] = 'prot'
        # Clear any stale two-touch marker
        _touched_once.pop(k, None)
    else:
        # Unknown key (shouldn't happen on hit). Refresh probation; do not auto-promote.
        _probation[k] = None
        _key_seg[k] = 'prob'
        _probation.move_to_end(k, last=True)

    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide segment placement using ghost history (segment-aware)
    g_prot_epoch = _ghost_protected.get(k)
    g_prob_epoch = _ghost_probation.get(k)
    recent_prot_ghost = (g_prot_epoch is not None) and (_epoch - g_prot_epoch <= 2)
    recent_prob_ghost = (g_prob_epoch is not None) and (_epoch - g_prob_epoch <= 2)
    incoming_score = _score(k)

    # Reset any existing placement
    if _key_seg.get(k) == 'prot':
        _protected.pop(k, None)
    else:
        _probation.pop(k, None)

    if _scan_mode:
        # Scan resistance: insert at probation LRU to minimize pollution,
        # require two-touch before promotion via update_after_hit.
        _probation[k] = None
        _probation.move_to_end(k, last=False)  # LRU side
        _key_seg[k] = 'prob'
    else:
        if recent_prot_ghost and incoming_score >= 2:
            # Re-admit into protected due to recent protected ghost and clear hotness
            _protected[k] = None
            _key_seg[k] = 'prot'
            _increase_protected()
        else:
            # Default admission into probation MRU
            _probation[k] = None
            _key_seg[k] = 'prob'
            _probation.move_to_end(k, last=True)
            if recent_prob_ghost:
                # A B1-like hit suggests we need more recency; bias slightly
                _decrease_protected()
                _inc(k)

    _rebalance(cache_snapshot)
=======
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide segment placement using ghost history (segment-aware)
    g_prot_epoch = _ghost_protected.get(k)
    g_prob_epoch = _ghost_probation.get(k)
    recent_prot_ghost = (g_prot_epoch is not None) and (_epoch - g_prot_epoch <= 2)
    recent_prob_ghost = (g_prob_epoch is not None) and (_epoch - g_prob_epoch <= 2)
    incoming_score = _score(k)

    # Reset any existing placement
    if _key_seg.get(k) == 'prot':
        _protected.pop(k, None)
    else:
        _probation.pop(k, None)

    # Clear ghosts on readmission
    _ghost_protected.pop(k, None)
    _ghost_probation.pop(k, None)

    if _scan_mode:
        # Scan resistance: insert at probation LRU to minimize pollution,
        # require two-touch before promotion via update_after_hit.
        _probation[k] = None
        _probation.move_to_end(k, last=False)  # LRU side
        _key_seg[k] = 'prob'
    else:
        if recent_prot_ghost and incoming_score >= 2:
            # Re-admit into protected due to recent protected ghost
            _protected[k] = None
            _key_seg[k] = 'prot'
            _increase_protected()
        else:
            # Admission guard vs last victim: if clearly colder, insert at probation LRU
            colder_than_victim = (incoming_score + 0.5) < _last_victim_score
            _probation[k] = None
            _key_seg[k] = 'prob'
            if colder_than_victim:
                _probation.move_to_end(k, last=False)  # push to LRU side
            else:
                _probation.move_to_end(k, last=True)   # MRU
            if recent_prob_ghost:
                # A B1-like hit suggests we need more recency; bias slightly
                _decrease_protected()
                _inc(k)

    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    # Record into ghost according to the segment it was evicted from
    k = evicted_obj.key
    seg = _key_seg.get(k, None)
    # Store last victim score for potential future enhancements
    global _last_victim_score, _evict_prob_cnt, _evict_prot_cnt
    _last_victim_score = _score(k)

    if seg == 'prob':
        _ghost_probation[k] = _epoch
        _probation.pop(k, None)
        _evict_prob_cnt += 1
    elif seg == 'prot':
        _ghost_protected[k] = _epoch
        _protected.pop(k, None)
        _evict_prot_cnt += 1

    # Clean any stale two-touch markers
    _touched_once.pop(k, None)

    _key_seg.pop(k, None)

    # Trim ghost histories to bounded size
    limit = max(1, _GHOST_LIMIT_MULT * max(cache_snapshot.capacity, 1))
    while len(_ghost_probation) > limit:
        _ghost_probation.popitem(last=False)
    while len(_ghost_protected) > limit:
        _ghost_protected.popitem(last=False)

    # Adaptive protected tuning: if we evicted from probation but the incoming object is hotter,
    # increase protected to preserve hot items better.
    try:
        if seg == 'prob' and _score(obj.key) > _last_victim_score:
            _increase_protected()
    except Exception:
        pass

    # Eviction-mix adaptation over a short window
    try:
        total = _evict_prob_cnt + _evict_prot_cnt
        window = max(8, min(int(max(cache_snapshot.capacity, 1)), 128))
        if total >= window:
            if _evict_prot_cnt > _evict_prob_cnt:
                _decrease_protected()
            elif _evict_prob_cnt > _evict_prot_cnt:
                _increase_protected()
            _evict_prot_cnt = 0
            _evict_prob_cnt = 0
    except Exception:
        # Be conservative if anything goes wrong
        _evict_prot_cnt = 0
        _evict_prob_cnt = 0

    # After an eviction, ensure protected segment still respects target (it might shrink due to target change)
    _rebalance(cache_snapshot)
=======
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object to be inserted into the cache.
        - `evicted_obj`: The object that was just evicted from the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    # Record into ghost according to the segment it was evicted from
    k = evicted_obj.key
    seg = _key_seg.get(k, None)
    # Store last victim score for potential future enhancements
    global _last_victim_score, _evict_prob_cnt, _evict_prot_cnt
    _last_victim_score = _score(k)

    if seg == 'prob':
        _ghost_probation[k] = _epoch
        _probation.pop(k, None)
        _evict_prob_cnt += 1
    elif seg == 'prot':
        _ghost_protected[k] = _epoch
        _protected.pop(k, None)
        _evict_prot_cnt += 1
    else:
        # Unknown segment: default to probation ghost
        _ghost_probation[k] = _epoch

    # Clean any stale two-touch markers
    _touched_once.pop(k, None)

    _key_seg.pop(k, None)

    # Trim ghost histories to bounded size
    limit = max(1, _GHOST_LIMIT_MULT * max(cache_snapshot.capacity, 1))
    while len(_ghost_probation) > limit:
        _ghost_probation.popitem(last=False)
    while len(_ghost_protected) > limit:
        _ghost_protected.popitem(last=False)

    # Adaptive protected tuning: if we evicted from probation but the incoming object is hotter,
    # increase protected to preserve hot items better. Also react to incoming ghost type.
    try:
        if seg == 'prob' and _score(obj.key) > _last_victim_score:
            _increase_protected()
        if obj.key in _ghost_protected:
            _increase_protected()
        elif obj.key in _ghost_probation:
            _decrease_protected()
    except Exception:
        pass

    # Eviction-mix adaptation over a short window
    try:
        total = _evict_prob_cnt + _evict_prot_cnt
        window = max(8, min(int(max(cache_snapshot.capacity, 1)), 128))
        if total >= window:
            if _evict_prot_cnt > _evict_prob_cnt:
                _decrease_protected()
            elif _evict_prob_cnt > _evict_prot_cnt:
                _increase_protected()
            _evict_prot_cnt = 0
            _evict_prob_cnt = 0
    except Exception:
        # Be conservative if anything goes wrong
        _evict_prot_cnt = 0
        _evict_prob_cnt = 0

    # After an eviction, ensure protected segment still respects target (it might shrink due to target change)
    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>