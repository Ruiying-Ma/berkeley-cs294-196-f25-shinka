--- a/original.py
+++ b/original.py
@@ -1,413 +1,324 @@
 # EVOLVE-BLOCK-START
-"""Scan-aware ARC+SLRU with freshness-aware ghosts, momentum p-updates, and aging LRFU sampling"""
+"""W-TinyLFU + SLRU:
+- Window LRU (W) for new items
+- Main SLRU split into Probation (P) and Protected (S)
+- TinyLFU-like decayed frequency for admission
+- Adaptive window sizing and scan-aware eviction
+"""
 
 from collections import OrderedDict
 
-# Segments (resident)
-_T1_probation = OrderedDict()   # first-touch, recency-biased
-_T2_protected = OrderedDict()   # multi-touch, frequency-biased
-
-# Ghost histories (evicted keys) store eviction timestamps for freshness
-_B1_ghost = OrderedDict()       # from T1: key -> evict_ts
-_B2_ghost = OrderedDict()       # from T2: key -> evict_ts
-
-# ARC's adaptive target (float) for T1 size
-_p_target = 0.0
+# Segments
+_W_window = OrderedDict()   # recency-biased window
+_P_prob = OrderedDict()     # main probation
+_S_prot = OrderedDict()     # main protected
+_seg = {}                   # key -> 'W'|'P'|'S'
+
+# Decayed frequency (TinyLFU-like) and timestamps
+_freq = {}                  # key -> small int, halved periodically
+_FREQ_MAX = 15
+_last_age_tick = 0
+_AGE_WINDOW = 128
+
+# EWMA signals for scan/locality
+_hit_ewma = 0.0
+_miss_ewma = 0.0
+_EWMA_ALPHA = 0.05
+_scan_mode = False
+
+# Capacity and targets
 _cap_est = 0
-
-# Fallback timestamp ledger and lightweight frequency
-m_key_timestamp = dict()        # key -> last access time (for tie-breaking)
-_freq = dict()                  # key -> small counter (saturating)
-_last_age_tick = 0
-
-# Admission guard based on last victim strength and a short scan window
-_last_victim_strength = 0.0
-_VICTIM_GUARD_THRESH = 2.0
-_guard_until = 0
-
-# Scan detection and momentum for p updates
-_hit_ewma = 0.0
-_ins_ewma = 0.0
-_EWMA_ALPHA = 0.05
-_scan_until = 0
-_p_momentum = 0.0
-_p_last_update_tick = 0
-
-# Tunables
-_P_INIT_RATIO = 0.30             # initial share for T1
-_FREQ_MAX = 7                    # 3-bit saturating counter
-_FRESH_WINDOW_RATIO = 0.5        # ghost freshness window = 0.5 * cap
-_SCAN_TRIGGER_INS = 0.7          # insert EWMA threshold
-_SCAN_TRIGGER_HIT = 0.15         # hit EWMA threshold
-_SCAN_WINDOW_MULT = 1.0          # scan window length ~= cap accesses
-_P_COOLDOWN_DIV = 10             # min spacing between non-ghost p-updates (~cap/10 accesses) for faster adaptation
-_CROSS_EVICT_FREQ_MARGIN = 0     # allow override on equal-or-better frequency if overall colder
-
-def _ensure_capacity(cache_snapshot):
-    """Initialize capacity and clamp p within [0, cap]."""
-    global _cap_est, _p_target
+_window_frac = 0.10    # adaptive: 2%..25%
+_prot_frac = 0.80      # protected share within main (P+S)
+
+# Admission planning between evict() and update_after_insert()
+_admit_plan = {}        # key -> 'main' | 'window'
+
+
+def _ensure_params(cache_snapshot):
+    global _cap_est, _AGE_WINDOW
     cap = getattr(cache_snapshot, "capacity", None)
     if isinstance(cap, int) and cap > 0:
         _cap_est = cap
     else:
         _cap_est = max(_cap_est, len(cache_snapshot.cache))
-    if _cap_est <= 0:
-        _cap_est = max(1, len(cache_snapshot.cache))
-    if _p_target == 0.0 and not _T1_probation and not _T2_protected and not _B1_ghost and not _B2_ghost:
-        _p_target = min(float(_cap_est), max(0.0, float(_cap_est) * _P_INIT_RATIO))
-    if _p_target < 0.0:
-        _p_target = 0.0
-    if _p_target > float(_cap_est):
-        _p_target = float(_cap_est)
-
-def _ghost_trim():
-    """Bound ghosts by capacity."""
-    while len(_B1_ghost) > _cap_est:
-        _B1_ghost.popitem(last=False)
-    while len(_B2_ghost) > _cap_est:
-        _B2_ghost.popitem(last=False)
+    _cap_est = max(1, _cap_est)
+    # Age roughly at cache size cadence
+    _AGE_WINDOW = max(64, _cap_est)
+
 
 def _maybe_age(cache_snapshot):
-    """Periodically age frequencies to avoid stale bias."""
+    """Halve frequencies periodically to discard stale history."""
     global _last_age_tick
-    _ensure_capacity(cache_snapshot)
     now = cache_snapshot.access_count
-    if now - _last_age_tick >= max(1, _cap_est):
+    if now - _last_age_tick >= _AGE_WINDOW:
         for k in list(_freq.keys()):
-            newf = _freq.get(k, 0) // 2
-            if newf <= 0:
+            nv = _freq.get(k, 0) // 2
+            if nv <= 0:
                 _freq.pop(k, None)
             else:
-                _freq[k] = newf
+                _freq[k] = nv
         _last_age_tick = now
 
-def _update_activity(is_hit, cache_snapshot):
-    """Track recent hit/miss behavior and activate scan window if needed."""
-    global _hit_ewma, _ins_ewma, _scan_until
-    alpha = _EWMA_ALPHA
-    _hit_ewma = (1.0 - alpha) * _hit_ewma + alpha * (1.0 if is_hit else 0.0)
-    _ins_ewma = (1.0 - alpha) * _ins_ewma + alpha * (0.0 if is_hit else 1.0)
-    if (_ins_ewma > _SCAN_TRIGGER_INS) and (_hit_ewma < _SCAN_TRIGGER_HIT):
-        _scan_until = cache_snapshot.access_count + int(max(1, _SCAN_WINDOW_MULT * _cap_est))
-
-def _adjust_p(sign, step, now, freshness_scale=1.0, force=False):
-    """Momentum-based adjustment of ARC's p with cooldown and clamping."""
-    global _p_target, _p_momentum, _p_last_update_tick
-    # Throttle non-ghost adjustments to avoid oscillation
-    if not force:
-        cool = max(1, int(max(1, _cap_est) // max(1, _P_COOLDOWN_DIV)))
-        if now - _p_last_update_tick < cool:
-            return
-    # Scale step by freshness and bound to 0.25*cap to avoid wild swings
-    bounded = min(max(1.0, float(step) * float(freshness_scale)), max(1.0, 0.25 * float(_cap_est)))
-    # Momentum update with clamp
-    _p_momentum = 0.5 * _p_momentum + float(sign) * bounded
-    max_mom = 0.25 * float(_cap_est)
-    if _p_momentum > max_mom:
-        _p_momentum = max_mom
-    elif _p_momentum < -max_mom:
-        _p_momentum = -max_mom
-    # Apply and clamp p
-    _p_target += _p_momentum
-    if _p_target < 0.0:
-        _p_target = 0.0
-        _p_momentum = 0.0
-    if _p_target > float(_cap_est):
-        _p_target = float(_cap_est)
-        _p_momentum = 0.0
-    _p_last_update_tick = now
-
-def _fallback_choose(cache_snapshot):
-    """LRU fallback using timestamps."""
+
+def _inc_freq(key):
+    _freq[key] = min(_FREQ_MAX, _freq.get(key, 0) + 1)
+
+
+def _freq_of(key):
+    return _freq.get(key, 0)
+
+
+def _update_signals(is_hit, cache_snapshot):
+    """Update EWMAs and detect scans to adapt window sizing."""
+    global _hit_ewma, _miss_ewma, _scan_mode, _window_frac, _prot_frac
+    a = _EWMA_ALPHA
+    _hit_ewma = (1 - a) * _hit_ewma + a * (1.0 if is_hit else 0.0)
+    _miss_ewma = (1 - a) * _miss_ewma + a * (0.0 if is_hit else 1.0)
+
+    # Simple scan detection: many misses, few hits
+    scanning = (_miss_ewma > 0.75 and _hit_ewma < 0.2)
+    _scan_mode = scanning
+
+    # Adapt window and protected fractions
+    if _scan_mode:
+        _window_frac = 0.02   # keep window tiny during scans
+        _prot_frac = 0.90     # keep main protected large
+    else:
+        # If good locality, expand window a bit to capture recency
+        if _hit_ewma > 0.5:
+            _window_frac = 0.20
+            _prot_frac = 0.80
+        elif _hit_ewma > 0.3:
+            _window_frac = 0.12
+            _prot_frac = 0.80
+        else:
+            _window_frac = 0.08
+            _prot_frac = 0.85
+
+
+def _get_lru(od):
+    """Return LRU key from OrderedDict or None."""
+    for k in od.keys():
+        return k
+    return None
+
+
+def _move_to_W(key):
+    if key in _P_prob:
+        _P_prob.pop(key, None)
+    if key in _S_prot:
+        _S_prot.pop(key, None)
+    _W_window.pop(key, None)
+    _W_window[key] = True
+    _seg[key] = 'W'
+
+
+def _move_to_P(key):
+    if key in _W_window:
+        _W_window.pop(key, None)
+    if key in _S_prot:
+        _S_prot.pop(key, None)
+    _P_prob.pop(key, None)
+    _P_prob[key] = True
+    _seg[key] = 'P'
+
+
+def _move_to_S(key):
+    if key in _W_window:
+        _W_window.pop(key, None)
+    if key in _P_prob:
+        _P_prob.pop(key, None)
+    _S_prot.pop(key, None)
+    _S_prot[key] = True
+    _seg[key] = 'S'
+
+
+def _rebalance_protected():
+    """Keep S within target fraction of main (P+S) by demoting to P."""
+    main_sz = len(_P_prob) + len(_S_prot)
+    if main_sz <= 0:
+        return
+    target_S = int(max(1, round(_prot_frac * main_sz)))
+    while len(_S_prot) > target_S:
+        lru = _get_lru(_S_prot)
+        if lru is None:
+            break
+        _S_prot.pop(lru, None)
+        _P_prob[lru] = True
+        _seg[lru] = 'P'
+
+
+def evict(cache_snapshot, obj):
+    """
+    W-TinyLFU guided victim selection:
+    - Prefer window victim during scans.
+    - When window >= target: compare f(obj) vs f(P.LRU) to decide if admitting to main.
+      * If f(obj) > f(P.LRU), evict from P (admit new to main).
+      * Else evict from W (keep main intact).
+    - Otherwise prefer evicting from P; if empty, from W; then from S as last resort.
+    """
+    _ensure_params(cache_snapshot)
+    _maybe_age(cache_snapshot)
+
+    key_in = obj.key if obj is not None else None
+    f_x = _freq_of(key_in)
+
+    # Targets
+    window_target = max(1, int(round(_window_frac * _cap_est)))
+
+    # Candidates
+    vW = _get_lru(_W_window)
+    vP = _get_lru(_P_prob)
+    vS = _get_lru(_S_prot)
+
+    # Scan bias: favor evicting from window to avoid polluting main
+    if _scan_mode and vW is not None:
+        _admit_plan[key_in] = 'window'
+        return vW or vP or vS
+
+    # Window full: perform TinyLFU admission comparison against P's LRU
+    if len(_W_window) >= window_target and vW is not None and vP is not None:
+        if f_x > _freq_of(vP):
+            # Admit new item into main; evict from probation
+            _admit_plan[key_in] = 'main'
+            return vP
+        else:
+            # Keep main intact; evict from window
+            _admit_plan[key_in] = 'window'
+            return vW
+
+    # Otherwise, choose probation victim if exists, guided by frequency
+    if vP is not None:
+        # If incoming clearly hotter than probation LRU, plan to admit to main
+        if f_x >= _freq_of(vP):
+            _admit_plan[key_in] = 'main'
+        else:
+            _admit_plan[key_in] = 'window'
+        return vP
+
+    # If no probation, evict from window if possible
+    if vW is not None:
+        _admit_plan[key_in] = 'window'
+        return vW
+
+    # Last resort: evict from protected LRU
+    if vS is not None:
+        _admit_plan[key_in] = 'main'
+        return vS
+
+    # Fallback
     keys = list(cache_snapshot.cache.keys())
     if not keys:
         return None
-    known = [(k, m_key_timestamp.get(k, None)) for k in keys]
-    known_ts = [x for x in known if x[1] is not None]
-    if known_ts:
-        return min(known_ts, key=lambda kv: kv[1])[0]
+    _admit_plan[key_in] = 'window'
     return keys[0]
 
-def _lru_iter(od):
-    """Iterate keys from LRU to MRU for an OrderedDict."""
-    for k in od.keys():
-        yield k
-
-def _score_key(k):
-    """Compute victim score: lower is better (less frequent, older)."""
-    return (_freq.get(k, 0), m_key_timestamp.get(k, 0))
-
-def _pick_from(od, sample_n, cache_snapshot):
-    """Pick victim from first few LRU entries by (freq asc, timestamp asc)."""
-    if not od:
-        return None
-    cnt = 0
-    best_k = None
-    best_sc = None
-    for k in _lru_iter(od):
-        if k not in cache_snapshot.cache:
-            continue
-        sc = _score_key(k)
-        if best_sc is None or sc < best_sc:
-            best_sc = sc
-            best_k = k
-        cnt += 1
-        if cnt >= sample_n:
-            break
-    return best_k
-
-def _demote_protected_if_needed(cache_snapshot, avoid_key=None):
-    """Keep T2 size within ARC target by demoting LRU entries to T1 MRU."""
-    _ensure_capacity(cache_snapshot)
-    t1_target = int(round(_p_target))
-    t2_target = max(_cap_est - t1_target, 0)
-    while len(_T2_protected) > t2_target:
-        # LRU of T2
-        lru = None
-        for k in _lru_iter(_T2_protected):
-            if k != avoid_key and k in cache_snapshot.cache:
-                lru = k
-                break
-        if lru is None:
-            break
-        _T2_protected.pop(lru, None)
-        _T1_probation[lru] = True  # demoted MRU in T1
-
-def evict(cache_snapshot, obj):
-    '''
-    Evict using ARC replace with dynamic sampling and scan bias:
-    - Prefer T1 when |T1| > p or when upcoming key is in B2 and |T1| == p.
-    - During scan window, always prefer T1 if non-empty.
-    - Cross-segment override: pick the globally colder candidate by (freq, age) when reasonable.
-    '''
-    _ensure_capacity(cache_snapshot)
-
-    t1_size = len(_T1_probation)
-    t2_size = len(_T2_protected)
-    x_in_b2 = (obj is not None) and (obj.key in _B2_ghost)
-    choose_t1 = (t1_size >= 1) and ((x_in_b2 and t1_size == int(round(_p_target))) or (t1_size > _p_target))
-
-    # Scan bias: keep evictions in probation when scanning
-    if cache_snapshot.access_count <= _scan_until and t1_size > 0:
-        choose_t1 = True
-
-    # Adaptive sampling sizes based on pressure and scan
-    cap = max(1, _cap_est)
-    t1_pressure = (t1_size > _p_target + 0.1 * cap) or (cache_snapshot.access_count <= _scan_until)
-    t2_pressure = (t2_size > (cap - int(round(_p_target)))) or False
-
-    T1_SAMPLE = 1 if t1_pressure else 2
-    if cache_snapshot.access_count <= _scan_until:
-        T1_SAMPLE = 1
-    T2_SAMPLE = 5 if t2_pressure else 3
-    if _hit_ewma < 0.2:
-        T2_SAMPLE = max(2, T2_SAMPLE - 1)
-
-    # Sample candidates from both segments
-    cand_t1 = _pick_from(_T1_probation, T1_SAMPLE, cache_snapshot) if t1_size > 0 else None
-    cand_t2 = _pick_from(_T2_protected, T2_SAMPLE, cache_snapshot) if t2_size > 0 else None
-
-    # Initial choice by ARC
-    if choose_t1:
-        victim_key = cand_t1 if cand_t1 is not None else cand_t2
+
+def update_after_hit(cache_snapshot, obj):
+    """
+    On hit:
+    - Update EWMAs and decay frequencies periodically.
+    - Increment TinyLFU frequency.
+    - In W: refresh MRU; optionally fast-track to S if frequency is high.
+    - In P: promote to S.
+    - In S: refresh MRU.
+    - Rebalance protected size.
+    """
+    _ensure_params(cache_snapshot)
+    _maybe_age(cache_snapshot)
+    _update_signals(True, cache_snapshot)
+
+    k = obj.key
+    _inc_freq(k)
+
+    if k in _W_window:
+        # Refresh MRU in window; if clearly hot, promote to protected
+        _W_window.move_to_end(k, last=True)
+        if _freq_of(k) >= 3 and not _scan_mode:
+            _move_to_S(k)
+    elif k in _P_prob:
+        # Two-touch: probation -> protected
+        _move_to_S(k)
+    elif k in _S_prot:
+        # Refresh MRU
+        _S_prot.move_to_end(k, last=True)
     else:
-        victim_key = cand_t2 if cand_t2 is not None else cand_t1
-
-    # Cross-segment override: prefer globally colder by (freq asc, timestamp asc)
-    if cand_t1 is not None and cand_t2 is not None:
-        sc1 = _score_key(cand_t1)
-        sc2 = _score_key(cand_t2)
-        min_seg = max(1, int(0.3 * cap))
-        # If ARC chose T1 but T2 candidate is strictly colder overall, and T2 has enough items, override
-        if choose_t1 and (sc2 < sc1) and (len(_T2_protected) > min_seg):
-            victim_key = cand_t2
-        # If ARC chose T2 but T1 candidate is strictly colder overall, and T1 has enough items, override
-        elif (not choose_t1) and (sc1 < sc2) and (len(_T1_probation) > min_seg):
-            victim_key = cand_t1
-        else:
-            # Fall back to frequency-gap rule (margin may be zero)
-            f1, f2 = sc1[0], sc2[0]
-            if choose_t1 and (f2 + _CROSS_EVICT_FREQ_MARGIN < f1) and (len(_T2_protected) > min_seg):
-                victim_key = cand_t2
-            elif (not choose_t1) and (f1 + _CROSS_EVICT_FREQ_MARGIN < f2) and (len(_T1_probation) > min_seg):
-                victim_key = cand_t1
-
-    if victim_key is None:
-        victim_key = _fallback_choose(cache_snapshot)
-    return victim_key
-
-def update_after_hit(cache_snapshot, obj):
-    '''
-    On hit:
-    - Update EWMA and age frequencies.
-    - Increment frequency (saturating).
-    - Two-touch promotion from T1 when locality is poor (scan or low hit EWMA) or T1 is over target.
-    - Otherwise: first hit in T1 promotes to T2.
-    - Keep T2 within its ARC target via demotion.
-    - Remove any ghost entries for this key.
-    '''
-    _ensure_capacity(cache_snapshot)
+        # Unknown metadata: place into window MRU
+        _move_to_W(k)
+
+    _rebalance_protected()
+
+
+def update_after_insert(cache_snapshot, obj):
+    """
+    On miss/insert:
+    - Update EWMAs and age frequencies.
+    - Increment TinyLFU frequency for the key.
+    - Use prior admission plan: 'main' => insert into P; else into W.
+    - If scanning, bias new items to window LRU to shed quickly.
+    """
+    _ensure_params(cache_snapshot)
     _maybe_age(cache_snapshot)
-    _update_activity(True, cache_snapshot)
-
-    key = obj.key
-    now = cache_snapshot.access_count
-    m_key_timestamp[key] = now
-    _freq[key] = min(_FREQ_MAX, _freq.get(key, 0) + 1)
-
-    in_scan = now <= _scan_until
-    t1_over = len(_T1_probation) > int(round(_p_target))
-    poor_locality = (_hit_ewma < 0.2)
-
-    if key in _T2_protected:
-        _T2_protected.move_to_end(key, last=True)
-    elif key in _T1_probation:
-        require_two_touch = in_scan or t1_over or poor_locality
-        if require_two_touch and _freq.get(key, 0) < 2:
-            # Keep in T1 and move to MRU until proven by second touch
-            _T1_probation.move_to_end(key, last=True)
-        else:
-            # Promote to protected
-            _T1_probation.pop(key, None)
-            _T2_protected[key] = True
+    _update_signals(False, cache_snapshot)
+
+    k = obj.key
+    _inc_freq(k)
+
+    plan = _admit_plan.pop(k, 'window')
+    if plan == 'main' and not _scan_mode:
+        _move_to_P(k)
     else:
-        # Metadata miss: treat as hot and place in T2
-        _T2_protected[key] = True
-
-    _demote_protected_if_needed(cache_snapshot, avoid_key=key)
-
-    # Ghost cleanup
-    if key in _B1_ghost:
-        _B1_ghost.pop(key, None)
-    if key in _B2_ghost:
-        _B2_ghost.pop(key, None)
-    _ghost_trim()
-
-def update_after_insert(cache_snapshot, obj):
-    '''
-    On miss and insert:
-    - Update EWMA and age frequencies.
-    - If key in ghosts: momentum-adjust p; fresh ghosts re-admit to T2 (seed freq), stale to T1.
-    - Else: insert to T1; during guard/scan or poor locality, place at T1 LRU; gently lower p in these phases (with cooldown).
-    '''
-    _ensure_capacity(cache_snapshot)
-    _maybe_age(cache_snapshot)
-    _update_activity(False, cache_snapshot)
-
-    key = obj.key
-    now = cache_snapshot.access_count
-    m_key_timestamp[key] = now
-
-    in_b1 = key in _B1_ghost
-    in_b2 = key in _B2_ghost
-
-    fresh_window = max(1, int(_FRESH_WINDOW_RATIO * _cap_est))
-
-    if in_b1 or in_b2:
-        # Compute step based on opposing ghost sizes
-        if in_b1:
-            step = max(1.0, float(len(_B2_ghost)) / max(1.0, float(len(_B1_ghost))))
-            ev_ts = _B1_ghost.get(key, None)
-            age = (now - ev_ts) if isinstance(ev_ts, int) else (fresh_window + 1)
-            fresh = age <= fresh_window
-            _adjust_p(+1, step, now, freshness_scale=(1.2 if fresh else 1.0), force=True)
-            _B1_ghost.pop(key, None)
-            if fresh:
-                # Admit to T2 as recently valuable
-                _T2_protected[key] = True
-                _freq[key] = max(3, min(_FREQ_MAX, _freq.get(key, 0) + 2))
-                _demote_protected_if_needed(cache_snapshot, avoid_key=key)
-            else:
-                _T1_probation[key] = True
-                _freq[key] = _freq.get(key, 0)
-        else:
-            step = max(1.0, float(len(_B1_ghost)) / max(1.0, float(len(_B2_ghost))))
-            ev_ts = _B2_ghost.get(key, None)
-            age = (now - ev_ts) if isinstance(ev_ts, int) else (fresh_window + 1)
-            fresh = age <= fresh_window
-            _adjust_p(-1, step, now, freshness_scale=(1.2 if fresh else 1.0), force=True)
-            _B2_ghost.pop(key, None)
-            if fresh:
-                _T2_protected[key] = True
-                _freq[key] = max(3, min(_FREQ_MAX, _freq.get(key, 0) + 2))
-                _demote_protected_if_needed(cache_snapshot, avoid_key=key)
-            else:
-                _T1_probation[key] = True
-                _freq[key] = _freq.get(key, 0)
-    else:
-        # New key: insert into T1
-        _T1_probation[key] = True
-        _freq[key] = _freq.get(key, 0)
-        # Guard, scan and poor-locality handling: bias newcomer colder
-        t1_over = len(_T1_probation) > int(round(_p_target))
-        poor_locality = (_hit_ewma < 0.2)
-        if (_last_victim_strength >= _VICTIM_GUARD_THRESH) or (now <= _scan_until) or poor_locality or t1_over:
-            _T1_probation.move_to_end(key, last=False)
-            # Gently lower p in scan or poor-locality phases to keep pressure in T1 (cooldowned)
-            if (now <= _scan_until) or poor_locality:
-                _adjust_p(-1, max(1.0, 0.05 * float(_cap_est)), now, force=False)
-
-    # Avoid duplicates across structures
-    if key in _T1_probation and key in _T2_protected:
-        _T1_probation.pop(key, None)
-    if key in _B1_ghost:
-        _B1_ghost.pop(key, None)
-    if key in _B2_ghost:
-        _B2_ghost.pop(key, None)
-    _ghost_trim()
+        _move_to_W(k)
+        # Bias to LRU when scanning to shed quickly
+        if _scan_mode:
+            # Move to LRU position
+            try:
+                _W_window.move_to_end(k, last=False)
+            except Exception:
+                pass
+
+    _rebalance_protected()
+
 
 def update_after_evict(cache_snapshot, obj, evicted_obj):
-    '''
+    """
     After eviction:
-    - Remove from resident segment and put into the appropriate ghost with timestamp.
-    - Track victim strength and set a short admission guard when a strong T2 victim is evicted.
-    - Clean frequency and timestamp entries.
-    '''
-    _ensure_capacity(cache_snapshot)
-    key = evicted_obj.key
-    now = cache_snapshot.access_count
-
-    was_t1 = key in _T1_probation
-    was_t2 = key in _T2_protected
-
-    fval = _freq.get(key, 0)
-    strength = float(fval) + (2.0 if was_t2 else 0.0)
-    global _last_victim_strength, _guard_until
-    _last_victim_strength = strength
-
-    if was_t1:
-        _T1_probation.pop(key, None)
-        _B1_ghost[key] = now
-    elif was_t2:
-        _T2_protected.pop(key, None)
-        _B2_ghost[key] = now
-        if fval >= 2:
-            _guard_until = now + max(1, _cap_est // 2)
-    else:
-        # Unknown residency; default to B1 ghost
-        _B1_ghost[key] = now
-
-    m_key_timestamp.pop(key, None)
-    _freq.pop(key, None)
-    _ghost_trim()
+    - Remove evicted key from its segment and metadata.
+    - No ghosts are kept; TinyLFU retains decayed history implicitly.
+    """
+    _ensure_params(cache_snapshot)
+    k = evicted_obj.key
+
+    if k in _W_window:
+        _W_window.pop(k, None)
+    if k in _P_prob:
+        _P_prob.pop(k, None)
+    if k in _S_prot:
+        _S_prot.pop(k, None)
+    _seg.pop(k, None)
+    _freq.pop(k, None)
+
+    # If an admission plan existed for the incoming key, keep it for update_after_insert
+    # (nothing else to do here)
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate