<NAME>
arc_srlu_fast_promo_no_demote_scan_tuning
</NAME>

<DESCRIPTION>
I introduce three synergistic improvements targeted at lowering miss rates across diverse workloads, especially those with scans and phase changes:

1) Freshness-tiered ghost readmission with fast-promotion grace:
   - On B1/B2 ghost hits, compute a freshness weight w = 1 - age/fresh_window. If very fresh (w ≥ 0.66), re-admit directly to protected (T2) with seeded frequency. If moderately fresh (0.33 ≤ w < 0.66), re-admit to probation (T1) MRU but grant a fast-promotion window during which the next hit promotes immediately to T2, even in scan mode. Else, admit to T1 LRU. This reduces premature T2 pollution while retaining agility for near-working-set items.

2) No-demote shielding for new promotions/readmissions:
   - After promoting or freshly re-admitting hot keys, apply a temporary no-demote window that demote logic respects. This stabilizes protected contents during locality bursts and avoids oscillations. Implemented by skipping protected LRU keys under active no-demote protection.

3) Momentum-smart ARC p-adaptation and scan-aware evictions:
   - Enhance p updates with sign-sensitive momentum: halve momentum on sign flips and adjust steps by freshness while damping increases and amplifying decreases during scans, reducing overreaction. In evict(), protect T2 in poor locality and when small, biasing evictions toward T1 to keep multi-hit items resident.

Additionally, I add gentle, periodic shedding of stale T2 tail frequency under poor hit rate to recover from degraded states faster.

These changes strengthen scan resistance, reduce protected churn, and improve re-reference recognition, improving hit rates without heavy overhead.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
# Tunables
_P_INIT_RATIO = 0.30             # initial share for T1
_FREQ_MAX = 7                    # 3-bit saturating counter
_FRESH_WINDOW_RATIO = 0.5        # ghost freshness window = 0.5 * cap
_SCAN_TRIGGER_INS = 0.7          # insert EWMA threshold
_SCAN_TRIGGER_HIT = 0.15         # hit EWMA threshold
_SCAN_WINDOW_MULT = 1.0          # scan window length ~= cap accesses
=======
# Tunables
_P_INIT_RATIO = 0.30             # initial share for T1
_FREQ_MAX = 7                    # 3-bit saturating counter
_FRESH_WINDOW_RATIO = 0.5        # ghost freshness window = 0.5 * cap
_SCAN_TRIGGER_INS = 0.7          # insert EWMA threshold
_SCAN_TRIGGER_HIT = 0.15         # hit EWMA threshold
_SCAN_WINDOW_MULT = 1.0          # scan window length ~= cap accesses

# Freshness-tiered fast promotion and no-demote shielding
_FAST_PROMOTE_WINDOW_MULT = 0.5  # fraction of fresh window for fast promotion grace
_NO_DEMOTE_WINDOW_MULT = 0.5     # fraction of fresh window for no-demote grace
_fast_promote_until = {}          # key -> time until immediate promotion from T1 is allowed
_no_demote_until = {}             # key -> time until demotion from T2 is disallowed

# Momentum helper
_p_last_sign = 0
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def _maybe_age(cache_snapshot):
    """Periodically age frequencies to avoid stale bias."""
    global _last_age_tick
    _ensure_capacity(cache_snapshot)
    now = cache_snapshot.access_count
    if now - _last_age_tick >= max(1, _cap_est):
        for k in list(_freq.keys()):
            newf = _freq.get(k, 0) // 2
            if newf <= 0:
                _freq.pop(k, None)
            else:
                _freq[k] = newf
        _last_age_tick = now
=======
def _maybe_age(cache_snapshot):
    """Periodically age frequencies to avoid stale bias."""
    global _last_age_tick
    _ensure_capacity(cache_snapshot)
    now = cache_snapshot.access_count
    if now - _last_age_tick >= max(1, _cap_est):
        # Global decay
        for k in list(_freq.keys()):
            newf = _freq.get(k, 0) // 2
            if newf <= 0:
                _freq.pop(k, None)
            else:
                _freq[k] = newf
        # Under poor locality or during scans, shed some protection by cooling T2 tail
        if (_hit_ewma < 0.2) or (now <= _scan_until):
            tail_n = max(1, len(_T2_protected) // 10)
            cnt = 0
            for k in _lru_iter(_T2_protected):
                f = _freq.get(k, 0)
                if f > 0:
                    _freq[k] = f - 1
                cnt += 1
                if cnt >= tail_n:
                    break
        _last_age_tick = now
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def _adjust_p(sign, step, now, freshness_scale=1.0):
    """Momentum-based adjustment of ARC's p with clamping."""
    global _p_target, _p_momentum, _p_last_update_tick
    # Scale step by freshness and bound to 0.25*cap to avoid wild swings
    bounded = min(max(1.0, float(step) * float(freshness_scale)), max(1.0, 0.25 * float(_cap_est)))
    _p_momentum = 0.5 * _p_momentum + float(sign) * bounded
    _p_target += _p_momentum
    if _p_target < 0.0:
        _p_target = 0.0
        _p_momentum = 0.0
    if _p_target > float(_cap_est):
        _p_target = float(_cap_est)
        _p_momentum = 0.0
    _p_last_update_tick = now
=======
def _adjust_p(sign, step, now, freshness_scale=1.0):
    """Momentum-based adjustment of ARC's p with clamping and scan-aware damping."""
    global _p_target, _p_momentum, _p_last_update_tick, _p_last_sign
    sgn = 1 if sign >= 0 else -1
    # Base step scaled by freshness
    adj = float(step) * float(freshness_scale)
    # Scan-aware damping/amplification
    if now <= _scan_until:
        if sgn > 0:
            adj *= 0.5  # damp p increases during scans
        else:
            adj *= 1.2  # amplify p decreases during scans
    # Bound to avoid wild swings
    bounded = min(max(1.0, adj), max(1.0, 0.25 * float(_cap_est)))
    # Halve momentum on sign flip to stabilize
    if _p_last_sign != 0 and _p_last_sign != sgn:
        _p_momentum *= 0.5
    _p_last_sign = sgn
    _p_momentum = 0.5 * _p_momentum + float(sgn) * bounded
    _p_target += _p_momentum
    if _p_target < 0.0:
        _p_target = 0.0
        _p_momentum = 0.0
    if _p_target > float(_cap_est):
        _p_target = float(_cap_est)
        _p_momentum = 0.0
    _p_last_update_tick = now
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def _demote_protected_if_needed(cache_snapshot, avoid_key=None):
    """Keep T2 size within ARC target by demoting LRU entries to T1 MRU."""
    _ensure_capacity(cache_snapshot)
    t1_target = int(round(_p_target))
    t2_target = max(_cap_est - t1_target, 0)
    while len(_T2_protected) > t2_target:
        # LRU of T2
        lru = None
        for k in _lru_iter(_T2_protected):
            if k != avoid_key and k in cache_snapshot.cache:
                lru = k
                break
        if lru is None:
            break
        _T2_protected.pop(lru, None)
        _T1_probation[lru] = True  # demoted MRU in T1
=======
def _demote_protected_if_needed(cache_snapshot, avoid_key=None):
    """Keep T2 size within ARC target by demoting LRU entries to T1 MRU, respecting no-demote grace."""
    _ensure_capacity(cache_snapshot)
    t1_target = int(round(_p_target))
    t2_target = max(_cap_est - t1_target, 0)
    now = cache_snapshot.access_count
    while len(_T2_protected) > t2_target:
        # Find first demotable LRU in T2 not under protection
        lru = None
        for k in _lru_iter(_T2_protected):
            if k == avoid_key or (k not in cache_snapshot.cache):
                continue
            if _no_demote_until.get(k, 0) > now:
                continue
            lru = k
            break
        if lru is None:
            break
        _T2_protected.pop(lru, None)
        _T1_probation[lru] = True  # demoted MRU in T1
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    '''
    Evict using ARC replace with dynamic sampling and scan bias:
    - Prefer T1 when |T1| > p or when upcoming key is in B2 and |T1| == p.
    - During scan window, always prefer T1 if non-empty.
    - Within the chosen segment, sample a few LRU entries and pick (freq asc, timestamp asc).
    '''
    _ensure_capacity(cache_snapshot)

    t1_size = len(_T1_probation)
    t2_size = len(_T2_protected)
    x_in_b2 = (obj is not None) and (obj.key in _B2_ghost)
    choose_t1 = (t1_size >= 1) and ((x_in_b2 and t1_size == int(round(_p_target))) or (t1_size > _p_target))

    # Scan bias: keep evictions in probation when scanning
    if cache_snapshot.access_count <= _scan_until and t1_size > 0:
        choose_t1 = True

    # Adaptive sampling sizes based on pressure and scan
    cap = max(1, _cap_est)
    t1_pressure = (t1_size > _p_target + 0.1 * cap) or (cache_snapshot.access_count <= _scan_until)
    t2_pressure = (t2_size > (cap - int(round(_p_target)))) or False

    T1_SAMPLE = 1 if t1_pressure else 2
    if cache_snapshot.access_count <= _scan_until:
        T1_SAMPLE = 1
    T2_SAMPLE = 5 if t2_pressure else 3
    # If the overall recent hit rate is low, reduce T2 sampling slightly
    if _hit_ewma < 0.2:
        T2_SAMPLE = max(2, T2_SAMPLE - 1)

    victim_key = None
    if choose_t1 and t1_size > 0:
        victim_key = _pick_from(_T1_probation, T1_SAMPLE, cache_snapshot)
    if victim_key is None and t2_size > 0:
        victim_key = _pick_from(_T2_protected, T2_SAMPLE, cache_snapshot)
    if victim_key is None and t1_size > 0:
        victim_key = _pick_from(_T1_probation, T1_SAMPLE, cache_snapshot)
    if victim_key is None:
        victim_key = _fallback_choose(cache_snapshot)
    return victim_key
=======
def evict(cache_snapshot, obj):
    '''
    Evict using ARC replace with dynamic sampling and scan/poor-locality bias:
    - Prefer T1 when |T1| > p or when scanning or when T2 is too small.
    - Within the chosen segment, sample a few LRU entries and pick (freq asc, timestamp asc).
    '''
    _ensure_capacity(cache_snapshot)

    t1_size = len(_T1_probation)
    t2_size = len(_T2_protected)
    x_in_b2 = (obj is not None) and (obj.key in _B2_ghost)
    choose_t1 = (t1_size >= 1) and ((x_in_b2 and t1_size == int(round(_p_target))) or (t1_size > _p_target))

    now = cache_snapshot.access_count
    # Scan bias: keep evictions in probation when scanning
    if now <= _scan_until and t1_size > 0:
        choose_t1 = True

    # Protect T2 when it's small or recent hit rate is poor
    cap = max(1, _cap_est)
    min_t2 = max(1, cap // 5)
    if not choose_t1 and t1_size > 0 and (t2_size <= min_t2 or _hit_ewma < 0.2):
        choose_t1 = True

    # Adaptive sampling sizes based on pressure and scan
    t1_pressure = (t1_size > _p_target + 0.1 * cap) or (now <= _scan_until)
    t2_pressure = (t2_size > (cap - int(round(_p_target)))) or False

    T1_SAMPLE = 1 if t1_pressure else 2
    if now <= _scan_until:
        T1_SAMPLE = 1
    T2_SAMPLE = 5 if t2_pressure else 3
    # If the overall recent hit rate is low, reduce T2 sampling slightly
    if _hit_ewma < 0.2:
        T2_SAMPLE = max(2, T2_SAMPLE - 1)

    victim_key = None
    if choose_t1 and t1_size > 0:
        victim_key = _pick_from(_T1_probation, T1_SAMPLE, cache_snapshot)
    if victim_key is None and t2_size > 0:
        victim_key = _pick_from(_T2_protected, T2_SAMPLE, cache_snapshot)
    if victim_key is None and t1_size > 0:
        victim_key = _pick_from(_T1_probation, T1_SAMPLE, cache_snapshot)
    if victim_key is None:
        victim_key = _fallback_choose(cache_snapshot)
    return victim_key
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    '''
    On hit:
    - Update EWMA and age frequencies.
    - Increment frequency (saturating).
    - In scan mode: require two touches in T1 before promotion (first hit -> T1 MRU).
    - Otherwise: first hit in T1 promotes to T2.
    - Keep T2 within its ARC target via demotion.
    - Remove any ghost entries for this key.
    '''
    _ensure_capacity(cache_snapshot)
    _maybe_age(cache_snapshot)
    _update_activity(True, cache_snapshot)

    key = obj.key
    now = cache_snapshot.access_count
    m_key_timestamp[key] = now
    _freq[key] = min(_FREQ_MAX, _freq.get(key, 0) + 1)

    in_scan = now <= _scan_until

    if key in _T2_protected:
        _T2_protected.move_to_end(key, last=True)
    elif key in _T1_probation:
        if in_scan and _freq.get(key, 0) < 2:
            # First re-touch during scan: keep in T1 and move to MRU
            _T1_probation.move_to_end(key, last=True)
        else:
            # Promote to protected
            _T1_probation.pop(key, None)
            _T2_protected[key] = True
    else:
        # Metadata miss: treat as hot and place in T2
        _T2_protected[key] = True

    _demote_protected_if_needed(cache_snapshot, avoid_key=key)

    # Ghost cleanup
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
=======
def update_after_hit(cache_snapshot, obj):
    '''
    On hit:
    - Update EWMA and age frequencies.
    - Increment frequency (saturating).
    - Fast-promotion: if within fast window, immediate promotion to T2.
    - In scan mode: otherwise require two touches in T1 before promotion.
    - Keep T2 within its ARC target via demotion (respecting no-demote).
    - Remove any ghost entries for this key.
    '''
    _ensure_capacity(cache_snapshot)
    _maybe_age(cache_snapshot)
    _update_activity(True, cache_snapshot)

    key = obj.key
    now = cache_snapshot.access_count
    m_key_timestamp[key] = now
    _freq[key] = min(_FREQ_MAX, _freq.get(key, 0) + 1)

    in_scan = now <= _scan_until
    fast_until = _fast_promote_until.get(key, 0)
    fast_ok = now <= fast_until

    if key in _T2_protected:
        _T2_protected.move_to_end(key, last=True)
    elif key in _T1_probation:
        if fast_ok:
            # Immediate promotion due to fast-promo grace
            _fast_promote_until.pop(key, None)
            _T1_probation.pop(key, None)
            _T2_protected[key] = True
            # Shield from demotion briefly
            fresh_window = max(1, int(_FRESH_WINDOW_RATIO * _cap_est))
            _no_demote_until[key] = now + max(1, int(_NO_DEMOTE_WINDOW_MULT * fresh_window))
        elif in_scan and _freq.get(key, 0) < 2:
            # First re-touch during scan: keep in T1 and move to MRU
            _T1_probation.move_to_end(key, last=True)
        else:
            # Promote to protected
            _T1_probation.pop(key, None)
            _T2_protected[key] = True
            fresh_window = max(1, int(_FRESH_WINDOW_RATIO * _cap_est))
            _no_demote_until[key] = now + max(1, int(_NO_DEMOTE_WINDOW_MULT * fresh_window))
    else:
        # Metadata miss: treat as hot and place in T2
        _T2_protected[key] = True
        fresh_window = max(1, int(_FRESH_WINDOW_RATIO * _cap_est))
        _no_demote_until[key] = now + max(1, int(_NO_DEMOTE_WINDOW_MULT * fresh_window))

    _demote_protected_if_needed(cache_snapshot, avoid_key=key)

    # Ghost cleanup
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    '''
    On miss and insert:
    - Update EWMA and age frequencies.
    - If key in ghosts: momentum-adjust p; fresh ghosts re-admit to T2 (seed freq), stale to T1.
    - Else: insert to T1; during guard/scan, place at T1 LRU; also gently lower p in scan to bias T1 evictions.
    '''
    _ensure_capacity(cache_snapshot)
    _maybe_age(cache_snapshot)
    _update_activity(False, cache_snapshot)

    key = obj.key
    now = cache_snapshot.access_count
    m_key_timestamp[key] = now

    in_b1 = key in _B1_ghost
    in_b2 = key in _B2_ghost

    fresh_window = max(1, int(_FRESH_WINDOW_RATIO * _cap_est))

    if in_b1 or in_b2:
        # Compute step based on opposing ghost sizes
        if in_b1:
            step = max(1.0, float(len(_B2_ghost)) / max(1.0, float(len(_B1_ghost))))
            ev_ts = _B1_ghost.get(key, None)
            age = (now - ev_ts) if isinstance(ev_ts, int) else (fresh_window + 1)
            fresh = age <= fresh_window
            _adjust_p(+1, step, now, freshness_scale=(1.2 if fresh else 1.0))
            _B1_ghost.pop(key, None)
            if fresh:
                # Admit to T2 as recently valuable
                _T2_protected[key] = True
                _freq[key] = max(3, min(_FREQ_MAX, _freq.get(key, 0) + 2))
                _demote_protected_if_needed(cache_snapshot, avoid_key=key)
            else:
                _T1_probation[key] = True
                _freq[key] = _freq.get(key, 0)
        else:
            step = max(1.0, float(len(_B1_ghost)) / max(1.0, float(len(_B2_ghost))))
            ev_ts = _B2_ghost.get(key, None)
            age = (now - ev_ts) if isinstance(ev_ts, int) else (fresh_window + 1)
            fresh = age <= fresh_window
            _adjust_p(-1, step, now, freshness_scale=(1.2 if fresh else 1.0))
            _B2_ghost.pop(key, None)
            if fresh:
                _T2_protected[key] = True
                _freq[key] = max(3, min(_FREQ_MAX, _freq.get(key, 0) + 2))
                _demote_protected_if_needed(cache_snapshot, avoid_key=key)
            else:
                _T1_probation[key] = True
                _freq[key] = _freq.get(key, 0)
    else:
        # New key: insert into T1
        _T1_probation[key] = True
        _freq[key] = _freq.get(key, 0)
        # Guard and scan handling: bias newcomer colder
        if (_last_victim_strength >= _VICTIM_GUARD_THRESH) or (now <= _scan_until):
            _T1_probation.move_to_end(key, last=False)
            # During scan, gently lower p to keep pressure in T1
            if now <= _scan_until:
                _adjust_p(-1, max(1.0, 0.1 * float(_cap_est)), now)

    # Avoid duplicates across structures
    if key in _T1_probation and key in _T2_protected:
        _T1_probation.pop(key, None)
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
=======
def update_after_insert(cache_snapshot, obj):
    '''
    On miss and insert:
    - Update EWMA and age frequencies.
    - If key in ghosts: momentum-adjust p; freshness-tiered readmission:
        w >= 0.66 -> T2 with seeded freq and no-demote grace;
        0.33 <= w < 0.66 -> T1 MRU with fast-promotion grace;
        else -> T1 LRU.
    - Else: insert to T1; during guard/scan, place at T1 LRU; also gently lower p in scan to bias T1 evictions.
    '''
    _ensure_capacity(cache_snapshot)
    _maybe_age(cache_snapshot)
    _update_activity(False, cache_snapshot)

    key = obj.key
    now = cache_snapshot.access_count
    m_key_timestamp[key] = now

    in_b1 = key in _B1_ghost
    in_b2 = key in _B2_ghost

    fresh_window = max(1, int(_FRESH_WINDOW_RATIO * _cap_est))

    if in_b1 or in_b2:
        if in_b1:
            step = max(1.0, float(len(_B2_ghost)) / max(1.0, float(len(_B1_ghost))))
            ev_ts = _B1_ghost.get(key, None)
            age = (now - ev_ts) if isinstance(ev_ts, int) else (fresh_window + 1)
            w = max(0.0, min(1.0, 1.0 - (float(age) / float(fresh_window)) if fresh_window > 0 else 0.0))
            _adjust_p(+1, step, now, freshness_scale=(1.0 + 2.0 * w))
            _B1_ghost.pop(key, None)
        else:
            step = max(1.0, float(len(_B1_ghost)) / max(1.0, float(len(_B2_ghost))))
            ev_ts = _B2_ghost.get(key, None)
            age = (now - ev_ts) if isinstance(ev_ts, int) else (fresh_window + 1)
            w = max(0.0, min(1.0, 1.0 - (float(age) / float(fresh_window)) if fresh_window > 0 else 0.0))
            _adjust_p(-1, step, now, freshness_scale=(1.0 + 2.0 * w))
            _B2_ghost.pop(key, None)

        # Freshness-tiered placement
        if w >= 0.66:
            _T2_protected[key] = True
            _freq[key] = max(3, min(_FREQ_MAX, _freq.get(key, 0) + 2))
            _demote_protected_if_needed(cache_snapshot, avoid_key=key)
            _no_demote_until[key] = now + max(1, int(_NO_DEMOTE_WINDOW_MULT * fresh_window))
            _fast_promote_until.pop(key, None)
        elif w >= 0.33:
            _T1_probation[key] = True
            _T1_probation.move_to_end(key, last=True)
            _freq[key] = max(1, _freq.get(key, 0))
            _fast_promote_until[key] = now + max(1, int(_FAST_PROMOTE_WINDOW_MULT * fresh_window))
        else:
            _T1_probation[key] = True
            _T1_probation.move_to_end(key, last=False)
            _freq[key] = _freq.get(key, 0)
            _fast_promote_until.pop(key, None)
    else:
        # New key: insert into T1
        _T1_probation[key] = True
        _freq[key] = _freq.get(key, 0)
        # Guard and scan handling: bias newcomer colder
        if (_last_victim_strength >= _VICTIM_GUARD_THRESH) or (now <= _scan_until) or (now <= _guard_until):
            _T1_probation.move_to_end(key, last=False)
            # During scan, gently lower p to keep pressure in T1
            if now <= _scan_until:
                _adjust_p(-1, max(1.0, 0.1 * float(_cap_est)), now)

    # Avoid duplicates across structures
    if key in _T1_probation and key in _T2_protected:
        _T1_probation.pop(key, None)
    if key in _B1_ghost:
        _B1_ghost.pop(key, None)
    if key in _B2_ghost:
        _B2_ghost.pop(key, None)
    _ghost_trim()
>>>>>>> REPLACE

</DIFF>
<DIFF>
<<<<<<< SEARCH
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    After eviction:
    - Remove from resident segment and put into the appropriate ghost with timestamp.
    - Track victim strength and set a short admission guard when a strong T2 victim is evicted.
    - Clean frequency and timestamp entries.
    '''
    _ensure_capacity(cache_snapshot)
    key = evicted_obj.key
    now = cache_snapshot.access_count

    was_t1 = key in _T1_probation
    was_t2 = key in _T2_protected

    fval = _freq.get(key, 0)
    strength = float(fval) + (2.0 if was_t2 else 0.0)
    global _last_victim_strength, _guard_until
    _last_victim_strength = strength

    if was_t1:
        _T1_probation.pop(key, None)
        _B1_ghost[key] = now
    elif was_t2:
        _T2_protected.pop(key, None)
        _B2_ghost[key] = now
        if fval >= 2:
            _guard_until = now + max(1, _cap_est // 2)
    else:
        # Unknown residency; default to B1 ghost
        _B1_ghost[key] = now

    m_key_timestamp.pop(key, None)
    _freq.pop(key, None)
    _ghost_trim()
=======
def update_after_evict(cache_snapshot, obj, evicted_obj):
    '''
    After eviction:
    - Remove from resident segment and put into the appropriate ghost with timestamp.
    - Track victim strength and set a short admission guard when a strong T2 victim is evicted.
    - Clean frequency and timestamp entries.
    '''
    _ensure_capacity(cache_snapshot)
    key = evicted_obj.key
    now = cache_snapshot.access_count

    was_t1 = key in _T1_probation
    was_t2 = key in _T2_protected

    fval = _freq.get(key, 0)
    strength = float(fval) + (2.0 if was_t2 else 0.0)
    global _last_victim_strength, _guard_until
    _last_victim_strength = strength

    if was_t1:
        _T1_probation.pop(key, None)
        _B1_ghost[key] = now
    elif was_t2:
        _T2_protected.pop(key, None)
        _B2_ghost[key] = now
        if fval >= 2:
            _guard_until = now + max(1, _cap_est // 2)
    else:
        # Unknown residency; default to B1 ghost
        _B1_ghost[key] = now

    # Clean transient control state
    _fast_promote_until.pop(key, None)
    _no_demote_until.pop(key, None)

    m_key_timestamp.pop(key, None)
    _freq.pop(key, None)
    _ghost_trim()
>>>>>>> REPLACE

</DIFF>