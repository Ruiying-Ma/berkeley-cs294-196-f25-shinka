<NAME>
slru_tlfu_age_bias_and_stronger_scan_guard
</NAME>

<DESCRIPTION>
I introduce four targeted improvements to the existing SLRU+TinyLFU hybrid to reduce cache misses across diverse workloads:

1) Age-biased and stale-protected-aware victim selection:
   - Modify _victim_tuple to include epoch age in the recency term and allow evicting stale protected entries (score==0 with sufficient age) before probation entries. This prevents protected from hoarding expired items.

2) Stronger scan guard and better segment balance:
   - Increase scan-mode persistence to two windows, biasing eviction towards probation longer during scans.
   - Lower default protected fraction from 0.8 to 0.7 to avoid over-allocating protected under mixed or scan-like patterns.
   - Increase sampling from protected when it dominates, improving victim choice accuracy.

3) Smarter promotions/admissions:
   - Two-touch gating now applies only to cold items (score<2) to avoid delaying promotion of real hot keys.
   - On insert, only place into protected if very strong frequency (score>=3) or protected-ghost signal; cold new items (score==0) enter probation at the LRU side unconditionally to reduce pollution.

4) Better ghost signal horizon:
   - Slightly widen ghost recency horizon from 2 to 3 epochs to better capture short phase shifts without overreacting.

These changes work cohesively: the eviction candidate ordering becomes more robust to stale protected entries, scans are recognized and handled longer, cold items are prevented from polluting the top of the stack, and ghost signals are a bit more effective. Overall this should reduce miss rates on low-locality and scan-heavy traces while preserving strong locality performance.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
_PROTECTED_FRAC = 0.8        # target fraction of cache to allocate to protected segment
=======
_PROTECTED_FRAC = 0.7        # target fraction of cache to allocate to protected segment
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
        if unique_density > 0.7 and hit_rate < 0.2:
            _scan_mode = True
            _scan_mode_epochs_left = 1
=======
        if unique_density > 0.7 and hit_rate < 0.2:
            _scan_mode = True
            _scan_mode_epochs_left = 2
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def _victim_tuple(key, seg, rec_idx):
    """Tuple for comparing eviction candidates. Lower is colder."""
    # Prefer lower frequency; tie-break by segment (probation preferred), then by older recency (smaller index)
    return (_score(key), 0 if seg == 'prob' else 1, rec_idx, key)
=======
def _victim_tuple(key, seg, rec_idx):
    """Tuple for comparing eviction candidates. Lower is colder."""
    # Include decayed frequency score and an age-biased recency term.
    # Also treat stale protected (score==0 and aged) similar to probation for eviction preference.
    s = _score(key)
    ce = _refcnt.get(key, (0, _epoch))
    age = max(0, _epoch - ce[1])
    # Segment bias: probation preferred (0), protected (1); but stale protected gets reduced bias.
    if seg == 'prot' and s == 0 and age >= 2:
        seg_bias = 0  # allow evicting stale protected before fresh probation
    else:
        seg_bias = 0 if seg == 'prob' else 1
    # Age-amplified recency index to prefer much older entries
    rec = rec_idx + min(50, age * 2)
    return (s, seg_bias, rec, key)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    # Keep metadata consistent and properly segmented before choosing a victim
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track key for scan detection unique density
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    # Clean up stale entries (if any)
    for k in list(_probation.keys()):
        if k not in cache_snapshot.cache:
            _probation.pop(k, None)
            _key_seg.pop(k, None)
    for k in list(_protected.keys()):
        if k not in cache_snapshot.cache:
            _protected.pop(k, None)
            _key_seg.pop(k, None)

    # If metadata is empty, fallback
    if not cache_snapshot.cache:
        return None

    # Ghost-driven overrides
    g_prot_epoch = _ghost_protected.get(obj.key)
    g_prob_epoch = _ghost_probation.get(obj.key)
    recent_prot_ghost = (g_prot_epoch is not None) and (_epoch - g_prot_epoch <= 2)
    recent_prob_ghost = (g_prob_epoch is not None) and (_epoch - g_prob_epoch <= 2)

    # Strong scan handling: prefer evicting from probation during scans
    if _scan_mode and _probation:
        # Evict LRU of probation to preserve protected segment during scans
        try:
            k, _ = next(iter(_probation.items()))
            return k
        except StopIteration:
            pass

    # If incoming was recently in protected ghost, free from probation to re-protect quickly
    if recent_prot_ghost and _probation:
        try:
            k, _ = next(iter(_probation.items()))
            return k
        except StopIteration:
            pass

    # If incoming was recently in probation ghost and protected dominates, free from protected
    if recent_prob_ghost and _protected and (len(_protected) > len(_probation)):
        try:
            k, _ = next(iter(_protected.items()))
            return k
        except StopIteration:
            pass

    # Adaptive sampling sizes
    prob_sample = _BASE_PROB_SAMPLE
    prot_sample = _BASE_PROT_SAMPLE
    if _scan_mode:
        prob_sample += 1
        prot_sample = max(1, prot_sample - 1)
    if len(_probation) > len(_protected) + 2:
        prob_sample += 1

    # Build candidate tuples from both segments' LRU sides
    candidates = []
    # Probation candidates
    pkeys = _sample_lru_keys(_probation, prob_sample)
    for idx, pk in enumerate(pkeys):
        if pk in cache_snapshot.cache:
            candidates.append(_victim_tuple(pk, 'prob', idx))
    # Protected candidates
    tkeys = _sample_lru_keys(_protected, prot_sample)
    for idx, tk in enumerate(tkeys):
        if tk in cache_snapshot.cache:
            candidates.append(_victim_tuple(tk, 'prot', idx))

    if not candidates:
        # Fallback: pick any key from cache if metadata got desynced
        return next(iter(cache_snapshot.cache.keys()))

    # Choose coldest by (score, segment preference, recency)
    best = min(candidates)
    candid_obj_key = best[3]
    victim_from_protected = (_key_seg.get(candid_obj_key) == 'prot')

    # Adaptive tuning: if we are forced to evict from protected, reduce its target fraction slightly
    if victim_from_protected:
        _decrease_protected()

    return candid_obj_key
=======
def evict(cache_snapshot, obj):
    '''
    This function defines how the algorithm chooses the eviction victim.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The new object that needs to be inserted into the cache.
    - Return:
        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
    '''
    # Keep metadata consistent and properly segmented before choosing a victim
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    _rebalance(cache_snapshot)

    # Track key for scan detection unique density
    try:
        _epoch_unique.add(obj.key)
    except Exception:
        pass

    # Clean up stale entries (if any)
    for k in list(_probation.keys()):
        if k not in cache_snapshot.cache:
            _probation.pop(k, None)
            _key_seg.pop(k, None)
    for k in list(_protected.keys()):
        if k not in cache_snapshot.cache:
            _protected.pop(k, None)
            _key_seg.pop(k, None)

    # If metadata is empty, fallback
    if not cache_snapshot.cache:
        return None

    # Ghost-driven overrides
    g_prot_epoch = _ghost_protected.get(obj.key)
    g_prob_epoch = _ghost_probation.get(obj.key)
    recent_prot_ghost = (g_prot_epoch is not None) and (_epoch - g_prot_epoch <= 3)
    recent_prob_ghost = (g_prob_epoch is not None) and (_epoch - g_prob_epoch <= 3)

    # Strong scan handling: prefer evicting from probation during scans
    if _scan_mode and _probation:
        # Evict LRU of probation to preserve protected segment during scans
        try:
            k, _ = next(iter(_probation.items()))
            return k
        except StopIteration:
            pass

    # If incoming was recently in protected ghost, free from probation to re-protect quickly
    if recent_prot_ghost and _probation:
        try:
            k, _ = next(iter(_probation.items()))
            return k
        except StopIteration:
            pass

    # If incoming was recently in probation ghost and protected dominates, free from protected
    if recent_prob_ghost and _protected and (len(_protected) > len(_probation)):
        try:
            k, _ = next(iter(_protected.items()))
            return k
        except StopIteration:
            pass

    # Adaptive sampling sizes
    prob_sample = _BASE_PROB_SAMPLE
    prot_sample = _BASE_PROT_SAMPLE
    if _scan_mode:
        prob_sample += 1
        prot_sample = max(1, prot_sample - 1)
    if len(_probation) > len(_protected) + 2:
        prob_sample += 1
    if len(_protected) > len(_probation) + 5:
        prot_sample += 1

    # Build candidate tuples from both segments' LRU sides
    candidates = []
    # Probation candidates
    pkeys = _sample_lru_keys(_probation, prob_sample)
    for idx, pk in enumerate(pkeys):
        if pk in cache_snapshot.cache:
            candidates.append(_victim_tuple(pk, 'prob', idx))
    # Protected candidates
    tkeys = _sample_lru_keys(_protected, prot_sample)
    for idx, tk in enumerate(tkeys):
        if tk in cache_snapshot.cache:
            candidates.append(_victim_tuple(tk, 'prot', idx))

    if not candidates:
        # Fallback: pick any key from cache if metadata got desynced
        return next(iter(cache_snapshot.cache.keys()))

    # Choose coldest by (score, segment preference, age-biased recency)
    best = min(candidates)
    candid_obj_key = best[3]
    victim_from_protected = (_key_seg.get(candid_obj_key) == 'prot')

    # Adaptive tuning: if we are forced to evict from protected, reduce its target fraction slightly
    if victim_from_protected:
        _decrease_protected()

    return candid_obj_key
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)

    # Determine if locality is poor: low hit rate or high uniqueness in window
    window = max(1, _DECAY_WINDOW)
    try:
        current_hit_rate = cache_snapshot.hit_count / max(1.0, float(cache_snapshot.access_count))
    except Exception:
        current_hit_rate = 0.0
    unique_density = min(1.0, len(_epoch_unique) / float(window))
    use_two_touch = _scan_mode or (current_hit_rate < 0.25) or (unique_density > 0.6)

    if seg == 'prob':
        if use_two_touch:
            # Time-bounded two-touch gating: second touch within one epoch promotes
            last = _touched_once.get(k)
            if last is not None and (_epoch - last) <= 1:
                _touched_once.pop(k, None)
                _probation.pop(k, None)
                _protected[k] = None  # MRU
                _key_seg[k] = 'prot'
            else:
                _touched_once[k] = _epoch
                # Refresh to MRU of probation
                if k in _probation:
                    _probation.move_to_end(k, last=True)
                else:
                    _probation[k] = None
        else:
            # Promote to protected on first hit when locality is decent
            _probation.pop(k, None)
            _protected[k] = None  # inserted at MRU
            _key_seg[k] = 'prot'
            _increase_protected()  # hits in probation signal benefit from a larger protected segment
    elif seg == 'prot':
        # Refresh recency in protected
        if k in _protected:
            _protected.move_to_end(k, last=True)
        else:
            # If somehow missing from the structure, reinsert into protected
            _protected[k] = None
            _key_seg[k] = 'prot'
        # Clear any stale two-touch marker
        _touched_once.pop(k, None)
    else:
        # Unknown key (shouldn't happen on hit).
        # In poor locality, keep in probation with refresh; otherwise, promote.
        if use_two_touch:
            _probation[k] = None
            _key_seg[k] = 'prob'
            _probation.move_to_end(k, last=True)
        else:
            _probation[k] = None
            _key_seg[k] = 'prob'
            _probation.pop(k, None)
            _protected[k] = None
            _key_seg[k] = 'prot'
            _increase_protected()

    _rebalance(cache_snapshot)
=======
def update_after_hit(cache_snapshot, obj):
    '''
    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object accessed during the cache hit.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)

    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    seg = _key_seg.get(k)

    # Determine if locality is poor: low hit rate or high uniqueness in window
    window = max(1, _DECAY_WINDOW)
    try:
        current_hit_rate = cache_snapshot.hit_count / max(1.0, float(cache_snapshot.access_count))
    except Exception:
        current_hit_rate = 0.0
    unique_density = min(1.0, len(_epoch_unique) / float(window))
    use_two_touch = _scan_mode or (current_hit_rate < 0.25) or (unique_density > 0.6)

    s = _score(k)

    if seg == 'prob':
        if use_two_touch and s < 2:
            # Time-bounded two-touch gating: second touch within one epoch promotes
            last = _touched_once.get(k)
            if last is not None and (_epoch - last) <= 1:
                _touched_once.pop(k, None)
                _probation.pop(k, None)
                _protected[k] = None  # MRU
                _key_seg[k] = 'prot'
            else:
                _touched_once[k] = _epoch
                # Refresh to MRU of probation
                if k in _probation:
                    _probation.move_to_end(k, last=True)
                else:
                    _probation[k] = None
        else:
            # Promote to protected on first hit when locality is decent or when clearly hot
            _probation.pop(k, None)
            _protected[k] = None  # inserted at MRU
            _key_seg[k] = 'prot'
            _increase_protected()  # hits in probation signal benefit from a larger protected segment
    elif seg == 'prot':
        # Refresh recency in protected
        if k in _protected:
            _protected.move_to_end(k, last=True)
        else:
            # If somehow missing from the structure, reinsert into protected
            _protected[k] = None
            _key_seg[k] = 'prot'
        # Clear any stale two-touch marker
        _touched_once.pop(k, None)
        # If protected is much smaller than probation, slightly expand it
        if len(_protected) * 2 < max(1, len(_probation)):
            _increase_protected()
    else:
        # Unknown key (shouldn't happen on hit).
        # In poor locality, keep in probation with refresh for cold items; otherwise, promote.
        if use_two_touch and s < 2:
            _probation[k] = None
            _key_seg[k] = 'prob'
            _probation.move_to_end(k, last=True)
        else:
            _probation[k] = None
            _key_seg[k] = 'prob'
            _probation.pop(k, None)
            _protected[k] = None
            _key_seg[k] = 'prot'
            _increase_protected()

    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide segment placement using ghost history (segment-aware)
    g_prot_epoch = _ghost_protected.get(k)
    g_prob_epoch = _ghost_probation.get(k)
    recent_prot_ghost = (g_prot_epoch is not None) and (_epoch - g_prot_epoch <= 2)
    recent_prob_ghost = (g_prob_epoch is not None) and (_epoch - g_prob_epoch <= 2)

    # Reset any existing placement
    if _key_seg.get(k) == 'prot':
        _protected.pop(k, None)
    else:
        _probation.pop(k, None)

    # Adjust protected fraction based on ghost admissions (ARC-like tuning)
    if recent_prot_ghost:
        _increase_protected()
    elif recent_prob_ghost:
        _decrease_protected()

    # Locality signal from current window
    window = max(1, _DECAY_WINDOW)
    try:
        current_hit_rate = cache_snapshot.hit_count / max(1.0, float(cache_snapshot.access_count))
    except Exception:
        current_hit_rate = 0.0
    unique_density = min(1.0, len(_epoch_unique) / float(window))
    high_uniqueness = unique_density > 0.6
    poor_locality = current_hit_rate < 0.25 or high_uniqueness

    s = _score(k)

    if _scan_mode:
        # Scan resistance: insert at probation LRU to minimize pollution,
        # require two-touch before promotion via update_after_hit.
        _probation[k] = None
        _probation.move_to_end(k, last=False)  # LRU side
        _key_seg[k] = 'prob'
    else:
        if recent_prot_ghost or s >= 2:
            # Re-admit into protected due to recent protected ghost hit or strong frequency
            _protected[k] = None
            _key_seg[k] = 'prot'
            _increase_protected()
        else:
            # Default admission into probation
            _probation[k] = None
            _key_seg[k] = 'prob'
            if recent_prob_ghost:
                # Slight boost for recently evicted probation ghost to accelerate useful re-references
                _probation.move_to_end(k, last=True)  # ensure MRU
                _inc(k)
            elif poor_locality and s == 0:
                # Bias towards LRU position when locality is poor and item is cold
                _probation.move_to_end(k, last=False)
            else:
                # Keep MRU position
                _probation.move_to_end(k, last=True)

    _rebalance(cache_snapshot)
=======
def update_after_insert(cache_snapshot, obj):
    '''
    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
    - Args:
        - `cache_snapshot`: A snapshot of the current cache state.
        - `obj`: The object that was just inserted into the cache.
    - Return: `None`
    '''
    _maybe_age(cache_snapshot)
    _sync_metadata(cache_snapshot)
    k = obj.key
    _inc(k)
    try:
        _epoch_unique.add(k)
    except Exception:
        pass

    # Decide segment placement using ghost history (segment-aware)
    g_prot_epoch = _ghost_protected.get(k)
    g_prob_epoch = _ghost_probation.get(k)
    recent_prot_ghost = (g_prot_epoch is not None) and (_epoch - g_prot_epoch <= 3)
    recent_prob_ghost = (g_prob_epoch is not None) and (_epoch - g_prob_epoch <= 3)

    # Reset any existing placement
    if _key_seg.get(k) == 'prot':
        _protected.pop(k, None)
    else:
        _probation.pop(k, None)

    # Adjust protected fraction based on ghost admissions (ARC-like tuning)
    if recent_prot_ghost:
        _increase_protected()
    elif recent_prob_ghost:
        _decrease_protected()

    # Locality signal from current window
    window = max(1, _DECAY_WINDOW)
    try:
        current_hit_rate = cache_snapshot.hit_count / max(1.0, float(cache_snapshot.access_count))
    except Exception:
        current_hit_rate = 0.0
    unique_density = min(1.0, len(_epoch_unique) / float(window))
    high_uniqueness = unique_density > 0.6
    poor_locality = current_hit_rate < 0.25 or high_uniqueness

    s = _score(k)

    if _scan_mode:
        # Scan resistance: insert at probation LRU to minimize pollution,
        # require two-touch before promotion via update_after_hit.
        _probation[k] = None
        _probation.move_to_end(k, last=False)  # LRU side
        _key_seg[k] = 'prob'
    else:
        if recent_prot_ghost or s >= 3:
            # Re-admit into protected due to recent protected ghost hit or strong frequency
            _protected[k] = None
            _key_seg[k] = 'prot'
            _increase_protected()
        else:
            # Default admission into probation
            _probation[k] = None
            _key_seg[k] = 'prob'
            if recent_prob_ghost:
                # Slight boost for recently evicted probation ghost to accelerate useful re-references
                _probation.move_to_end(k, last=True)  # ensure MRU
                _inc(k)
            elif s == 0:
                # Always bias cold items to the LRU to dampen scan pollution
                _probation.move_to_end(k, last=False)
            else:
                # Keep MRU position
                _probation.move_to_end(k, last=True)

    _rebalance(cache_snapshot)
>>>>>>> REPLACE

</DIFF>