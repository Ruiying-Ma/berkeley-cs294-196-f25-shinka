--- a/original.py
+++ b/original.py
@@ -1,172 +1,280 @@
 # EVOLVE-BLOCK-START
-"""Cache eviction algorithm for optimizing hit rates across multiple workloads"""
-
-# Segmented LRU (2Q-like) with a protected quota (SLRU-style) and conditional two-touch promotion:
-# - Newly inserted objects go to probationary.
-# - Promote to protected on hit; if protected is at/over target, require two touches to promote.
-# - Demote protected LRU when protected exceeds target to keep a healthy probation space.
-# - Evict: if protected exceeds target, evict protected LRU; else evict probation LRU first.
-m_ts = dict()                  # key -> last access timestamp
-m_probation = set()            # keys seen once (recently inserted)
-m_protected = set()            # keys with demonstrated reuse (promoted on hit)
-
-# Protected quota control
-m_target_protected = None      # target number of protected entries
-m_last_capacity = None         # last observed capacity (to re-init when changed)
-m_probation_hits = dict()      # key -> hit count while in probation (for two-touch when needed)
-
-def _init_targets(cache_snapshot):
-    global m_target_protected, m_last_capacity
-    cap = cache_snapshot.capacity or max(len(cache_snapshot.cache), 1)
-    if m_target_protected is None or m_last_capacity != cap:
-        m_target_protected = max(1, int(0.5 * cap))  # start balanced (50% protected)
-        m_last_capacity = cap
-
-def _oldest_key(candidates):
-    # Return the key with the smallest timestamp among candidates
-    return min(candidates, key=lambda k: m_ts.get(k, -1))
-
-def _enforce_protected_quota():
-    # Demote LRU from protected to probation until target is met
-    while m_target_protected is not None and len(m_protected) > m_target_protected:
-        demote_key = _oldest_key(m_protected)
-        m_protected.discard(demote_key)
-        m_probation.add(demote_key)
-        m_probation_hits.setdefault(demote_key, 0)
+"""Adaptive, modular cache eviction policy based on ARC with ghost lists.
+
+Structural redesign:
+- Encapsulate all policy state/logic in ARCPolicy class.
+- Maintain four OrderedDict segments: T1/T2 (resident), B1/B2 (ghosts).
+- Adaptive balancing parameter p tunes space split between T1 and T2.
+- REPLACE selects eviction side based on p and presence in B2 (ARC rule).
+- update_after_* keep metadata in sync after cache events.
+
+Why this helps:
+- ARC adapts to recency vs. frequency dynamically, resisting scans while keeping hot items.
+- Ghost lists capture recently evicted items to guide p updates, improving phase shift response.
+- OrderedDict yields efficient LRU behavior with clean modularity.
+"""
+
+from collections import OrderedDict
+
+class ARCPolicy:
+    def __init__(self):
+        # Resident LRU lists
+        self.T1 = OrderedDict()  # probationary (seen once)
+        self.T2 = OrderedDict()  # protected (reused)
+        # Ghost (non-resident) LRU lists
+        self.B1 = OrderedDict()  # evicted from T1
+        self.B2 = OrderedDict()  # evicted from T2
+
+        # Adaptive target for T1 size [0, c]
+        self.p = 0.0
+
+        # Metadata
+        self.ts = {}            # key -> last access timestamp (for fallback)
+        self.freq = {}          # key -> tiny frequency counter (optional boost)
+        self.last_capacity = None
+
+    # ---------- Internal utilities ----------
+    def _capacity(self, cache_snapshot):
+        cap = cache_snapshot.capacity or max(len(cache_snapshot.cache), 1)
+        return max(int(cap), 1)
+
+    def _init_or_update(self, cache_snapshot):
+        c = self._capacity(cache_snapshot)
+        if self.last_capacity != c:
+            # Clamp p and trim ghost sizes to 2c after capacity change
+            self.p = max(0.0, min(self.p, float(c)))
+            self._trim_ghosts_to(2 * c)
+            self.last_capacity = c
+        # Sync resident lists with actual cache keys (defensive)
+        self._sync_with_cache(cache_snapshot)
+
+    def _sync_with_cache(self, cache_snapshot):
+        keys_in_cache = set(cache_snapshot.cache.keys())
+        # Remove any resident entries not actually in cache
+        for od in (self.T1, self.T2):
+            to_remove = [k for k in od.keys() if k not in keys_in_cache]
+            for k in to_remove:
+                od.pop(k, None)
+        # Timestamps cleanup for non-present keys
+        for k in list(self.ts.keys()):
+            if k not in keys_in_cache and k not in self.B1 and k not in self.B2:
+                self.ts.pop(k, None)
+                self.freq.pop(k, None)
+
+    def _trim_ghosts_to(self, max_total):
+        # Ensure |T1| + |T2| + |B1| + |B2| <= max_total by trimming oldest ghosts
+        while (len(self.T1) + len(self.T2) + len(self.B1) + len(self.B2)) > max_total:
+            if self.B1:
+                self.B1.popitem(last=False)
+            elif self.B2:
+                self.B2.popitem(last=False)
+            else:
+                break
+
+    def _lru_key(self, odict: OrderedDict):
+        # Return LRU key (oldest) if exists, else None
+        try:
+            return next(iter(odict))
+        except StopIteration:
+            return None
+
+    def _replace_side(self, obj_key, c):
+        # ARC REPLACE rule: choose eviction from T1 or T2
+        len_t1 = len(self.T1)
+        p_int = int(round(self.p))
+        # If |T1| > p, evict from T1; if |T1| == p and obj âˆˆ B2, evict from T1; else from T2
+        if len_t1 > p_int or (len_t1 == p_int and obj_key in self.B2):
+            return 'T1'
+        else:
+            return 'T2'
+
+    def _record_access(self, key, now):
+        self.ts[key] = now
+        self.freq[key] = min(self.freq.get(key, 0) + 1, 7)  # tiny saturating counter
+
+    # ---------- Public policy interface ----------
+    def evict(self, cache_snapshot, obj):
+        self._init_or_update(cache_snapshot)
+        c = self._capacity(cache_snapshot)
+
+        # Choose victim according to ARC REPLACE, but ensure we pick a key actually in cache
+        keys_in_cache = set(cache_snapshot.cache.keys())
+
+        # If both resident lists empty (should not happen often), fallback to global oldest
+        if not self.T1 and not self.T2:
+            # Fallback: evict globally oldest (by timestamp) among actual cache keys
+            if not keys_in_cache:
+                return None
+            # If we have timestamps, use them; else arbitrary
+            candidates = list(keys_in_cache)
+            if self.ts:
+                return min(candidates, key=lambda k: self.ts.get(k, -1))
+            return next(iter(candidates))
+
+        side = self._replace_side(obj.key, c)
+        victim = None
+        if side == 'T1' and self.T1:
+            victim = self._lru_key(self.T1)
+        elif side == 'T2' and self.T2:
+            victim = self._lru_key(self.T2)
+        else:
+            # If chosen side empty (edge case), pick from the other; else any cached key
+            if self.T1:
+                victim = self._lru_key(self.T1)
+            elif self.T2:
+                victim = self._lru_key(self.T2)
+
+        # Defensive: ensure victim is in actual cache; otherwise fallback to any cached key
+        if victim is None or victim not in keys_in_cache:
+            # Try other list
+            alt = self._lru_key(self.T2 if side == 'T1' else self.T1)
+            if alt and alt in keys_in_cache:
+                victim = alt
+            else:
+                # Fallback: evict globally oldest
+                if not keys_in_cache:
+                    return None
+                candidates = list(keys_in_cache)
+                if self.ts:
+                    victim = min(candidates, key=lambda k: self.ts.get(k, -1))
+                else:
+                    victim = next(iter(candidates))
+        return victim
+
+    def update_after_hit(self, cache_snapshot, obj):
+        self._init_or_update(cache_snapshot)
+        now, key = cache_snapshot.access_count, obj.key
+        self._record_access(key, now)
+
+        # If in T1, promote to T2 MRU
+        if key in self.T1:
+            self.T1.pop(key, None)
+            self.T2[key] = True
+        elif key in self.T2:
+            # Refresh recency
+            self.T2.move_to_end(key, last=True)
+        else:
+            # Not tracked (metadata loss or sync), treat as protected to avoid premature eviction
+            self.T2[key] = True
+        # Keep resident sizes reasonable; if we somehow exceeded, demote from T2 to T1
+        c = self._capacity(cache_snapshot)
+        if (len(self.T1) + len(self.T2)) > c and self.T2:
+            # Demote oldest of T2 to T1 to preserve capacity accounting symmetry
+            demote = self._lru_key(self.T2)
+            if demote is not None:
+                self.T2.pop(demote, None)
+                self.T1[demote] = True
+
+    def update_after_insert(self, cache_snapshot, obj):
+        self._init_or_update(cache_snapshot)
+        now, key = cache_snapshot.access_count, obj.key
+        self._record_access(key, now)
+
+        c = self._capacity(cache_snapshot)
+
+        # If key was in ghost lists, adapt p and place into T2 (ARC)
+        if key in self.B1:
+            # Increase p
+            delta = max(1.0, len(self.B2) / float(max(1, len(self.B1))))
+            self.p = min(float(c), self.p + delta)
+            # Move from B1 to resident protected
+            self.B1.pop(key, None)
+            self.T2[key] = True
+        elif key in self.B2:
+            # Decrease p
+            delta = max(1.0, len(self.B1) / float(max(1, len(self.B2))))
+            self.p = max(0.0, self.p - delta)
+            # Move from B2 to resident protected
+            self.B2.pop(key, None)
+            self.T2[key] = True
+        else:
+            # New key: insert into T1 (probationary)
+            self.T1[key] = True
+
+        # Ensure |T1| + |T2| <= c by demoting if needed (defensive)
+        if (len(self.T1) + len(self.T2)) > c:
+            side = 'T1' if len(self.T1) > int(round(self.p)) else 'T2'
+            if side == 'T1' and self.T1:
+                k = self._lru_key(self.T1)
+                if k is not None:
+                    self.T1.pop(k, None)
+                    self.B1[k] = True
+            elif self.T2:
+                k = self._lru_key(self.T2)
+                if k is not None:
+                    self.T2.pop(k, None)
+                    self.B2[k] = True
+
+        # Trim ghosts: |T1| + |T2| + |B1| + |B2| <= 2c
+        self._trim_ghosts_to(2 * c)
+
+    def update_after_evict(self, cache_snapshot, obj, evicted_obj):
+        # Move evicted resident to appropriate ghost list
+        evk = evicted_obj.key
+
+        # Remove from resident lists if present and add to respective ghost
+        if evk in self.T1:
+            self.T1.pop(evk, None)
+            self.B1[evk] = True
+        elif evk in self.T2:
+            self.T2.pop(evk, None)
+            self.B2[evk] = True
+        else:
+            # If not in resident lists, just clear from ghosts to avoid overgrowth
+            self.B1.pop(evk, None)
+            self.B2.pop(evk, None)
+
+        # Cleanup tiny metadata; keep timestamp for ghosts only if we want, but keep simple
+        self.freq.pop(evk, None)
+        # Bound ghosts
+        c = self._capacity(cache_snapshot)
+        self._trim_ghosts_to(2 * c)
+
+
+# Global policy instance
+_policy = ARCPolicy()
 
 def evict(cache_snapshot, obj):
     '''
-    This function defines how the algorithm chooses the eviction victim.
-    - Args:
-        - `cache_snapshot`: A snapshot of the current cache state.
-        - `obj`: The new object that needs to be inserted into the cache.
-    - Return:
-        - `candid_obj_key`: The key of the cached object that will be evicted to make room for `obj`.
-    '''
-    global m_ts, m_probation, m_protected
-    _init_targets(cache_snapshot)
-
-    keys_in_cache = set(cache_snapshot.cache.keys())
-
-    # Keep metadata consistent with actual cache content
-    if m_probation:
-        m_probation.intersection_update(keys_in_cache)
-    if m_protected:
-        m_protected.intersection_update(keys_in_cache)
-    if m_ts:
-        for k in list(m_ts.keys()):
-            if k not in keys_in_cache:
-                m_ts.pop(k, None)
-                m_probation.discard(k)
-                m_protected.discard(k)
-                m_probation_hits.pop(k, None)
-
-    probation_candidates = m_probation & keys_in_cache
-    protected_candidates = m_protected & keys_in_cache
-
-    # If protected is oversized vs target, evict its oldest to reduce over-protection.
-    if protected_candidates and m_target_protected is not None and len(m_protected) > m_target_protected:
-        return _oldest_key(protected_candidates)
-    # Prefer evicting from probationary segment to avoid polluting protected items
-    if probation_candidates:
-        return _oldest_key(probation_candidates)
-    if protected_candidates:
-        return _oldest_key(protected_candidates)
-
-    # Fallback: evict the globally oldest if segmentation hasn't been set yet
-    if keys_in_cache:
-        return _oldest_key(keys_in_cache)
-    return None
+    Return the key of the cached object that will be evicted to make room for `obj`.
+    '''
+    return _policy.evict(cache_snapshot, obj)
 
 def update_after_hit(cache_snapshot, obj):
     '''
-    This function defines how the algorithm update the metadata it maintains immediately after a cache hit.
-    - Args:
-        - `cache_snapshot`: A snapshot of the current cache state.
-        - `obj`: The object accessed during the cache hit.
-    - Return: `None`
-    '''
-    global m_ts, m_probation, m_protected, m_probation_hits
-    _init_targets(cache_snapshot)
-    now = cache_snapshot.access_count
-    key = obj.key
-
-    # Ensure timestamp exists
-    if key not in m_ts:
-        m_ts[key] = now
-
-    # Conditional promotion: if protected is at/over target, require two touches in probation
-    if key in m_probation:
-        m_probation_hits[key] = m_probation_hits.get(key, 0) + 1
-        needs_two = (m_target_protected is not None and len(m_protected) >= m_target_protected)
-        if (not needs_two) or (m_probation_hits[key] >= 2):
-            m_probation.discard(key)
-            m_protected.add(key)
-            m_probation_hits.pop(key, None)
-            # Enforce quota in case we exceeded it due to promotion
-            _enforce_protected_quota()
-    elif key not in m_protected:
-        # If metadata was missing, treat as protected to avoid premature eviction
-        m_protected.add(key)
-        _enforce_protected_quota()
-
-    # Update recency timestamp
-    m_ts[key] = now
+    Update metadata immediately after a cache hit.
+    '''
+    _policy.update_after_hit(cache_snapshot, obj)
 
 def update_after_insert(cache_snapshot, obj):
     '''
-    This function defines how the algorithm updates the metadata it maintains immediately after inserting a new object into the cache.
-    - Args:
-        - `cache_snapshot`: A snapshot of the current cache state.
-        - `obj`: The object that was just inserted into the cache.
-    - Return: `None`
-    '''
-    global m_ts, m_probation, m_protected, m_probation_hits
-    _init_targets(cache_snapshot)
-    now = cache_snapshot.access_count
-    key = obj.key
-
-    # New insert starts in probationary segment
-    m_ts[key] = now
-    m_protected.discard(key)
-    m_probation.add(key)
-    m_probation_hits[key] = 0
+    Update metadata immediately after inserting a new object into the cache.
+    '''
+    _policy.update_after_insert(cache_snapshot, obj)
 
 def update_after_evict(cache_snapshot, obj, evicted_obj):
     '''
-    This function defines how the algorithm updates the metadata it maintains immediately after evicting the victim.
-    - Args:
-        - `cache_snapshot`: A snapshot of the current cache state.
-        - `obj`: The object to be inserted into the cache.
-        - `evicted_obj`: The object that was just evicted from the cache.
-    - Return: `None`
-    '''
-    global m_ts, m_probation, m_protected, m_probation_hits
-    evk = evicted_obj.key
-    # Remove all metadata for the evicted object
-    m_ts.pop(evk, None)
-    m_probation.discard(evk)
-    m_protected.discard(evk)
-    m_probation_hits.pop(evk, None)
-
+    Update metadata immediately after evicting the victim.
+    '''
+    _policy.update_after_evict(cache_snapshot, obj, evicted_obj)
 # EVOLVE-BLOCK-END
 
 # This part remains fixed (not evolved)
 def run_caching(trace_path: str, copy_code_dst: str):
     """Run the caching algorithm on a trace"""
     import os
     with open(os.path.abspath(__file__), 'r', encoding="utf-8") as f:
         code_str = f.read()
     with open(os.path.join(copy_code_dst), 'w') as f:
         f.write(code_str)
     from cache_utils import Cache, CacheConfig, CacheObj, Trace
     trace = Trace(trace_path=trace_path)
     cache_capacity = max(int(trace.get_ndv() * 0.1), 1)
     cache = Cache(CacheConfig(cache_capacity))
     for entry in trace.entries:
         obj = CacheObj(key=str(entry.key))
         cache.get(obj)
     with open(copy_code_dst, 'w') as f:
         f.write("")
     hit_rate = round(cache.hit_count / cache.access_count, 6)
     return hit_rate